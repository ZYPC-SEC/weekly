# 完成事项
+ Python基础学习[第五章之前的全部内容,并且每一节都进行了内容的反复测试演练(其实主要是尝试)]
+ 复盘解出了面试的那道TEA
+ 利用刚刚学的python写了几个好东西,下面细说
# 下周待做事项
+ 继续学习python
+ 学习别的题目的解法
# 本周学习的知识分享
## 对python大规律的发现
+ 把python学了两个晚上后我在某一次写代码时陷入了迷茫,我发现我不会写python代码,但不应该啊,我明明已经会python语法了,并且也有基本的编程思维,为什么离开一个短的任务之后就不会独自写了呢?于是我想到了c语言,PTA上的题目写得那么得心应手,我应该没那么菜才对,所以python和c语言之间应该是存在本质上,或者说是结构上的区别的
+ 还真是,简单来说,c语言是以操作为中心进行编写的,而python是以数据为中心进行编写的。有一个很有力的论证,c的第一步是int a;而py的第一步是a=,写c时想的应该是我要进行什么什么操作,而py应该想对这个数据我要怎样处理,这个道理简直处处都有印证,py里的数组叫列表,py里的函数总是作为.xx()放在数据后面,抓住这一点,在对其代码的理解和前期的编写流畅度上,我确实是感受到了很大的提升
## 知识内结回顾
+ 终端对话启用python/直接在对应文件夹内部python执行程序
+ print() 若有""内部直接输出,不作处理。不带""作为变量处理,输出其内容
+ print(f".....{变量}...")可拼接输出
+ print("......",变量)也能拼接输出
+ 逗号不在""内不做识别,在""在用于拼接变量和字符,在""内正常输出
+ xx.title()标题化变量,经过我的测试发现是段字符首大写,其他小写,与原文大小写无关
+ xx.upper()全大写  xx.lower()全小写
+ xx.rstrip() xx.lstrip() xx.strip()删除空白符
+ right side trip----x侧旅行,就是删除x测,协助记忆
+ +-*/相同,**表乘方
+ 浮点数只需要在使用时表明x.x就行,且使用/默认改为浮点运算
+ 经我测试发现强制类型转化仍有效,如int(2.99999999),结果是2
+ 大数内部_分组不识别
+ 全大写可指出某量为常量
+ #是注释符
+ xx[x]可指定列表项,依旧从0开始计数,带-就是倒数,从-1开始计数,同样可以用xx[x]=x来改变元素
+ .append()列表末尾增加元素 .insert()内部增加元素,经测试规律如下
+ [0,a,1,b,2,c.....]数字为插入点,字母为原变量
+ *xx为对xx的解包,避免输出列表格式,且不能在f""中使用
+ ""和''作用完全相同,只在多重包含中用于区分
+ del xx[]删除元素
+ xx=yy.pop()从yy弹出元素给xx,依旧可以指定位置
+ .remove('')知值时的删除元素方法
+ .sort()字母顺序排序,逆序为(reverse=True),sorted(xx)也可作为前置符
+ len()列表长度,不是字节,是元素数
+ for循环 for a in b: 意为对a由b得来执行:
+ 下面的内容应当缩进排序,编译器上打一个tab,直接编写四个空格为一个单位,且第一句不能不在首位,比如第一句打了一个空格,后一句不能补5个空格来进入循环
+ 值得一提的是虽热缩进会嵌套层级,但其实多个同一层级不是真的同级执行,在退出当前最高层级后才会执行,并重新判断下一个层级,所以不能被名字误导
+ range(x,y,z)从x到y-1生成数字,步长为z
+ xx[a:b]列表切片,从a到b,某侧为空自动拓展到最大位置
+ 元组是不可变列表,要修改就要重新定义
+ ## 部分代码展示
```python
key=[-1869584495, 268539025, 1080072337, 831522705]

for i,num in enumerate(key):

    rkey = hex(num & 0xFFFFFFFF)  
    print(f"key[{i}] = {num} -> {rkey}")
```
+ 这是学完for之后我立刻写的用来转化那个key的代码,数值就是面试时的那个key,当时enc,key,加密方式我都找到了,但是key不用工具转化不过来,简直是最绝望的死法,不过现在我会写了!二百三十三!!!
```python
enc = [
    0x34, 0x29, 0x29, 0x39, 0x2E, 0x3C, 0x01, 0x22, 
    0x15, 0x08, 0x25, 0x13, 0x09, 0x25, 0x18, 0x1B, 
    0x09, 0x13, 0x19, 0x25, 0x08, 0x1F, 0x0C, 0x1F, 
    0x08, 0x09, 0x1F, 0x07
]
key = 0x7A
result = ""
for a in enc:
    b = a ^ key
    result += chr(b)
print("解密结果:", result)
```
+ 一个简单的异或解密程序,里面的数值是一道nss新生赛题目,曾经我好像也要靠ai完成......(虽然说ai写不出来
``` python
shenmi = []
liebiao = ['da', 'fu', 'na', 'fu', 'da', 'fu', 'na', 'ha']
for liebiaos in liebiao:
    shenmi.insert(0,liebiaos)

import base64

hahaha = "5L2g55+l6YGTaGFuYWZ1ZGHnmoTmiJDliIbmmK/ku4DkuYjlkJc/"

print(base64.b64decode(hahaha.encode()).decode())

for chengfen in shenmi:
    print(chengfen)
    if chengfen == 'fu':
        print("发现fufu!!")
    print('-----------')
print("o(*≧▽≦)ツ┏━┓")
```
+ 学会一点python之后我就迫不及待地去搞抽象了,这就是那天晚上让我写完就忍不住唐笑起来了的抽象小代码,为什么想笑?快去运行一下吧~
## TEA
+ 虽然略显抽象,但我现在才大概把TEA完全搞懂了
+ 之前只是大概能乱点找到那三个关键块,enc,key,加密方式,然后发给ai大人摇尾乞怜。而现在,我已经今非昔比,也是成功进化成脚本小子,并且能大概对数据处理,对代码进行修改和理解了
```python
def tea_decrypt_correct(ciphertext_blocks, key):

    delta = 0x11451419
    key0, key1, key2, key3 = key
    n = 32
    
    results = []
    
    for ciphertext in ciphertext_blocks:
        v6, v5 = ciphertext
        
        # 计算总sum值
        sum_val = (delta * n) & 0xFFFFFFFF
        
        # 逆向解密（与加密顺序相反）
        for i in range(n):
            # 先解密v5（加密时后处理）
            v5 = (v5 - ((sum_val + v6) ^ (16 * v6 + key2) ^ ((v6 >> 5) + key3))) & 0xFFFFFFFF
            # 再解密v6（加密时先处理）
            v6 = (v6 - ((sum_val + v5) ^ (16 * v5 + key0) ^ ((v5 >> 5) + key1))) & 0xFFFFFFFF
            sum_val = (sum_val - delta) & 0xFFFFFFFF
        
        results.append((v6, v5))
    
    return results

# 密文
ciphertext_blocks = [
    (0x2D9793AF, 0x271AB059), 
    (0x3166EDC7, 0xD92DDA9A),  
    (0x16E38F5B, 0x49F0A29A), 
    (0x5F4B3FF3, 0xB83D1A71)   
]
# key
key = (0x90906791, 0x10019491, 0x40609891, 0x31900791)

# 解密所有块
plaintext_blocks = tea_decrypt_correct(ciphertext_blocks, key)

print("解密结果:")
for i, (v6, v5) in enumerate(plaintext_blocks):
    print(f"块{i+1}: {hex(v6)}, {hex(v5)}")
    
    # 转换为ASCII
    def to_ascii(v0, v1):
        result = b""
        for value in [v0, v1]:
            for j in range(4):
                result += bytes([(value >> (j * 8)) & 0xFF])
        try:
            return result.decode('utf-8', errors='ignore')
        except:
            return result.decode('latin-1', errors='ignore')
    
    ascii_result = to_ascii(v6, v5)
    print(f"  ASCII: {ascii_result}")

# 合并所有结果
print("\n合并后的flag:")
all_bytes = b""
for v6, v5 in plaintext_blocks:
    for value in [v6, v5]:
        for j in range(4):
            all_bytes += bytes([(value >> (j * 8)) & 0xFF])

print(f"完整字节: {all_bytes}")
print(f"十六进制: {all_bytes.hex()}")
print(f"最终flag: {all_bytes.decode('latin-1', errors='ignore')}")
```
+ 本来想着继续用c语言的,毕竟可以直接从伪c里复制加密方式然后修改,省下很多时间,虽然python是刚好要学的有点可惜,但是我仔细一看,我去!怎么python好像也能直接复制嘞???
+ 那还说啥了,瞌睡了就有人递枕头啊,找ai大人搞一下python解密代码顺便在温习一下python呗
+ 也是顺便把python里的定义函数给搞了,还有那些编码方式之类的,当时写搞哈纳伏打大人的代码时为了伪装及就稍微学了一些,这里也是了解的更多了👍
# 本周学习总结
+ 本周时间比较短,学的东西确实不多 再者虽然我想学逆向,但之前一直在搞web和misc,而且也没有好多同学出厂自带的python技能,所以逆向还是从头开始学习,说实话还是有点慢的,下一周或许也快不到哪去,毕竟马上就要期中了,但我还是会尽量找时间继续学习的
# 杂项
+ 学了markdown
+ 找了几个好网站