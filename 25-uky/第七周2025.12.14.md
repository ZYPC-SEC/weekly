# <font style="color:rgb(38, 38, 38);">完成事项</font>
1. ISCTF2025-wp
   >web题解已发<a href="https://uk5555544.github.io/2025/12/11/2025ISCTF%E9%83%A8%E5%88%86wp/">博客</a>
2. 找到一个比较权威的靶场PortSwigger
   >学习了DOM XSS
   >补全了js原型链知识
3. 有了自己的git图床
# <font style="color:rgb(38, 38, 38);">下周待做事项</font>
复习期末考试内容
# <font style="color:rgb(38, 38, 38);">本周学习的知识分享</font>
## DOM-based XSS
> 原型链污染与DOM型XSS息息相关，于是先在这个靶场学习了DOM-XSS攻击

DOM简单来说就是javaScript操作HTML页面的一个API，DOM-based XSS将可控的用户输入利用js注入到DOM元素中，从而实现攻击

寻找注入点方法:输入并加载数据->在源代码中查找数据所在的位置->在附近找到对应的js代码->分析js代码构造payload

+ #### document.write()
>document.write()方法将字符串写入HTML文档中，若字符串中包含html标签，则会被解析为对应的HTML元素

在搜索框中输入的数据包含在了src中，在附近找到对应的js代码
```javascript
function trackSearch(query) {
   document.write('<img src="/resources/images/tracker.gif?searchTerms='+query+'">');
}
var query = (new URLSearchParams(window.location.search)).get('search');
if(query) {
   trackSearch(query);
}
```
window.location即为当前页面的URL，search属性即为URL中的查询字符串部分

故123处即为注入点，payload: `"><script>alert(document.domain)</script>`
![](https://raw.githubusercontent.com/UK5555544/uky_images/main/blogs/20251211185816.png)
>document.domain属性返回当前网页的域名

+ #### element.innerHTML
>innerHTML属性可以获取或设置HTML元素的内容，将其嵌入到相应标签中
```javascript
document.getElementById('searchMessage').innerHTML = query;
```
需要注意的是innerhtml不会解析脚本元素，故\<script>在此处无法触发

其他payload:
```javascript
<img src=1 onerror=alert(1)>
```
加载名为x图片，失败时触发onerror事件
```javascript
<svg onload=alert(1)>
```
SVG是矢量图形格式，onload事件在元素加载完成后触发
```javascript
<iframe src=javascript:alert(1)>
```
iframe标签用于嵌入另一个HTML页面，src属性指定嵌入页面的URL，javascript:协议可直接执行js代码

+ #### jQuery
>jQuery是一个流行的JavaScript库，语法与原生js有所不同
```javascript
$(function(){
	$('#backLink').attr("href",(new URLSearchParams(window.location.search)).get('returnUrl'));
});
```
>attr()方法用于获取或设置元素属性值，$()用于选择元素，此语句的意思为将id为backLink的元素的href属性设置为URL中的returnUrl参数值

payload: `javascript:alert(1)`

其他jQuery利用函数:
```javascript
contains() //检查元素是否包含指定文本
add() //向元素添加内容
after() //在元素后插入内容
append() //在元素末尾添加内容
animate() //创建自定义动画效果
wrap() //将元素包裹在其他HTML元素中
```
+ #### 经典漏洞:hash变更
>URL中的hash部分常用于单页应用中标识页面状态

```javascript
$(window).on('hashchange', function(){
   var post = $('section.blog-list h2:contains(' + decodeURIComponent(window.location.hash.slice(1)) + ')');
   if (post) post.get(0).scrollIntoView();
});           
```
>slice(1)方法用于提取字符串的一部分，去掉#号，decodeURIComponent()用于解码URL编码，此串代码用作读取#后面的hash值，并在页面中查找对应标题并滚动到该位置

注入点即为#后的hash值，但这里存在一个问题，hash只有变更时才会触发事件，如果我们伪造链接发送给用户，就需要让他点击一次链接却能实现hash更替

这就需要\<iframe>标签，用于嵌套另一个HTML页面，让它加载完后触发url变更
```javascript
<iframe src="https://YOUR-LAB-ID.web-security-academy.net/#" onload="this.src+='<img src=x onerror=print()>'"></iframe>
```
其中this.src代表当前iframe的src属性，先创造一个空hash，再通过onload事件让它加载完后更改hash，从而触发hashchange事件

## 原型链污染
+ #### 关于python的补充
> 其实在 Python 中，严格来说没有原型链(Prototype)这个概念，对应的考点通常被称为Python Class Pollution(类污染)或Python属性覆盖漏洞。在25年的ISCTF中就出现了相关题目，让我不得不重视起来

除了经典的merge函数外，还有一些其他方法可以实现类污染：

##### 第三方库:pydash
漏洞函数：pydash.set_(obj, path, value)
>如果是普通的字典，set_ 只是设置键值对。但如果obj是一个类实例，pydash会尝试使用getattr/setattr进行属性访问

利用点就在于path的值，逃逸出当前对象，修改其类属性或全局变量
```python
import pydash
class User:
    def __init__(self):
        self.name = "guest"
isAdmin = False 

user = User()
path = "__init__.__globals__.isAdmin"
value = True
pydash.set_(user, path, value)
```
由于大部分函数为只读模式，不可覆盖。故此函数多用于覆盖配置

比如针对flask配置，可将path设为__init__.\_\_globals__.app.config_SECRET_KEY
>我之前在bac提到过，flask会用SECRET_KEY来签名session并储存在cookie里。而SECRET_KEY储存在app.config中，可以覆盖为自己的key，从而伪造session

对于json可以写
```json
{
    "__init__": {
        "__globals__": {
            "current_app": {
                "config": {
                    "SECRET_KEY": "uky123"
                }
            }
        }
    }
}
```
还有一种利用方法:通过类污染将app.config['DEBUG']覆盖为True，渲染出flask调试页面

漏洞函数:pydash.merge(target, source)
>target为对象，而source必须为json嵌套字典

```python
source = {
    "__class__": {
        "__init__": {
            "__globals__": {
                ...
            }
        }
    }
}
```
+ #### 关于javascript的补充
##### js原型链污染可以分为三种类型:
1. url参数
```url
https://vulnerable-website.com/?__proto__[evilProperty]=payload
```
>对象属性有两种访问方式:点操作符(.)和方括号([]):
\_\_proto__.evilProperty = 'payload'
\_\_proto__['evilProperty'] = 'payload'
2. JSON对象
>JSON.parse是javaScript中用于将JSON格式的字符串解析为javaScript对象的方法
```javascript
{
    "__proto__": {
        "evilProperty": "payload"
    }
}
```
3. DOM汇
>与DOM XSS结合，原型污染的接收点是本质上你能够通过原型污染访问的 JavaScript函数或DOM元素，它使你能够执行任意JavaScript或系统命令

##### js原型
js的对象原型有许多类型
```javascript
let myString = "";
Object.getPrototypeOf(myString);    // String.prototype

let myArray = [];
Object.getPrototypeOf(myArray);     // Array.prototype

let myNumber = 1;
Object.getPrototypeOf(myNumber);    // Number.prototype
```
不过他们都归根于一个原型Object.prototype
![](https://raw.githubusercontent.com/UK5555544/uky_images/main/blogs/20251214200421.png)
故可以通过Object.prototype来访问其他对象的原型

当一个对象创建时，它会继承其原型默认的所有属性和方法，**但如果在对象本身定义了同名属性或方法，则会覆盖原型中的对应项**

##### 客户端原型链污染
检测原型链污染可以用一下步骤:
1. 在可能的注入点里注入payload
>比如 url/?\_\_proto__[foo]=bar
这里可以多进行fuzz，\_\_proto\_\_.\_\_proto\_\_等都可以尝试
2. 在控制台检查污染是否成功
>在控制台输入Object.prototype.foo ，若返回 bar 则表示污染成功
##### 服务端原型链污染
>服务端原型链污染通常发生在Node.js等基于JavaScript的后端环境中，攻击者通过发送特制的请求，利用服务器端代码中的合并或赋值操作，将恶意属性注入到全局对象的原型中

常用方法:发送json数据到post请求中，因为服务器通常会用新或更新对象的 JSON 表示形式来响应

##### 绕过过滤
有些应用会对输入进行过滤，防止直接使用\_\_proto\_\_进行污染，我们可以利用myObject.constructor.prototype代替myObject.\_\_proto__

原理:每个JavaScript对象都有一个constructor属性，指向创建该对象的构造函数，而构造函数本身也有一个prototype属性，指向其原型对象

网站防止原型污染的一个明显方式是在将属性键合并到现有对象之前对其进行清理，如果只是简单删除一次违规键，则可以用双写绕过
```url
url?__pro__proto__to__.gadget=payload
```
 
# <font style="color:rgb(38, 38, 38);">本周学习总结</font>
学习了DOM XSS与原型链污染相关知识，补全了js原型链知识
