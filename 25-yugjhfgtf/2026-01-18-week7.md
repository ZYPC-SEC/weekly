# <font style="color:rgb(38, 38, 38);">完成事项</font>
+ 学习了DM语言

# <font style="color:rgb(38, 38, 38);">下周待做事项</font>
+ 刷点题也许
+ 理解下开发思路

# <font style="color:rgb(38, 38, 38);">本周学习的知识分享</font>

### 是什么

*DM*语言是一个名为*BYOND*的上古游戏引擎所用的编程语言
全称为DreamMaker，特征是使用巨量的对象继承
已经是九十年代的老引擎的老语言了，完全是Dead Language

![](https://pic1.imgdb.cn/item/696c45eb1031780e0fc6a5f2.png)

因为是游戏引擎的专有编程语言，所以它的优点和缺点都非常显著
比如专门为游戏引擎优化的实现逻辑，举个例子

##### 我需要做一个简陋的mud游戏界面，实现一个英雄角色，拥有名称、血量、物品栏

```
var/atom/movable/mob/living/carbon/human/PLAYER = new()
	var/player_name = "STEVE"
	var/player_health = 100
	var/list/inventory = list("剑", "盾")
	var/tmp/temporary_data  // 临时变量
	var/const/MAX_HEALTH = 200
```

我们来看看上面这是在干什么

```
var/***/***
 ^
```

*var/*是声明部分，一个var用来告诉程序将要创建新变量
var的使用相对自由，可以放在声明内外，创建全局和局部变量

```
var/***/***
     ^
```

如果注意力集中，我们能发现一点小区别

```
var/atom/movable/mob/living/carbon/human/PLAYER = new()
     ^
var/const/MAX_HEALTH = 200
      ^
```

这里箭头指向的一个*atom*，是普通的变量名，另一个*const*，是*修饰符*，用来告诉程序这里是全局变量,局部变量,常量等

也就是说在var的过程中我们有可选的*修饰符*和*类型*（类似c语言的变量声明，比如var/text，var/num)放在第二个位置用来限定声明

```
var/***/***
         ^
```



实际上最开始的在PLAYER下挨个var属性是有点麻烦的

```麻烦
	var/player_name = "STEVE"
	var/player_health = 100
```

DM支持类似python的定义方法也就是	

```
	PLAYER.player_name = "STEVE"
	PLAYER.player_health = 100
```

甚至可以直接

```
var/atom/movable/mob/living/carbon/human/PLAYER = new()
	name = "STEVE"
	health = 100
```



再往后，我们能发现，我们最开始的定义了继承自许多类，这段代码具体是说

```
var/atom/movable/mob/living/carbon/human/PLAYER = new()
 ^    ^     ^     ^    ^       ^     ^     ^       ^
定义 元素  可动物体 怪物  活物  碳基生物  人类   玩家   新生成
```

与其他语言类似，DM也有循环和判断，详细的类定义能帮助我们实现普适一些的机制，比如我们定义

```
var/atom/movable/mob/livingdead/carbon/zombie/ZOMBIE1 = new()
 ^    ^     ^     ^      ^         ^      ^      ^        ^
定义 元素  可动物体 怪物   活死人     碳基生物  僵尸   僵尸1    新生成
```

我们想要实现“碳基生物能被火焰伤害”和“治疗药水能治疗活物但是伤害活死人”这两项机制，就可以通过上面的
`***/carbon/***`和`***/livingdead/***`，`***/living/***`实现判断

##### 接下来是方法的实现

DM中的方法叫“过程”(proc)和“动词”(verb)
proc和def的使用非常相似

```
proc/heal(mob/M)
    if(istype(M, /mob/livingdead))
        var/damage = M.maxHealth / 10
        M.health -= damage
    else if(istype(M, /mob/living))
        var/healing = M.maxHealth / 10
        M.health += healing
```

这里我们就实现了上面的“治疗活物但伤害活死人”的机制，这里的*M*是形参，检测传入的M是什么来达成我们的需要

然后是*verb*系统，verb是DM语言独有的语法，这一专有系统继承自上古mud游戏，mud的特征之一是没有图形化界面，游戏内没有什么预设的按钮和选项给玩家选择，人物进行游戏互动需要手动输入特定的指令

```你听过北大侠客行吗
>>knock 宅院大门
>>看门丫鬟 探出头来问 “你是谁呀”
>>speak 看门丫鬟 hulu
>>看门丫鬟 说 "abababba，哈哈哈洋文我也会说"
>>knock 宅院大门
>>看门丫鬟 探出头来问 “你是谁呀”
>>ask 看门丫鬟 about 葫芦
>>看门丫鬟 说 "呀，这不是我家的葫芦吗，快请进"
```

verb系统本质上是为了便捷地设置类似的机制，但随着时代进步，新制作的游戏已经通过图形化界面淘汰了这种操作方式，但是我们还是要知道

```
/obj/item/药水/verb
    喝()
        set category = "物品"
        set name = "喝下药水"
        set desc = "喝下这瓶药水"
        var/mob/使用者 = usr
        if(istype(src, /obj/item/药水/治疗药水))
            heal(使用者)
```

这里这个*usr*是特殊变量，始终代指玩家或者说操作者，然后*使用者*是一个局部变量，用来传递对象，*src*是个地址，这里指使用对象“那个治疗药水”

###### 终于终于，我们完成了一堆代码，实现了创建英雄和喝药水的操作

能看出来我们的DM语言为游戏编程做了专门的优化，但是也非常显而易见的是，这种编程逻辑使得
离开原本的RPG游戏式思路再进行开发将会非常困难，对一个已经成型的游戏进行拓展开发也会非常非常麻烦

举个例子，我们写了个2d游戏，里面有所有的物品都能投掷，也有专门的手雷这种投掷武器，投掷物撞在墙上会被弹开，这是一个底层proc，现在我们想要开发一个粘性手雷，我们不可能重写所有物品的类来新加入一个比如
/wall_stickable的新类来决定投掷物会不会黏在墙上，更改更早的proc也不太可能，新机制的实现非常依赖于已经搭好的框架，绕开框架也许可以，但很可能会出错

先说到这吧

# <font style="color:rgb(38, 38, 38);">本周学习总结</font>

学DM，摸鱼，看椭曲，理解找曲线，但是看不懂计算过程在干嘛，摸鱼


# <font style="color:rgb(38, 38, 38);">杂项</font>

沉迷SS13，好玩😋
