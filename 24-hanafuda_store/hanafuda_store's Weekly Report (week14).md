# hanafuda_store's Weekly Report (week14)
## 密码算法
上周的缺空，这周内终于抽时间完善了，详见个人博客(https://hanafudastore.github.io/2025/01/16/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%B8%B8%E8%A7%81%E5%AF%86%E7%A0%81%E6%80%BB%E7%BB%93/)
## ADCTF出题
上周虽然也在出题，但是很多都还留有一些问题，比如那道python贪吃蛇游戏的题在上周出现了无法解包和反编译的问题，这周通过排查，解决了这些问题，并按照格式完善了题目的内容。同时，我还解决了一直困扰着我的安卓逆向出题，学习了java的部分语法和Android Studio的使用，并成功出题。
## Python学习
由于Python中的语法中函数和各种方法琳琅满目鱼龙混杂导致我虽然用了很多时间在学，但是一弄就是学一点忘一点，这次我选择了进行笔记的记录，帮助记忆和自己查看，内容可在个人博客中查看(https://hanafudastore.github.io/2025/03/11/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)
## 做题
这周主要攻克了VM虚拟机逆向的这道题
### [网鼎杯 2020 青龙组]singal
核心代码如下
```c
int __cdecl vm_operad(int *enc, int num114)
{
  int result; // eax
  char input[200]; // [esp+13h] [ebp-E5h] BYREF
  char temp; // [esp+DBh] [ebp-1Dh]
  int case_8; // [esp+DCh] [ebp-1Ch]
  int v6; // [esp+E0h] [ebp-18h]
  int find_flag; // [esp+E4h] [ebp-14h]
  int j; // [esp+E8h] [ebp-10h]
  int i; // [esp+ECh] [ebp-Ch]

  i = 0;
  j = 0;
  find_flag = 0;
  v6 = 0;
  case_8 = 0;
  while ( 1 )
  {
    result = i;                                 // result=0
    if ( i >= num114 )
      return result;
    switch ( enc[i] )
    {
      case 1:
        input[v6 + 100] = temp;
        ++i;
        ++v6;
        ++j;
        break;
      case 2:
        temp = enc[i + 1] + input[j];
        i += 2;
        break;
      case 3:
        temp = input[j] - LOBYTE(enc[i + 1]);
        i += 2;
        break;
      case 4:
        temp = enc[i + 1] ^ input[j];
        i += 2;
        break;
      case 5:
        temp = enc[i + 1] * input[j];
        i += 2;
        break;
      case 6:
        ++i;
        break;
      case 7:
        if ( input[find_flag + 100] != enc[i + 1] )// 检验输入（一位）
        {
          printf("what a shame...");
          exit(0);
        }
        ++find_flag;
        i += 2;
        break;
      case 8:
        input[case_8] = temp;
        ++i;
        ++case_8;
        break;
      case 10:
        read(input);
        ++i;
        break;
      case 11:
        temp = input[j] - 1;
        ++i;
        break;
      case 12:
        temp = input[j] + 1;
        ++i;
        break;
      default:
        continue;
    }
  }
}
```
联想到图灵机的原理，可认为该程序用传入的enc模拟纸带，通过纸带上的不同内容对数据进行不同的操作，由case 7可知该指令对应的是对flag的检查，同时可知纸带上的7后面一位的数据一定是flag密文。再分别逆向其他操作码对应的数据操作过程，同时提取纸带上的内容可得exp如下
```c
#include<string.h>
#include<stdio.h>
unsigned char opcode[] =
{
  0x0A, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00,
  0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00,
  0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x21, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x20, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x51, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00,
  0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x0C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0B, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00,
  0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x08, 0x00,
  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00,
  0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00,
  0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x20, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0C, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x22, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3F, 0x00,
  0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x07, 0x00,
  0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x33, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x18, 0x00,
  0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0xA7, 0xFF, 0xFF, 0xFF,
  0x07, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x07, 0x00,
  0x00, 0x00, 0xF1, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00,
  0x28, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x84, 0xFF,
  0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0xC1, 0xFF, 0xFF, 0xFF,
  0x07, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x07, 0x00,
  0x00, 0x00, 0x7A, 0x00, 0x00,
};
int *a = (int *)opcode;
int __cdecl vm_operad(int *opcode, int a2)
{
  int order[114] = {};//执行顺序
  char flag[100]; 
  char v4[200]; //Str[] 
  char v5; 
  int m; 
  int z; 
  int y; 
  int x; 
  int i; 
  int s = 0;
  i = 0;
  x = 0;
  y = 0;
  z = 0;
  m = 0;
  while (1)
  {
    if ( i >= a2 )//继续循环
      break;
    switch ( opcode[i] )
    {
      case 1:
        v4[z+100] = v5;
        ++i;
        ++z;
        ++x;
        break;
      case 2:
        v5 = opcode[i + 1] + flag[x];
        i += 2;
        break;
      case 3:
        v5 = flag[x] - opcode[i + 1];
        i += 2;
        break;
      case 4:
        v5 = opcode[i + 1] ^ flag[x];
        i += 2;
        break;

      case 5:
        v5 = opcode[i + 1] * flag[x];
        i += 2;
        break;
      case 6:
        ++i;
      case 7:
        v4[y+100] = opcode[i + 1];
        printf("%#x, ",v4[y+100]);//打印比较的opcode,这里%#x是表示16进制输出时会带%号 
        ++y;
        i += 2;
        break;
      case 8:
        flag[m] = v5;
        ++i;
        ++m;
        break;
      case 10:
        scanf("%s",flag);//输入点
        ++i;
        break;
      case 11:
        v5 = flag[x] - 1;
        ++i;
        break;
      case 12:
        v5 = flag[x] + 1;
        ++i;
        break;
    }
    printf("%d, ",i);//打印每次使用的索引
  }
}
int main()
{
    vm_operad(a,114);
    return 0;
}
```
### [GDOUCTF 2023]L！s！
本题是分析两个极为相似程序的细微区别，需要使用插件bindiff。先用IDA分别分析两个程序，保存分析结果得到两个i64文件，然后在bindiff的工作区打开这两个文件，分析如下：
![](http://m.qpic.cn/psc?/V52mtLJJ3HJION2p4keN1yJtcH3fCpcu/LiySpxowE0yeWXwBdXN*SSoLlh7UqUy6XMw3TekJFBxg.PTGpwIkrDH76tQ1K5XJV8jsmvMeGrpMVgfanS8jb10JDfd*zDiIc9cykPTGMIM!/b&bo=wQZwBMEGcAQDByI!&rf=viewer_4)
![](http://m.qpic.cn/psc?/V52mtLJJ3HJION2p4keN1yJtcH3fCpcu/LiySpxowE0yeWXwBdXN*SWmz8o9tyahBGB6t6qnQjyjHLiMu6i9fy7pk4g45gs9qxjS.UDfcsrPdUp.RyEgx00I.xHX8vFGaJsWiBpj*0Uw!/b&bo=vwZwBL8GcAQDByI!&rf=viewer_4)
通过分析找到相似率最低的函数，其即为我们要找的关键函数，用IDA再次打开分析，可以看到关键代码
```c
LABEL_7:
        if ( v9 && !v9[1] )
        {
          *(_QWORD *)&lmao[8] = 0x3F7D132A2A252822LL;
          *(_QWORD *)lmao = 0x7D2E370A180F1604LL;
          *(_QWORD *)&lmao[24] = 0x31207C7C381320LL;
          *(_QWORD *)&lmao[16] = 0x392A7F3F39132D13LL;
          v18 = lmao;
          do
            *v18++ ^= **(_BYTE **)v7;
          while ( &lmao[31] != v18 );
          puts(lmao);
        }
```
可知核心代码是异或，但是不知道异或的秘钥，可尝试爆破，exp如下：
```c
#include<stdio.h>
int main()
{
	char a[] = { 0x04,0x16,0x0F,0x18,0x0A,0x37,0x2E,0x7D,0x22,0x28,0x25,0x2A,0x2A,0x13,0x7D,0x3F,0x13,0x2D,0x13,0x39,0x3F,0x7F,0x2A,0x39,0x13,0x2D,0x13,0x39,0x3F,0x7F,0x2A,0x39,0x20,0x13,0x38,0x7C,0x7C,0x20,0x31,0x00 };
	int i = 0;
	int j = 0;
	for (i = 0; i < 256; i++)
	{
		for (j = 0; j < 50; j++)
		{
			printf("%c", a[j]^i);
		}
		printf("\n");
	}

	return 0;
}
```
可得flag为HZCTF{b1ndiff_1s_a_us3ful_t00l}