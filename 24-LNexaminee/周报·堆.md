# 周报 · 堆

## 堆利用

在该章节中，我们会按照如下的步骤进行介绍

1. 介绍我们所熟知的动态内存分配的堆的宏观操作
2. 介绍为了达到这些操作所使用的数据结构
3. 介绍利用这些数据结构实现堆的分配与回收的具体操作
4. 由浅入深地介绍堆的各种利用技巧。

## 堆概述

>可以提供动态分配的内存
>
>堆管理器处于用户程序与内核中间，主要做以下工作
>
>1. 响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。
>2. 管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。

* malloc

>~~~c
>/*
>  malloc(size_t n)
>  返回一个指向新分配的至少 n 字节内存块的指针。如果空间不足，返回 null。
>  在 ANSI C 系统中，失败时还会将 errno 设置为 ENOMEM。
>  
>  如果 n 为 0，malloc 会返回一个最小尺寸的内存块（大多数 32 位系统为 16 字节，
>  64 位系统为 24 或 32 字节）。在多数系统中，size_t 是无符号类型，因此传入负数参数
>  会被视为请求极大的内存空间，通常会失败。不同系统支持的最大 n 值不同，
>  但始终小于 size_t 类型能表示的最大值。
>*/
>~~~
>
>malloc 函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况进行了处理
>
>- 当 n=0 时，返回当前系统允许的堆的最小内存块。
>- 当 n 为负数时，由于在大多数系统上，**size_t 是无符号数（这一点非常重要）**，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。

* free

>~~~c
>/*
>  free(void* p)
>  释放由 p 指向的内存块，该内存块必须是通过 malloc 或相关函数（如 realloc）分配的。
>  如果 p 是空指针（NULL），free 函数不会有任何效果。
>  如果 p 已经被释放过，调用 free(p) 可能导致不可预测的（通常是灾难性的）后果。
>  除非通过 mallopt 禁用此功能，否则释放非常大的内存块时，系统会自动将未使用的内存归还给操作系统，从而减少程序占用的内存总量。
>*/
>~~~
>
>free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。
>
>该函数也同样对异常情况进行了处理
>• 当 p 为空指针时，函数不执行任何操作。
>• 当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 double free。
>• 除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。

* mmap

>malloc 会使用 [mmap](http://lxr.free-electrons.com/source/mm/mmap.c?v=3.8#L1285) 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。
>
>也就是申请大块内存

* sbrk

>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 [brk](https://en.wikipedia.org/wiki/Sbrk) 的大小来向操作系统申请内存。
>
>初始时，堆的起始地址 [start_brk](http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365) 以及堆的当前末尾 [brk](http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365) 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同
>
>- 不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。
>- 开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。

* 多线程支持

>在 glibc 的 ptmalloc 实现中，比较好的一点就是支持了多线程的快速访问。在新的实现中，所有的线程共享多个堆。
>
>虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率, 说白了就是预支，这一块连续的内存区域为 arena（预支空间）。此外，我们称由主线程申请的内存为 main_arena。后续的申请的内存会一直从这个 arena 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加 brk 的方式来增加堆的空间。
>
>类似地，arena 也可以通过减小 brk 来缩小自己的空间。

## 堆的相关数据结构

* ### 微观结构

  * malloc_chunk

    >在程序的执行过程中，我们称由 malloc 申请的内存为 `chunk` 。这块内存在 ptmalloc 内部用 malloc_chunk 结构体来表示。当程序申请的 `chunk` 被 free 后，会被加入到相应的空闲管理列表中
    >
    >空闲管理列表
    >
    >>当堆被free内存不会马上回到系统中，而是被glibc留下备用，这个备用的地方就是空闲管理列表，接下来所讲到的bin就是其中的几种
    >
    >~~~c
    >/*
    >  此结构体声明具有误导性（但准确且必要）。它声明了一种对内存的“视图”，
    >  允许从已知基址偏移访问必要字段。具体解释见下文。
    >*/
    >struct malloc_chunk {
    >
    >  INTERNAL_SIZE_T      prev_size;  /* 前一个内存块的大小（仅当前一个块空闲时有效） */
    >  INTERNAL_SIZE_T      size;       /* 当前块的总大小（包含头部开销） */
    >
    >  struct malloc_chunk* fd;         /* 双向链表前向指针——仅在块空闲时使用 */
    >  struct malloc_chunk* bk;         /* 双向链表后向指针——仅在块空闲时使用 */
    >
    >  /* 仅用于大内存块：指向下一个更大尺寸块的指针 */
    >  struct malloc_chunk* fd_nextsize; /* 大块双向链表前向指针——仅在块空闲时使用 */
    >  struct malloc_chunk* bk_nextsize; /* 大块双向链表后向指针——仅在块空闲时使用 */
    >};
    >~~~
    >
    >各个字段的具体的解释如下：
    >• prev_size, 如果该 chunk 的 物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小） 是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。这里的前一 chunk 指的是较低地址的 chunk 。
    >• size ，该 chunk 的大小，大小必须是 MALLOC_ALIGNMENT 的整数倍。如果申请的内存大小不是 MALLOC_ALIGNMENT 的整数倍，会被转换满足大小的最小的 MALLOC_ALIGNMENT 的倍数，这通过 request2size() 宏完成。32 位系统中， MALLOC_ALIGNMENT 可能是 4 或 8 ；64 位系统中，MALLOC_ALIGNMENT 是 8。 
    >
    >* size字段的妙用
    >
    >> **最低 3 位标志**：
    >>
    >> - `PREV_INUSE`（最低位）：前一个块是否在使用中（1=使用中，0=空闲）。
    >> - `IS_MMAPPED`（倒数第二位）：是否通过 `mmap` 分配（大块直接映射）。
    >> - `NON_MAIN_ARENA`（倒数第三位）：是否属于非主分配区。
    >
    >* fd，bk。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。 chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下
    >  • fd 指向下一个（非物理相邻）空闲的 chunk 。
    >  • bk 指向上一个（非物理相邻）空闲的 chunk 。
    >  • 通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理。
    >  • fd_nextsize， bk_nextsize，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。
    >  • fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。
    >  • bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。
    >  • 一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。
    >
    > 我们称一个已经分配的 chunk的前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处。
    >当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前 chunk 使用。这就是 chunk 中的空间复用。
    >
    >一般情况下，物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。

  * bin

    >在具体的实现中，ptmalloc 采用分箱式方法对空闲的 chunk 进行管理。首先，它会根据空闲的 chunk 的大小以及使用状态将 chunk 初步分为 4 类：fast bins，small bins，large bins，unsorted bin。每类中仍然有更细的划分，相似大小的 chunk 会用双向链表链接起来。也就是说，在每类 bin 的内部仍然会有多个互不相关的链表来保存不同大小的 chunk。
    >
    >数组中的 bin 依次如下
    >1. 第一个为 unsorted bin，字如其面，这里面的 chunk 没有进行排序，存储的 chunk 比较杂。
    >2. 索引从 2 到 63 的 bin 称为 small bin，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为 2 个机器字长，即 32 位相差 8 字节，64 位相差 16 字节。
    >3. small bins 后面的 bin 被称作 large bins。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的 chunk 同样按照最近使用顺序排列。

    * fast bin

      >~~~c
      >/*
      >   Fastbins（快速空闲链表）
      >
      >   这是一个由多个单链表组成的数组，用于存放最近被释放的小内存块。Fastbins
      >   中的链表不是双向链接的（仅单链表）。单链表操作更快，且这些链表中的块永远不会
      >   从中间被移除，因此无需双向链接。此外，与普通的内存块链表不同，Fastbins 不遵循
      >   先进先出（FIFO）规则，而是使用后进先出（LIFO）规则，因为在 Fastbins 的短暂使用
      >   场景中，顺序并不重要。
      >
      >   Fastbins 中的内存块会保留其“正在使用”标记（inuse bit），因此它们无法与其他空闲块
      >   合并。只有当调用 malloc_consolidate 函数时，Fastbins 中的所有块才会被释放并与其他
      >   空闲块合并。
      >*/
      >typedef struct malloc_chunk *mfastbinptr;  // 定义 Fastbins 链表指针类型
      >
      >/*
      >   Fastbins 数组定义在 malloc_state 结构体中：
      >   mfastbinptr fastbinsY[ NFASTBINS ];  // NFASTBINS 是 Fastbins 的数量
      >*/
      >~~~
      >
      >fastbin属于是一类专门存放小包裹的地址，运用了单链表和栈式存储（**LIFO 顺序**）
      >
      >ptmalloc 默认情况下会调用 set_max_fast(s) 将全局变量 global_max_fast 设置为 DEFAULT_MXFAST，也就是设置 fast bins 中 `chunk` 的最大值。当 MAX_FAST_SIZE 被设置为 0 时，系统就不会支持 fastbin 。
      >
      >### **对 Pwn 手的关键知识点**
      >
      >| **特性**         | **技术细节**                                                 | **攻击意义**                                                 |
      >| :--------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
      >| **单链表**       | 仅通过 `fd`（前向指针）链接，无 `bk`（后向指针）             | 攻击者只需修改 `fd` 指针即可劫持链表，操作更简单（如 `Fastbin Attack`）。 |
      >| **LIFO 顺序**    | 最新释放的块最先被分配（类似“叠盘子，取最上面的”）           | 可通过控制释放顺序构造特定内存布局（double free）。          |
      >| **不合并**       | 块释放后保留 `inuse` 标记，相邻空闲块不合并                  | 维持内存块的独立性，防止意外破坏攻击链（ Double Free）。     |
      >| **触发合并条件** | 调用 `malloc_consolidate`（如分配大内存时）会合并 Fastbins 中的块 | 攻击中需避免触发此操作，否则可能破坏构造的漏洞链。           |

        ~~~ c
      初始状态：Fastbin 链表为空
      +----------------+
      | fastbinsY[0] → NULL
      +----------------+
      
      释放块 A 后：
      +----------------+    +----------------+
      | fastbinsY[0] → A → NULL
      +----------------+    +----------------+
      
      Double Free 后（绕过检测）：
      +----------------+    +----------------+    +----------------+
      | fastbinsY[0] → A → A → NULL
      +----------------+    +----------------+    +----------------+
      
      修改 fd 指向 fake_addr：
      +----------------+    +----------------+    +----------------+
      | fastbinsY[0] → A → fake_addr → NULL
      +----------------+    +----------------+    +----------------+
        ~~~

    * small bin

      >small bins 中每个 `chunk` 的大小与其所在的 bin 的 index 的关系为：chunk_size = 2 * SIZE_SZ *index（通常为 `0x80` 到 `0x400` 字节），具体如下
      >
      >| 下标 | SIZE_SZ=4（32 位） | SIZE_SZ=8（64 位） |
      >| :--- | :----------------- | :----------------- |
      >| 2    | 16                 | 32                 |
      >| 3    | 24                 | 48                 |
      >| 4    | 32                 | 64                 |
      >| 5    | 40                 | 80                 |
      >| x    | 2 * 4 * x          | 2 * 8 * x          |
      >| 63   | 504                | 1008               |
      >
      > small bins 中一共有 62 个循环双向链表，简单地说就是一个大列表套着六十二个小链表的结构，每个链表中存储的 `chunk` 大小都一致。比如对于 32 位系统来说，下标 2 对应的双向链表中存储的 `chunk` 大小为均为 16 字节。每个链表都有链表头结点，这样可以方便对于链表内部结点的管理。此外，**small bins 中每个 bin 对应的链表采用队列结构（先进先出）**，所以同一个链表中先被释放的 `chunk` 会先被分配出去。
      >
      >### **Small Bins 对 Pwn 手的关键知识点**
      >
      >Small Bins 是 glibc 堆管理器中用于管理中等大小内存块（通常为 `0x80` 到 `0x400` 字节）的双向链表结构，以下是其核心特点及攻击意义：
      >
      >| **特性**      | **技术细节**                                                 | **攻击意义**                                                 |
      >| :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
      >| **双向链表**  | 使用 `fd`（前向指针）和 `bk`（后向指针）维护链表结构         | 攻击者可伪造 `fd/bk` 触发 `unlink` 操作，实现任意地址写（需绕过安全检查）。 |
      >| **FIFO 顺序** | 分配时从链表头部取块，释放时插入链表尾部                     | 通过控制释放顺序构造稳定的内存布局（如堆重叠）。             |
      >| **合并机制**  | 释放时检查相邻块是否空闲，若空闲则合并为更大的块             | 利用合并操作触发非预期的内存块重叠（如 `off-by-one` 触发合并）。 |
      >| **固定大小**  | 每个 Small Bin 管理固定大小的内存块（如 0x80、0x90、...、0x400） | 需精确控制块大小以命中目标 Bin。                             |

    * large bin

      >large bins 中一共包括 63 个 bin，每个 bin 中的 `chunk` 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 `chunk` 大小之间的公差一致，具体如下：
      >
      >| 组   | 数量 | 公差    |
      >| :--- | :--- | :------ |
      >| 1    | 32   | 64B     |
      >| 2    | 16   | 512B    |
      >| 3    | 8    | 4096B   |
      >| 4    | 4    | 32768B  |
      >| 5    | 2    | 262144B |
      >| 6    | 1    | 不限制  |
      >
      >如上，是一个大列表套小列表套链表的结构
      >
      > 分组源代码
      >
      >~~~ c
      >#define largebin_index_32(sz)                                                  \
      >    (((((unsigned long) (sz)) >> 6) <= 38)                                     \
      >         ? 56 + (((unsigned long) (sz)) >> 6)                                  \
      >         : ((((unsigned long) (sz)) >> 9) <= 20)                               \
      >               ? 91 + (((unsigned long) (sz)) >> 9)                            \
      >               : ((((unsigned long) (sz)) >> 12) <= 10)                        \
      >                     ? 110 + (((unsigned long) (sz)) >> 12)                    \
      >                     : ((((unsigned long) (sz)) >> 15) <= 4)                   \
      >                           ? 119 + (((unsigned long) (sz)) >> 15)              \
      >                           : ((((unsigned long) (sz)) >> 18) <= 2)             \
      >                                 ? 124 + (((unsigned long) (sz)) >> 18)        \
      >                                 : 126)
      >
      >#define largebin_index_32_big(sz)                                              \
      >    (((((unsigned long) (sz)) >> 6) <= 45)                                     \
      >         ? 49 + (((unsigned long) (sz)) >> 6)                                  \
      >         : ((((unsigned long) (sz)) >> 9) <= 20)                               \
      >               ? 91 + (((unsigned long) (sz)) >> 9)                            \
      >               : ((((unsigned long) (sz)) >> 12) <= 10)                        \
      >                     ? 110 + (((unsigned long) (sz)) >> 12)                    \
      >                     : ((((unsigned long) (sz)) >> 15) <= 4)                   \
      >                           ? 119 + (((unsigned long) (sz)) >> 15)              \
      >                           : ((((unsigned long) (sz)) >> 18) <= 2)             \
      >                                 ? 124 + (((unsigned long) (sz)) >> 18)        \
      >                                 : 126)
      >
      >// XXX It remains to be seen whether it is good to keep the widths of
      >// XXX the buckets the same or whether it should be scaled by a factor
      >// XXX of two as well.
      >#define largebin_index_64(sz)                                                  \
      >    (((((unsigned long) (sz)) >> 6) <= 48)                                     \
      >         ? 48 + (((unsigned long) (sz)) >> 6)                                  \
      >         : ((((unsigned long) (sz)) >> 9) <= 20)                               \
      >               ? 91 + (((unsigned long) (sz)) >> 9)                            \
      >               : ((((unsigned long) (sz)) >> 12) <= 10)                        \
      >                     ? 110 + (((unsigned long) (sz)) >> 12)                    \
      >                     : ((((unsigned long) (sz)) >> 15) <= 4)                   \
      >                           ? 119 + (((unsigned long) (sz)) >> 15)              \
      >                           : ((((unsigned long) (sz)) >> 18) <= 2)             \
      >                                 ? 124 + (((unsigned long) (sz)) >> 18)        \
      >                                 : 126)
      >
      >#define largebin_index(sz)                                                     \
      >    (SIZE_SZ == 8 ? largebin_index_64(sz) : MALLOC_ALIGNMENT == 16             \
      >                                                ? largebin_index_32_big(sz)    \
      >                                                : largebin_index_32(sz))
      >~~~
      >
      >这段代码就不作翻译直接解释了（懒）
      >
      >以上glibc源代码相当于解释了如何将不同大小的内存块分组，相当于在一个物流中心分拣快递，因为large bin中的链表并不是让同样的大小而是大小相近的chunk分配到同一个组中，这也就相当于管理员按照重量划分快递分组，而以上代码就是一套自动分拣规则，通过位运算快速判断包裹属于哪个区域
      >
      >32位：
      >
      >>使用宏 `largebin_index_32`，分组规则如下：
      >>
      >>| **区间范围（字节）** | **计算方式**         | **对应索引** |
      >>| :------------------- | :------------------- | :----------- |
      >>| `64 ~ 2559`          | `(size >> 6) + 56`   | 56 ~ 95      |
      >>| `2560 ~ 5119`        | `(size >> 9) + 91`   | 91 ~ 110     |
      >>| `5120 ~ 10239`       | `(size >> 12) + 110` | 110 ~ 119    |
      >>| `10240 ~ 20479`      | `(size >> 15) + 119` | 119 ~ 123    |
      >>| `20480 ~ 40959`      | `(size >> 18) + 124` | 124 ~ 126    |
      >>| `≥40960`             | 固定索引126          | 126          |
      >>
      >>使用宏 `largebin_index_32_big`，分组更稀疏：
      >>
      >>| **区间范围（字节）** | **计算方式**         | **对应索引** |
      >>| :------------------- | :------------------- | :----------- |
      >>| `64 ~ 2943`          | `(size >> 6) + 49`   | 49 ~ 94      |
      >>| `2944 ~ 5119`        | `(size >> 9) + 91`   | 91 ~ 110     |
      >>| `5120 ~ 10239`       | `(size >> 12) + 110` | 110 ~ 119    |
      >>| `10240 ~ 20479`      | `(size >> 15) + 119` | 119 ~ 123    |
      >>| `20480 ~ 40959`      | `(size >> 18) + 124` | 124 ~ 126    |
      >>| `≥40960`             | 固定索引126          | 126          |
      >
      >64位：
      >
      >>使用宏 `largebin_index_64`，分组规则更密集：
      >>
      >>| **区间范围（字节）** | **计算方式**         | **对应索引** |
      >>| :------------------- | :------------------- | :----------- |
      >>| `512 ~ 2559`         | `(size >> 6) + 48`   | 48 ~ 95      |
      >>| `2560 ~ 5119`        | `(size >> 9) + 91`   | 91 ~ 110     |
      >>| `5120 ~ 10239`       | `(size >> 12) + 110` | 110 ~ 119    |
      >>| `10240 ~ 20479`      | `(size >> 15) + 119` | 119 ~ 123    |
      >>| `20480 ~ 40959`      | `(size >> 18) + 124` | 124 ~ 126    |
      >>| `≥40960`             | 固定索引126          | 126          |
      >
      >### **对 Pwn 手的关键知识点**
      >
      >| **特性**                | **技术细节**                                                 | **攻击意义**                                                 |
      >| :---------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
      >| **双向链表 + 大小排序** | 每个 bin 中的块按大小降序排列，`fd_nextsize` 和 `bk_nextsize` 指向更大/更小的块 | 可通过篡改指针构造异常链表，实现任意地址分配（如 `House of Storm`）。 |
      >| **合并机制**            | 释放时会合并相邻空闲块，形成更大的块                         | 利用合并触发堆重叠（Heap Overlap）或泄露 `main_arena` 地址。 |
      >| **大块管理范围**        | 每个 bin 管理一个**大小区间**（如 1024~1536 字节）           | 需精确控制块大小以命中目标 bin，构造特定内存布局。           |

    * unsorted bin

      >unsorted bin 可以视为空闲 `chunk` 回归其所属 bin 之前的缓冲区，就好比一个临时货架，所有刚到的包裹（刚释放的块）或拆分后剩下的包裹碎片（分割后的剩余块）都会先放在这里
      >
      >~~~ c
      >/*
      >  Unsorted chunks（未排序的块）
      >
      >  所有从块分割中产生的剩余部分，以及所有被释放的块，
      >  首先被放入“unsorted” bin 中。在内存分配时（malloc），
      >  它们会获得一次被重新使用的机会，如果未被使用，则会被转移到常规的 bin 中。
      >  因此，unsorted_chunks 本质上是一个队列：
      >  - 释放操作（和 malloc_consolidate）会将块加入队列，
      >  - 分配操作（malloc）会从队列中取出块（使用或转移到其他 bin）。
      >
      >  Unsorted chunks 永远不会设置 NON_MAIN_ARENA 标志，
      >  因此在比较块大小时无需考虑该标志。
      >*/
      >~~~
      >
      >1. 临时存放：新包裹不会直接分类到固定区域（如large bin、small bin），而是先在临时货架等待。
      >2. 优先处理：当有新的分拣请求（malloc）时，分拣员（内存管理器）会先检查临时货架，看看有没有合适的包裹直接发出，其中遵循队列规则（FIFO）。
      >3. 二次分类：如果包裹在临时货架放了一轮还没被领走，就会被转移到固定的货架（small/large bins）中。
      >4. 统一规格：临时货架上的包裹没有特殊标签（如“NON_MAIN_ARENA”），分拣员只需按大小处理。
      >
      >unsorted bin 处于我们之前所说的 bin 数组下标 1 处。故而 unsorted bin 只有一个链表。unsorted bin 中的空闲 `chunk` 处于乱序状态，主要有两个来源
      >
      >- 当一个较大的 `chunk` 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。
      >- 释放一个不属于 fast bin 的 chunk，并且该 `chunk` 不和 top `chunk` 紧邻时，该 `chunk` 会被首先放到 unsorted bin 中。
      >
      >### **对 Pwn 手的关键知识点**
      >
      >| **特性**      | **技术细节**                                   | **攻击意义**                                                 |
      >| :------------ | :--------------------------------------------- | :----------------------------------------------------------- |
      >| **双向链表**  | 使用 `fd` 和 `bk` 维护双向链表结构             | 攻击者可读取 `fd`/`bk` 泄露 `main_arena` 地址（计算 `libc` 基址）。 |
      >| **FIFO 行为** | 实际表现为“先进先出”                           | 通过控制释放顺序构造特定的内存布局。                         |
      >| **合并机制**  | 释放时若相邻块为空闲，则合并成大块             | 利用合并触发堆块重叠（Heap Overlap）或扩展攻击面。           |
      >| **临时性**    | 块在 unsorted bin 中最多存活一次 `malloc` 遍历 | 需快速利用，否则块会被转移到其他 bin 中。                    |
      >
      >分配顺序大于fast bin，当fast bin无法满足的时候在unsorbed bin中分配，如果还是无法满足，去small和large中找
      >
      > ### 协作流程
      >
      >##### **(1) 内存释放时的流向**
      >
      >- **小内存块（<0x80）** → 直接进入 **Fastbins**（不合并，保留 `inuse` 标记）。
      >- **其他内存块** → 进入 **Unsorted Bin**（合并相邻空闲块）。
      >
      >##### **(2) 内存分配时的交互**
      >
      >1. **优先查找 Fastbins**：
      >   - 若请求大小匹配 Fastbins 的某个链表，直接取出头部块（LIFO）。
      >   - **未命中 Fastbins** → 进入下一步。
      >2. **处理 Unsorted Bin**：
      >   - 遍历 Unsorted Bin 中的块，尝试直接分配或切割后分配。
      >   - **切割后的剩余块** → 转移到对应的 Small/Large Bin。
      >3. **触发合并（malloc_consolidate）**：
      >   - 当请求大内存时（如超过 `MMAP_THRESHOLD`），会合并所有 Fastbins 中的块到 Unsorted Bin。

  * **通用宏**top chunk

    >~~~ c
    >/*
    >  Top（顶部块）
    >
    >  最顶部的可用内存块（即紧邻可用内存末尾的块）会被特殊处理。它永远不会被包含在任何 bin 中，
    >  只有在没有其他可用块时才会被使用，并且如果它非常大（参见 M_TRIM_THRESHOLD），
    >  则会将其释放回系统。由于 top 最初指向一个初始大小为 0 的 bin，
    >  因此在第一次 malloc 请求时会强制扩展堆，从而避免了在 malloc 中编写特殊代码
    >  来检查它是否存在。但在从系统获取内存时，我们仍然需要这样做，因此我们让
    >  initial_top 在初始化和第一次调用 sysmalloc 之间的时间段内将该 bin 视为合法但
    >  不可用的块。（这有些微妙，因为它依赖于在这段时间内前两个字也为零。）
    >*/
    >
    >/* 方便的是，unsorted bin 可以在第一次调用时用作 dummy top */
    >#define initial_top(M) (unsorted_chunks(M))
    >~~~
    >
    >程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 chunk。这个 chunk 不属于任何一个 bin，它的作用在于当所有的 bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对 heap 进行扩展后再进行分配。在 main arena 中通过 sbrk 扩展 heap，而在 thread arena 中通过 mmap 分配新的 heap。
    >
    >需要注意的是，top chunk 的 prev_inuse（prevsize的最后一位）比特位始终为 1，否则其前面的 chunk 就会被合并到 top chunk 中。
    >
    >初始情况下，我们可以将 unsorted chunk 作为 top chunk（因为unsorted bin下标为1）
    >
    > 在 `glibc` 的堆内存管理（`ptmalloc2`）中，**Unsorted Chunk** 和 **Unsorted Bin** 是紧密关联但概念不同的两个实体。以下从结构、行为、利用场景等角度进行对比分析：
    >
    >| **特性**     | **Unsorted Chunk**                         | **Unsorted Bin**                   |
    >| :----------- | :----------------------------------------- | :--------------------------------- |
    >| **本质**     | 单个内存块（chunk）                        | 管理内存块的双向链表结构           |
    >| **作用**     | 临时存放释放或分割后的内存块               | 作为容器，协调内存分配与碎片整理   |
    >| **生命周期** | 短暂存在于 Unsorted Bin 中，等待分类或重用 | 持久存在，作为全局管理结构的一部分 |
    >
    > **说白了，bin里存的就是chunk**

  * last remainder(内存碎片)

    >在用户使用 malloc 请求分配内存时，ptmalloc2 找到的 `chunk` 可能并不和申请的内存大小一致，这时候就将分割之后的剩余部分称之为 last remainder `chunk` ，unsort bin 也会存这一块。top `chunk` 分割剩下的部分不会作为 last remainder.

* ### 宏观结构

  * arena

    >在 `glibc` 的堆内存管理（`ptmalloc2`）中，**Arena** 是一个核心概念，用于管理堆内存的分配与释放。你可以将 Arena 理解为一个**独立的内存管理区域**，每个 Arena 都有自己的堆空间、空闲链表（bins）和其他管理结构
    >
    >* arena数量
    >
    >  >想象一个快递分拣中心（Arena），它负责管理多个快递柜（堆内存）和分拣员（内存分配器）。每个分拣中心都有自己的规则和资源：
    >  >• 主分拣中心（Main Arena）：只有一个，负责管理主线程的堆内存。
    >  >• 分中心（Thread Arena）：每个线程可以有自己的分拣中心，避免多线程竞争。
    >  >
    >  >~~~ c
    >  >For 32 bit systems:
    >  >     Number of arena = 2 * number of cores.
    >  >For 64 bit systems:
    >  >     Number of arena = 8 * number of cores.
    >  >~~~
    >  >
    >  >不是每个线程都有自己的arena，因为每个系统的核数是有限的，当线程数大于核数的二倍（超线程技术）时，就必然有线程处于等待状态，所以没有必要为每个线程分配一个 arena。
    >
    >* main与thread的区别
    >
    >  >与 thread 不同的是，main_arena 并不在申请的 heap 中，而是一个全局变量，在 libc.so 的数据段

  * heap_info

    >程序刚开始执行时，每个线程是没有 heap 区域的。当其申请内存时，就需要一个结构来记录对应的信息，而 heap_info 的作用就是这个。而且当该 heap 的资源被使用完后，就必须得再次申请内存了。此外，一般申请的 heap 是不连续的，因此需要记录不同 heap 之间的链接结构

## 深入理解ptmalloc2

### 深入理解堆的实现

任何堆的实现都需要从以下两个角度考虑相应的问题

* 宏观角度
  * 创建堆
  * 堆初始化
  * 删除堆
* 微观角度
  * 申请内存块
  * 释放内存块

### 基础操作

#### unlink

>unlink 用来将一个双向链表（只存储空闲的 chunk）中的一个元素取出来，可能在以下地方使用
>
>* malloc
>  * 从恰好大小合适的 large bin 中获取 chunk。
>    * 这里需要注意的是 fastbin 与 unsorted bin 就没有使用 unlink，这就是为什么漏洞会经常出现在它们这里的原因。
>    * 依次遍历处理 unsorted bin 时也没有使用 unlink 。
>  * 从比请求的 chunk 所在的 bin 大的 bin 中取 chunk。
>* free **/** malloc_consolidate
>  * 后向合并，合并物理相邻低地址空闲 chunk。
>  * 前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。
>* realloc
>  * 前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。
>
>unlink的宏定义：
>
>~~~ c
>/* Take a chunk off a bin list */
>// unlink p
>#define unlink(AV, P, BK, FD) {                                            \
>    // 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。
>    if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \
>      malloc_printerr ("corrupted size vs. prev_size");               \
>    FD = P->fd;                                                                      \
>    BK = P->bk;                                                                      \
>    // 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。
>    if (__builtin_expect (FD->bk != P || BK->fd != P, 0))                      \
>      malloc_printerr (check_action, "corrupted double-linked list", P, AV);  \
>    else {                                                                      \
>        FD->bk = BK;                                                              \
>        BK->fd = FD;                                                              \
>        // 下面主要考虑 P 对应的 nextsize 双向链表的修改
>        if (!in_smallbin_range (chunksize_nomask (P))                              \
>            // 如果P->fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。
>            // 那么其实也就没有必要对 nextsize 字段进行修改了。
>            // 这里没有去判断 bk_nextsize 字段，可能会出问题。
>            && __builtin_expect (P->fd_nextsize != NULL, 0)) {                      \
>            // 类似于小的 chunk 的检查思路
>            if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)              \
>                || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))    \
>              malloc_printerr (check_action,                                      \
>                               "corrupted double-linked list (not small)",    \
>                               P, AV);                                              \
>            // 这里说明 P 已经在 nextsize 链表中了。
>            // 如果 FD 没有在 nextsize 链表中
>            if (FD->fd_nextsize == NULL) {                                      \
>                // 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P
>                // 令 FD 为 nextsize 串起来的
>                if (P->fd_nextsize == P)                                      \
>                  FD->fd_nextsize = FD->bk_nextsize = FD;                      \
>                else {                                                              \
>                // 否则我们需要将 FD 插入到 nextsize 形成的双链表中
>                    FD->fd_nextsize = P->fd_nextsize;                              \
>                    FD->bk_nextsize = P->bk_nextsize;                              \
>                    P->fd_nextsize->bk_nextsize = FD;                              \
>                    P->bk_nextsize->fd_nextsize = FD;                              \
>                  }                                                              \
>              } else {                                                              \
>                // 如果在的话，直接拿走即可
>                P->fd_nextsize->bk_nextsize = P->bk_nextsize;                      \
>                P->bk_nextsize->fd_nextsize = P->fd_nextsize;                      \
>              }                                                                      \
>          }                                                                      \
>      }                                                                              \
>}
>~~~
>
>在glibc的堆管理中，当空闲chunk位于small bin链表的尾部时，其bk指针指向main_arena中的结构（位于libc的数据段），而fd指针指向前一个堆中的chunk
>
>~~~c
>main_arena.dummy <-> chunkA <-> chunkB <-> main_arena.dummy
>~~~
>
>如以上结构
>
>chunkB是最近被释放的，位于链表尾部。
>
>chunkB的fd指向chunkA（堆地址），bk指向main_arena.dummy（libc地址）
>
>`chunkB`的`bk`指向`main_arena`中的dummy节点，而`main_arena`位于libc的数据段。通过计算偏移，可泄露libc基址。
>
>fd泄露堆地址
>
>chunkB的fd指向同属堆内存的chunkA，直接暴露堆内部地址，用于构造堆布局。
>
>同时，无论是对于 fd，bk 还是 fd_nextsize ，bk_nextsize，程序都会检测 fd 和 bk 是否满足对应的要求
>
>~~~ c
>// fd bk
>if (__builtin_expect (FD->bk != P || BK->fd != P, 0))                      \
>  malloc_printerr (check_action, "corrupted double-linked list", P, AV);  \
>
>  // next_size related
>              if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)              \
>                || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))    \
>              malloc_printerr (check_action,                                      \
>                               "corrupted double-linked list (not small)",    \
>                               P, AV);
>~~~
>
>以上代码检查了P 的 forward chunk 的 bk 以及P 的 backward chunk 的 fd ，也就是说不可以直接更改bk和fd从而到我们想要的地址
>
>**注意：堆的第一个 chunk 所记录的 prev_inuse 位默认为 1。**

### 堆初始化

堆初始化是在用户第一次申请内存时执行 malloc_consolidate 再执行 malloc_init_state 实现的

### 申请内存块

* malloc

  >平时申请malloc函数的时候，我们其实是申请了malloc函数中的_libc_malloc函数，而 _libc_malloc函数其实底层调用了 _int_mallo函数
  >
  >* _int_malloc
  >
  >  >~~~c
  >  >static void *_int_malloc(mstate av, size_t bytes) {
  >  >    INTERNAL_SIZE_T nb;  /* normalized request size */
  >  >    unsigned int    idx; /* associated bin index */
  >  >    mbinptr         bin; /* associated bin */
  >  >
  >  >    mchunkptr       victim;       /* inspected/selected chunk */
  >  >    INTERNAL_SIZE_T size;         /* its size */
  >  >    int             victim_index; /* its bin index */
  >  >
  >  >    mchunkptr     remainder;      /* remainder from a split */
  >  >    unsigned long remainder_size; /* its size */
  >  >
  >  >    unsigned int block; /* bit map traverser */
  >  >    unsigned int bit;   /* bit map traverser */
  >  >    unsigned int map;   /* current word of binmap */
  >  >
  >  >    mchunkptr fwd; /* misc temp for linking */
  >  >    mchunkptr bck; /* misc temp for linking */
  >  >
  >  >    const char *errstr = NULL;
  >  >
  >  >    /*
  >  >       Convert request size to internal form by adding SIZE_SZ bytes
  >  >       overhead plus possibly more to obtain necessary alignment and/or
  >  >       to obtain a size of at least MINSIZE, the smallest allocatable
  >  >       size. Also, checked_request2size traps (returning 0) request sizes
  >  >       that are so large that they wrap around zero when padded and
  >  >       aligned.
  >  >     */
  >  >
  >  >    checked_request2size(bytes, nb);
  >  >~~~
  >  >
  >  >`int_malloc` 是 glibc 中实现 `malloc` 的核心函数，负责管理堆内存的分配。可以把它想象成一个**仓库管理员**，负责从堆内存的“仓库”中找到合适大小的“货物”（内存块），分发给用户。
  >  >
  >  >int_malloc` 的工作流程
  >  >
  >  >以下是 `int_malloc` 的简化流程（以 64 位系统为例）：
  >  >
  >  >##### **(1) 接收订单（用户请求）**
  >  >
  >  >- **输入**：用户需要的内存大小 `size`。
  >  >- **处理**：管理员会将 `size` 转换为实际分配的 chunk 大小（包含头部开销和对齐）。
  >  >
  >  >------
  >  >
  >  >##### **(2) 快速发货（Fastbins）**
  >  >
  >  >- **场景**：如果 `size` 是**小内存**（如 ≤ 0x80 字节）。
  >  >- **操作**：
  >  >  1. 管理员去 **Fastbins 货架**（按固定尺寸分类的快递柜）查找匹配的块。
  >  >  2. 如果找到，直接取出**最近释放的块**（LIFO 原则），返回给用户。
  >  >- **特点**：速度快，但块不合并，可能产生碎片。
  >  >
  >  >------
  >  >
  >  >##### **(3) 普通订单（Smallbins & Unsorted Bin）**
  >  >
  >  >- **场景**：如果 `size` 是**中等内存**（如 0x80 < size ≤ 0x400）。
  >  >- **操作**：
  >  >  1. 管理员先检查 **Unsorted Bin**（临时货架），看看有没有合适的块。
  >  >  2. 如果找到，直接分配或切割后分配；剩余块转移到 **Smallbins**。
  >  >  3. 如果未找到，再去 **Smallbins**（按固定尺寸分类的货架）查找。
  >  >
  >  >------
  >  >
  >  >##### **(4) 大件处理（Largebins）**
  >  >
  >  >- **场景**：如果 `size` 是**大内存**（如 > 0x400 字节）。
  >  >- **操作**：
  >  >  1. 管理员在 **Largebins**（按大小区间分类的货架）中搜索最接近需求的块。
  >  >  2. 如果找到，切割后分配；剩余块放回 Unsorted Bin。
  >  >
  >  >------
  >  >
  >  >##### **(5) 紧急调货（Top Chunk 扩展）**
  >  >
  >  >- **场景**：所有货架都无法满足需求。
  >  >- **操作**：
  >  >  1. 管理员从 **Top Chunk**（仓库顶部的剩余空间）切割一块内存。
  >  >  2. 如果 Top Chunk 不足，调用 `sysmalloc` 向系统申请扩展堆空间（如 `mmap`）。
  >  >
  >  >------
  >  >
  >  >##### **(6) 安全检查**
  >  >
  >  >- **关键检查点**：
  >  >  - 块大小是否合法。
  >  >  - 链表指针是否被篡改（如 `unlink` 时的 `fd->bk == P`）。
  >  >- **防御**：防止攻击者通过溢出或 UAF 篡改堆结构。
  >  >
  >  >接着会寻找一个 arena 来试图分配内存
  >  >
  >  >然后调用 _int_malloc 函数去申请对应的内存
  >  >
  >  >如果分配失败的话，ptmalloc 会尝试再去寻找一个可用的 arena，并分配内存
  >  >
  >  >如果申请到了 arena，那么在退出之前还得解锁
  >
  >* _libc_malloc
  >
  >  >~~~ c
  >  >// wapper for int_malloc
  >  >void *__libc_malloc(size_t bytes) {
  >  >    mstate ar_ptr;
  >  >    void * victim;
  >  >    // 检查是否有内存分配钩子，如果有，调用钩子并返回.
  >  >    void *(*hook)(size_t, const void *) = atomic_forced_read(__malloc_hook);
  >  >    if (__builtin_expect(hook != NULL, 0))
  >  >        return (*hook)(bytes, RETURN_ADDRESS(0));
  >  >~~~
  >  >
  >  >首先解释一下钩子函数
  >  >
  >  >钩子函数是 glibc 提供的一组函数指针，允许用户在内存分配/释放的关键节点插入自定义代码，说白了，是一个可以直接执行shellcode的函数指针
  >  >
  >  >以上代码让**用户申请的字节一旦进入申请内存函数中就变成了无符号整数**。
  >  >
  >  >接着会寻找一个 arena 来试图分配内存
  >  >
  >  >~~~ c
  >  >    arena_get(ar_ptr, bytes);
  >  >~~~
  >  >
  >  >然后调用 _int_malloc 函数去申请对应的内存
  >  >
  >  >~~~ c
  >  >    victim = _int_malloc(ar_ptr, bytes);
  >  >~~~
  >  >
  >  >如果分配失败的话，ptmalloc 会尝试再去寻找一个可用的 arena，并分配内存
  >  >
  >  >~~~ c
  >  >    /* Retry with another arena only if we were able to find a usable arena
  >  >       before.  */
  >  >    if (!victim && ar_ptr != NULL) {
  >  >        LIBC_PROBE(memory_malloc_retry, 1, bytes);
  >  >        ar_ptr = arena_get_retry(ar_ptr, bytes);
  >  >        victim = _int_malloc(ar_ptr, bytes);
  >  >    }
  >  >~~~
  >  >
  >  >说白了就是一遍一遍的试着用_int_malloc函数

* fast bin

  >如果申请的 chunk 的大小位于 fastbin 范围内，**需要注意的是这里比较的是无符号整数**。**此外，是从 fastbin 的头结点开始取 chunk**。
  >
  >~~~c
  >/*
  >   如果请求的大小符合 fastbin 的条件，首先检查对应的 bin。
  >   即使 av（arena）尚未初始化，这段代码也可以安全执行，因此我们可以直接尝试，
  >   而无需额外检查，从而节省时间。
  >*/
  >
  >if ((unsigned long) (nb) <= (unsigned long) (get_max_fast())) {
  >    // 获取对应的 fastbin 下标
  >    idx = fastbin_index(nb);
  >    // 获取对应的 fastbin 头指针
  >    mfastbinptr *fb = &fastbin(av, idx);
  >    mchunkptr pp = *fb;
  >    // 使用 fd 遍历对应的 bin，检查是否有空闲的 chunk
  >    do {
  >        victim = pp;
  >        if (victim == NULL) break;
  >    } while ((pp = catomic_compare_and_exchange_val_acq(fb, victim->fd, victim)) != victim);
  >    // 如果找到可用的 chunk
  >    if (victim != 0) {
  >        // 检查取到的 chunk 大小是否与相应的 fastbin 索引一致。
  >        // 根据取得的 victim，利用 chunksize 计算其大小。
  >        // 利用 fastbin_index 计算 chunk 的索引。
  >        if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0)) {
  >            errstr = "malloc(): memory corruption (fast)";
  >        errout:
  >            malloc_printerr(check_action, errstr, chunk2mem(victim), av);
  >            return NULL;
  >        }
  >        // 细致的检查（仅在 DEBUG 模式下有用）
  >        check_remalloced_chunk(av, victim, nb);
  >        // 将获取的 chunk 转换为用户可用的内存模式
  >        void *p = chunk2mem(victim);
  >        // 如果设置了 perturb_type，则将获取到的 chunk 初始化为 perturb_type ^ 0xff
  >        alloc_perturb(p, bytes);
  >        return p;
  >    }
  >}
  >~~~
  >
  >以上代码的作用是：
  >
  >- 检查请求的内存大小 `nb` 是否属于 Fastbins 的管理范围（即小于等于 `get_max_fast()`）。
  >
  >- 如果是，则从对应的 Fastbin 链表中取出一个空闲 chunk 返回给用户。
  >
  >  关键步骤
  >
  >  > 1.**检查 Fastbin 范围**
  >  > 2.**获取 Fastbin 链表头**
  >  >
  >  > 3.**遍历 Fastbin 链表**
  >  >
  >  > 4.**安全检查**

* small bin

  >如果获取的内存块的范围处于 small bin 的范围，那么执行如下流程
  >
  >~~~c
  >/*
  >   如果请求的大小属于 small bin 的范围，检查对应的 regular bin。
  >   由于这些 "smallbins" 每个 bin 只存放一种大小的 chunk，因此无需在 bin 内搜索。
  >   （对于大请求，我们需要等待 unsorted chunks 处理完毕以找到最佳匹配。但对于小请求，
  >   匹配是精确的，因此我们可以立即检查，这样更快。）
  >*/
  >
  >if (in_smallbin_range(nb)) {
  >    // 获取 small bin 的索引
  >    idx = smallbin_index(nb);
  >    // 获取对应 small bin 中的 chunk 指针
  >    bin = bin_at(av, idx);
  >    // 先执行 victim = last(bin)，获取 small bin 的最后一个 chunk
  >    // 如果 victim = bin，那说明该 bin 为空。
  >    // 如果不相等，那么会有两种情况
  >    if ((victim = last(bin)) != bin) {
  >        // 第一种情况，small bin 还没有初始化。
  >        if (victim == 0) /* initialization check */
  >            // 执行初始化，将 fast bins 中的 chunk 进行合并
  >            malloc_consolidate(av);
  >        // 第二种情况，small bin 中存在空闲的 chunk
  >        else {
  >            // 获取 small bin 中倒数第二个 chunk。
  >            bck = victim->bk;
  >            // 检查 bck->fd 是不是 victim，防止伪造
  >            if (__glibc_unlikely(bck->fd != victim)) {
  >                errstr = "malloc(): smallbin double linked list corrupted";
  >                goto errout;
  >            }
  >            // 设置 victim 对应的 inuse 位
  >            set_inuse_bit_at_offset(victim, nb);
  >            // 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来
  >            bin->bk = bck;
  >            bck->fd = bin;
  >            // 如果不是 main_arena，设置对应的标志
  >            if (av != &main_arena) set_non_main_arena(victim);
  >            // 细致的检查，非调试状态没有作用
  >            check_malloced_chunk(av, victim, nb);
  >            // 将申请到的 chunk 转化为对应的 mem 状态
  >            void *p = chunk2mem(victim);
  >            // 如果设置了 perturb_type，则将获取到的 chunk 初始化为 perturb_type ^ 0xff
  >            alloc_perturb(p, bytes);
  >            return p;
  >        }
  >    }
  >}
  >~~~
  >
  >以上的作用是：
  >
  >* 检查请求的内存大小 nb 是否属于 Smallbins 的管理范围（即 0x20 到 0x3F0 字节）。
  >* 如果是，则从对应的 Smallbin 链表中取出一个空闲 chunk 返回给用户
  >
  >关键步骤
  >
  >>##### 1.**检查 Smallbin 范围**
  >>
  >>2.**获取 Smallbin 链表头**
  >>
  >>3.**检查 Smallbin 是否为空**
  >>
  >>4.**初始化检查**
  >>
  >>5.**取出空闲 chunk**
  >>
  >>6.**更新链表**
  >>
  >>7.**返回内存给用户**

* large bin

  >当fast和small都不能满足的时候就会考虑large bin，但是因为large bin大小只是相似，所以会利用malloc_consolidate（合并fast bin到unsorted bin）然后二次在unsorted bin中查找，如果还是没有，那就直接在large bin中找
  >
  >**不直接从相应的 bin 中取出 large chunk 是因为 ptmalloc 的机制，它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。**
  >
  >~~~ c
  >    /*
  >   如果这是一个大内存请求，继续之前先合并 fastbins。
  >   尽管在尚未检查是否有可用空间之前就合并所有 fastbins 可能看起来有些过度，
  >   但这可以避免通常与 fastbins 相关的碎片化问题。
  >   此外，实际上，程序往往倾向于连续发出小请求或大请求，而较少混合请求，
  >   因此在大多数程序中，合并操作并不会频繁调用。
  >   而那些频繁调用合并操作的程序，往往更容易产生内存碎片。
  >*/
  >    else {
  >        // 获取large bin的下标。
  >        idx = largebin_index(nb);
  >        // 如果存在fastbin的话，会处理 fastbin
  >        if (have_fastchunks(av)) malloc_consolidate(av);
  >    }
  >~~~

* 大循环遍历unsorted bin

  >在接下来的这个循环中，主要做了以下的操作
  >
  >* 按照队列方式逐个将unsorted chunk取出来
  >  * 如果是 small request，则考虑是不是恰好满足，是的话，直接返回。
  >  * 如果不是的话，放到对应的 bin 中。
  >* 尝试从 large bin 中分配用户所需的内存
  >
  >~~~c
  >    /*
  >       Process recently freed or remaindered chunks, taking one only if
  >       it is exact fit, or, if this a small request, the chunk is remainder from
  >       the most recent non-exact fit.  Place other traversed chunks in
  >       bins.  Note that this step is the only place in any routine where
  >       chunks are placed in bins.
  >
  >       The outer loop here is needed because we might not realize until
  >       near the end of malloc that we should have consolidated, so must
  >       do so and retry. This happens at most once, and only when we would
  >       otherwise need to expand memory to service a "small" request.
  >     */
  >
  >    for (;;) {
  >        int iters = 0;
  >~~~
  >
  > 该部分是一个大循环，为了尝试重新分配 small bin chunk，这是因为我们虽然会首先使用 large bin，top chunk 来尝试满足用户的请求，但是如果没有满足的话，由于我们在上面没有分配成功 small bin，我们并没有对 fast bin 中的 chunk 进行合并，所以这里会进行 fast bin chunk 的合并，进而使用一个大循环来尝试再次分配 small bin chunk
  >
  >说白了就是哪里都找不到了，尝试一下再fast bin合并一下看看有没有可能合并一下有没有机会出现需要的堆块
  >
  >unsorted bin 遍历
  >
  >~~~c
  >        // 如果 unsorted bin 不为空
  >        // First In First Out
  >        while ((victim = unsorted_chunks(av)->bk) != unsorted_chunks(av)) {
  >            // victim 为 unsorted bin 的最后一个 chunk
  >            // bck 为 unsorted bin 的倒数第二个 chunk
  >            bck = victim->bk;
  >            // 判断得到的 chunk 是否满足要求，不能过小，也不能过大
  >            // 一般 system_mem 的大小为132K
  >            if (__builtin_expect(chunksize_nomask(victim) <= 2 * SIZE_SZ, 0) ||
  >                __builtin_expect(chunksize_nomask(victim) > av->system_mem, 0))
  >                malloc_printerr(check_action, "malloc(): memory corruption",
  >                                chunk2mem(victim), av);
  >            // 得到victim对应的chunk大小。
  >            size = chunksize(victim);
  >~~~
  >
  >如果用户的请求为 small bin chunk，那么我们首先考虑 last remainder
  >
  >~~~c
  >            /*
  >               If a small request, try to use last remainder if it is the
  >               only chunk in unsorted bin.  This helps promote locality for
  >               runs of consecutive small requests. This is the only
  >               exception to best-fit, and applies only when there is
  >               no exact fit for a small chunk.
  >             */
  >
  >            if (in_smallbin_range(nb) && bck == unsorted_chunks(av) &&
  >                victim == av->last_remainder &&
  >                (unsigned long) (size) > (unsigned long) (nb + MINSIZE)) {
  >                /* split and reattach remainder */
  >                // 获取新的 remainder 的大小
  >                remainder_size          = size - nb;
  >                // 获取新的 remainder 的位置
  >                remainder               = chunk_at_offset(victim, nb);
  >                // 更新 unsorted bin 的情况
  >                unsorted_chunks(av)->bk = unsorted_chunks(av)->fd = remainder;
  >                // 更新 av 中记录的 last_remainder
  >                av->last_remainder                                = remainder;
  >                // 更新last remainder的指针
  >                remainder->bk = remainder->fd = unsorted_chunks(av);
  >                if (!in_smallbin_range(remainder_size)) {
  >                    remainder->fd_nextsize = NULL;
  >                    remainder->bk_nextsize = NULL;
  >                }
  >                // 设置victim的头部，
  >                set_head(victim, nb | PREV_INUSE |
  >                                     (av != &main_arena ? NON_MAIN_ARENA : 0));
  >                // 设置 remainder 的头部
  >                set_head(remainder, remainder_size | PREV_INUSE);
  >                // 设置记录 remainder 大小的 prev_size 字段，因为此时 remainder 处于空闲状态。
  >                set_foot(remainder, remainder_size);
  >                // 细致的检查，非调试状态下没有作用
  >                check_malloced_chunk(av, victim, nb);
  >                // 将 victim 从 chunk 模式转化为mem模式
  >                void *p = chunk2mem(victim);
  >                // 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff
  >                alloc_perturb(p, bytes);
  >                return p;
  >            }
  >~~~
  >
  >如果从 unsorted bin 中取出来的 chunk 大小正好合适，就直接使用
  >
  >~~~c
  >            /* Take now instead of binning if exact fit */
  >            if (size == nb) {
  >                set_inuse_bit_at_offset(victim, size);
  >                if (av != &main_arena) set_non_main_arena(victim);
  >                check_malloced_chunk(av, victim, nb);
  >                void *p = chunk2mem(victim);
  >                alloc_perturb(p, bytes);
  >                return p;
  >            }
  >~~~
  >
  >把取出来的 chunk 放到对应的 small bin 中（分类开始，不让unsorted bin里留东西）
  >
  >~~~c
  >            /* place chunk in bin */
  >
  >            if (in_smallbin_range(size)) {
  >                victim_index = smallbin_index(size);
  >                bck          = bin_at(av, victim_index);
  >                fwd          = bck->fd;
  >~~~
  >
  >把取出来的 chunk 放到对应的 large bin 中（效果同上）
  >
  >~~~c
  >            } else {
  >                // large bin 范围
  >                victim_index = largebin_index(size);
  >                bck          = bin_at(av, victim_index); // 当前 large bin 的头部
  >                fwd          = bck->fd;
  >
  >                /* maintain large bins in sorted order */
  >                /* 从这里我们可以总结出，largebin 以 fd_nextsize 递减排序。
  >                   同样大小的 chunk，后来的只会插入到之前同样大小的 chunk 后，
  >                   而不会修改之前相同大小的fd/bk_nextsize，这也很容易理解，
  >                   可以减低开销。此外，bin 头不参与 nextsize 链接。*/
  >                // 如果 large bin 链表不空
  >                if (fwd != bck) {
  >                    /* Or with inuse bit to speed comparisons */
  >                    // 加速比较，应该不仅仅有这个考虑，因为链表里的 chunk 都会设置该位。
  >                    size |= PREV_INUSE;
  >                    /* if smaller than smallest, bypass loop below */
  >                    // bck->bk 存储着相应 large bin 中最小的chunk。
  >                    // 如果遍历的 chunk 比当前最小的还要小，那就只需要插入到链表尾部。
  >                    // 判断 bck->bk 是不是在 main arena。
  >                    assert(chunk_main_arena(bck->bk));
  >                    if ((unsigned long) (size) <
  >                        (unsigned long) chunksize_nomask(bck->bk)) {
  >                        // 令 fwd 指向 large bin 头
  >                        fwd = bck;
  >                        // 令 bck 指向 largin bin 尾部 chunk
  >                        bck = bck->bk;
  >                        // victim 的 fd_nextsize 指向 largin bin 的第一个 chunk
  >                        victim->fd_nextsize = fwd->fd;
  >                        // victim 的 bk_nextsize 指向原来链表的第一个 chunk 指向的 bk_nextsize
  >                        victim->bk_nextsize = fwd->fd->bk_nextsize;
  >                        // 原来链表的第一个 chunk 的 bk_nextsize 指向 victim
  >                        // 原来指向链表第一个 chunk 的 fd_nextsize 指向 victim
  >                        fwd->fd->bk_nextsize =
  >                            victim->bk_nextsize->fd_nextsize = victim;
  >                    } else {
  >                        // 当前要插入的 victim 的大小大于最小的 chunk
  >                        // 判断 fwd 是否在 main arena
  >                        assert(chunk_main_arena(fwd));
  >                        // 从链表头部开始找到不比 victim 大的 chunk
  >                        while ((unsigned long) size < chunksize_nomask(fwd)) {
  >                            fwd = fwd->fd_nextsize;
  >                            assert(chunk_main_arena(fwd));
  >                        }
  >                        // 如果找到了一个和 victim 一样大的 chunk，
  >                        // 那就直接将 chunk 插入到该chunk的后面，并不修改 nextsize 指针。
  >                        if ((unsigned long) size ==
  >                            (unsigned long) chunksize_nomask(fwd))
  >                            /* Always insert in the second position.  */
  >                            fwd = fwd->fd;
  >                        else {
  >                            // 如果找到的chunk和当前victim大小不一样
  >                            // 那么就需要构造 nextsize 双向链表了
  >                            victim->fd_nextsize              = fwd;
  >                            victim->bk_nextsize              = fwd->bk_nextsize;
  >                            fwd->bk_nextsize                 = victim;
  >                            victim->bk_nextsize->fd_nextsize = victim;
  >                        }
  >                        bck = fwd->bk;
  >                    }
  >                } else
  >                    // 如果空的话，直接简单使得 fd_nextsize 与 bk_nextsize 构成一个双向链表即可。
  >                    victim->fd_nextsize = victim->bk_nextsize = victim;
  >            }
  >~~~
  >
  >while 最多迭代 10000 次后退出
  >
  >~~~c
  >            // #define MAX_ITERS 10000
  >            if (++iters >= MAX_ITERS) break;
  >        }
  >~~~

* #### large chunk

  >如果请求的 chunk 在 large chunk 范围内，就在对应的 bin 中从小到大进行扫描，找到第一个合适的。
  >
  >~~~c
  >        /*
  >           If a large request, scan through the chunks of current bin in
  >           sorted order to find smallest that fits.  Use the skip list for this.
  >         */
  >        if (!in_smallbin_range(nb)) {
  >            bin = bin_at(av, idx);
  >            /* skip scan if empty or largest chunk is too small */
  >            // 如果对应的 bin 为空或者其中的chunk最大的也很小，那就跳过
  >            // first(bin)=bin->fd 表示当前链表中最大的chunk
  >            if ((victim = first(bin)) != bin &&
  >                (unsigned long) chunksize_nomask(victim) >=
  >                    (unsigned long) (nb)) {
  >                // 反向遍历链表，直到找到第一个不小于所需chunk大小的chunk
  >                victim = victim->bk_nextsize;
  >                while (((unsigned long) (size = chunksize(victim)) <
  >                        (unsigned long) (nb)))
  >                    victim = victim->bk_nextsize;
  >
  >                /* Avoid removing the first entry for a size so that the skip
  >                   list does not have to be rerouted.  */
  >                // 如果最终取到的chunk不是该bin中的最后一个chunk，并且该chunk与其前面的chunk
  >                // 的大小相同，那么我们就取其前面的chunk，这样可以避免调整bk_nextsize,fd_nextsize
  >                //  链表。因为大小相同的chunk只有一个会被串在nextsize链上。
  >                if (victim != last(bin) &&
  >                    chunksize_nomask(victim) == chunksize_nomask(victim->fd))
  >                    victim = victim->fd;
  >                // 计算分配后剩余的大小
  >                remainder_size = size - nb;
  >                // 进行unlink
  >                unlink(av, victim, bck, fwd);
  >
  >                /* Exhaust */
  >                // 剩下的大小不足以当做一个块
  >                // 很好奇接下来会怎么办？
  >                if (remainder_size < MINSIZE) {
  >                    set_inuse_bit_at_offset(victim, size);
  >                    if (av != &main_arena) set_non_main_arena(victim);
  >                }
  >                /* Split */
  >                //  剩下的大小还可以作为一个chunk，进行分割。
  >                else {
  >                    // 获取剩下那部分chunk的指针，称为remainder
  >                    remainder = chunk_at_offset(victim, nb);
  >                    /* We cannot assume the unsorted list is empty and therefore
  >                       have to perform a complete insert here.  */
  >                    // 插入unsorted bin中
  >                    bck = unsorted_chunks(av);
  >                    fwd = bck->fd;
  >                    // 判断 unsorted bin 是否被破坏。
  >                    if (__glibc_unlikely(fwd->bk != bck)) {
  >                        errstr = "malloc(): corrupted unsorted chunks";
  >                        goto errout;
  >                    }
  >                    remainder->bk = bck;
  >                    remainder->fd = fwd;
  >                    bck->fd       = remainder;
  >                    fwd->bk       = remainder;
  >                    // 如果不处于small bin范围内，就设置对应的字段
  >                    if (!in_smallbin_range(remainder_size)) {
  >                        remainder->fd_nextsize = NULL;
  >                        remainder->bk_nextsize = NULL;
  >                    }
  >                    // 设置分配的chunk的标记
  >                    set_head(victim,
  >                             nb | PREV_INUSE |
  >                                 (av != &main_arena ? NON_MAIN_ARENA : 0));
  >
  >                    // 设置remainder的上一个chunk，即分配出去的chunk的使用状态
  >                    // 其余的不用管，直接从上面继承下来了
  >                    set_head(remainder, remainder_size | PREV_INUSE);
  >                    // 设置remainder的大小
  >                    set_foot(remainder, remainder_size);
  >                }
  >                // 检查
  >                check_malloced_chunk(av, victim, nb);
  >                // 转换为mem状态
  >                void *p = chunk2mem(victim);
  >                // 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff
  >                alloc_perturb(p, bytes);
  >                return p;
  >            }
  >        }
  >~~~

* #### 寻找较大 chunk

  >如果走到了这里，那说明对于用户所需的 chunk，不能直接从其对应的合适的 bin 中获取 chunk，所以我们需要来查找比当前 bin 更大的 fast bin ， small bin 或者 large bin
  >
  >~~~c
  >        /*
  >           Search for a chunk by scanning bins, starting with next largest
  >           bin. This search is strictly by best-fit; i.e., the smallest
  >           (with ties going to approximately the least recently used) chunk
  >           that fits is selected.
  >
  >           The bitmap avoids needing to check that most blocks are nonempty.
  >           The particular case of skipping all bins during warm-up phases
  >           when no chunks have been returned yet is faster than it might look.
  >         */
  >
  >        ++idx;
  >        // 获取对应的bin
  >        bin   = bin_at(av, idx);
  >        // 获取当前索引在binmap中的block索引
  >        // #define idx2block(i) ((i) >> BINMAPSHIFT)  ,BINMAPSHIFT=5
  >        // Binmap按block管理，每个block为一个int，共32个bit，可以表示32个bin中是否有空闲chunk存在
  >        // 所以这里是右移5
  >        block = idx2block(idx);
  >        // 获取当前块大小对应的映射，这里可以得知相应的bin中是否有空闲块
  >        map   = av->binmap[ block ];
  >        // #define idx2bit(i) ((1U << ((i) & ((1U << BINMAPSHIFT) - 1))))
  >        // 将idx对应的比特位设置为1，其它位为0
  >        bit   = idx2bit(idx);
  >        for (;;) {            /* Skip rest of block if there are no more set bits in this block.
  >             */
  >            // 如果bit>map，则表示该 map 中没有比当前所需要chunk大的空闲块
  >            // 如果bit为0，那么说明，上面idx2bit带入的参数为0。
  >            if (bit > map || bit == 0) {
  >                do {
  >                    // 寻找下一个block，直到其对应的map不为0。
  >                    // 如果已经不存在的话，那就只能使用top chunk了
  >                    if (++block >= BINMAPSIZE) /* out of bins */
  >                        goto use_top;
  >                } while ((map = av->binmap[ block ]) == 0);
  >                // 获取其对应的bin，因为该map中的chunk大小都比所需的chunk大，而且
  >                // map本身不为0，所以必然存在满足需求的chunk。
  >                bin = bin_at(av, (block << BINMAPSHIFT));
  >                bit = 1;
  >            }
  >~~~

* 使用top chunk

  >如果所有的 bin 中的 chunk 都没有办法直接满足要求（即不合并），或者说都没有空闲的 chunk。那么我们就只能使用 top chunk 了
  >
  >~~~c
  >    use_top:
  >        /*
  >           If large enough, split off the chunk bordering the end of memory
  >           (held in av->top). Note that this is in accord with the best-fit
  >           search rule.  In effect, av->top is treated as larger (and thus
  >           less well fitting) than any other available chunk since it can
  >           be extended to be as large as necessary (up to system
  >           limitations).
  >
  >           We require that av->top always exists (i.e., has size >=
  >           MINSIZE) after initialization, so if it would otherwise be
  >           exhausted by current request, it is replenished. (The main
  >           reason for ensuring it exists is that we may need MINSIZE space
  >           to put in fenceposts in sysmalloc.)
  >         */
  >        // 获取当前的top chunk，并计算其对应的大小
  >        victim = av->top;
  >        size   = chunksize(victim);
  >        // 如果分割之后，top chunk 大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。
  >        if ((unsigned long) (size) >= (unsigned long) (nb + MINSIZE)) {
  >            remainder_size = size - nb;
  >            remainder      = chunk_at_offset(victim, nb);
  >            av->top        = remainder;
  >            // 这里设置 PREV_INUSE 是因为 top chunk 前面的 chunk 如果不是 fastbin，就必然会和
  >            // top chunk 合并，所以这里设置了 PREV_INUSE。
  >            set_head(victim, nb | PREV_INUSE |
  >                                 (av != &main_arena ? NON_MAIN_ARENA : 0));
  >            set_head(remainder, remainder_size | PREV_INUSE);
  >
  >            check_malloced_chunk(av, victim, nb);
  >            void *p = chunk2mem(victim);
  >            alloc_perturb(p, bytes);
  >            return p;
  >        }
  >        // 否则，判断是否有 fast chunk
  >        /* When we are using atomic ops to free fast chunks we can get
  >           here for all block sizes.  */
  >        else if (have_fastchunks(av)) {
  >            // 先执行一次fast bin的合并
  >            malloc_consolidate(av);
  >            /* restore original bin index */
  >            // 判断需要的chunk是在small bin范围内还是large bin范围内
  >            // 并计算对应的索引
  >            // 等待下次再看看是否可以
  >            if (in_smallbin_range(nb))
  >                idx = smallbin_index(nb);
  >            else
  >                idx = largebin_index(nb);
  >        }
  >~~~
  >
  
* 堆内存不够

  >如果堆内存不够，我们就需要使用 `sysmalloc` 来申请内存了
  >
  >glibc源代码 略

* _libc_calloc

  >calloc 也是 libc 中的一种申请内存块的函数
  >
  >~~~c
  >/*
  >  calloc(size_t n_elements, size_t element_size);
  >  Returns a pointer to n_elements * element_size bytes, with all locations
  >  set to zero.
  >*/
  >void*  __libc_calloc(size_t, size_t);
  >~~~
  >
  >

* sysmalloc

  >该函数用于当前堆内存不足时，需要向系统申请更多的内存
  >
  >* 基本定义
  >
  >  ~~~c
  >  void* __libc_calloc(size_t n, size_t size) {
  >      // ▌阶段1：量子级安全检查
  >      const size_t bytes = n * size;
  >      if (size && (n > SIZE_MAX / size)) { // 防宇宙大爆炸式溢出
  >          errno = ENOMEM;                  // 设置错误暗号
  >          return NULL;                      // 举红旗投降
  >      }
  >  
  >      // ▌阶段2：调用内存炼金术士
  >      void* mem = __libc_malloc(bytes);     // 底层黑魔法（可能使用sbrk或mmap）
  >  
  >      // ▌阶段3：数据焚化炉启动
  >      if (mem != NULL) {
  >          // 现代OS的隐藏技能：COW（写时复制）零页技术
  >          memset(mem, 0, bytes);           // 暴力清零（但内核可能偷懒优化）
  >      }
  >  
  >      // ▌阶段4：返回时空坐标
  >      return mem; // 可能是纯净天堂，也可能是虚空深渊（NULL）
  >  }
  >  ~~~
  >
  >  想象你要在图书馆借100本完全空白的新笔记本，管理员`calloc`会：
  >  1️⃣ **计算需求**：确认100本 × 每本200页的合理性（防溢出）
  >  2️⃣ **找空房间**：在馆内开辟专用空间（分配内存）
  >  3️⃣ **撕掉旧笔记**：用碎纸机销毁所有残留文字（清零）
  >  4️⃣ **交付钥匙**：给你一个绝对干净的仓库地址（返回指针）
  >
  >  而`malloc`更像是直接给你一个可能堆满灰尘的旧仓库。
  >
  >  1. **零≠安全**
  >     - 浮点数0.0的二进制形态 ≠ 全零比特（依赖IEEE754实现）
  >     - 空指针的零地址访问会触发**段错误核爆**
  >  2. **幽灵内存现象**
  >     调用`calloc(0,100)`可能返回：
  >     - 魔法指针：一个可被`free()`的安全幽灵地址
  >     - NULL：某些系统的严格模式
  >
  >  #### **calloc vs malloc**
  >
  >  | 场景               | calloc战绩                | malloc对策                 |
  >  | :----------------- | :------------------------ | :------------------------- |
  >  | **分配1GB内存**    | 0.2ms (利用内核预清零页)  | 1.5ms (需手动memset)       |
  >  | **重复分配小内存** | 慢于malloc (频繁清零开销) | 直接重用脏内存             |
  >  | **安全敏感场景**   | 杜绝未初始化数据泄漏      | 需手动清零否则可能泄露密钥 |
  >
  >* 考虑mmap
  >
  >  >正如开头注释所言如果满足如下任何一种条件
  >  >
  >  >1. 没有分配堆。
  >  >2. 申请的内存大于 `mp_.mmap_threshold`，并且 mmap 的数量小于最大值，就可以尝试使用 mmap。

## 释放内存块

* _libc_free

  >free函数也有一层封装（_libc_free)
  >
  >~~~c
  >void __libc_free(void *mem) {
  >    mstate    ar_ptr;
  >    mchunkptr p; /* chunk corresponding to mem */
  >    // 判断是否有钩子函数 __free_hook
  >    void (*hook)(void *, const void *) = atomic_forced_read(__free_hook);
  >    if (__builtin_expect(hook != NULL, 0)) {
  >        (*hook)(mem, RETURN_ADDRESS(0));
  >        return;
  >    }
  >    // free NULL没有作用
  >    if (mem == 0) /* free(0) has no effect */
  >        return;
  >    // 将mem转换为chunk状态
  >    p = mem2chunk(mem);
  >    // 如果该块内存是mmap得到的
  >    if (chunk_is_mmapped(p)) /* release mmapped memory. */
  >    {
  >        /* See if the dynamic brk/mmap threshold needs adjusting.
  >       Dumped fake mmapped chunks do not affect the threshold.  */
  >        if (!mp_.no_dyn_threshold && chunksize_nomask(p) > mp_.mmap_threshold &&
  >            chunksize_nomask(p) <= DEFAULT_MMAP_THRESHOLD_MAX &&
  >            !DUMPED_MAIN_ARENA_CHUNK(p)) {
  >            mp_.mmap_threshold = chunksize(p);
  >            mp_.trim_threshold = 2 * mp_.mmap_threshold;
  >            LIBC_PROBE(memory_mallopt_free_dyn_thresholds, 2,
  >                       mp_.mmap_threshold, mp_.trim_threshold);
  >        }
  >        munmap_chunk(p);
  >        return;
  >    }
  >    // 根据chunk获得分配区的指针
  >    ar_ptr = arena_for_chunk(p);
  >    // 执行释放
  >    _int_free(ar_ptr, p, 0);
  >}
  >~~~
  >
  >当调用`free(p)`时：
  >**物理层面**：将内存标记为可重用，但数据仍存在直到被覆盖
  >
  >**逻辑层面**：修改堆管理器的元数据链表
  >
  >**安全层面**：在虚拟地址空间制造了一个可能被他人占据的"空房间"
  >
  >* _int_free
  >
  >  >函数初始时刻定义了一系列的变量，并且得到了用户想要释放的 chunk 的大小
  >
  >* 简单的检查
  >
  >  >~~~c
  >  >    /* Little security check which won't hurt performance: the
  >  >       allocator never wrapps around at the end of the address space.
  >  >       Therefore we can exclude some size values which might appear
  >  >       here by accident or by "design" from some intruder.  */
  >  >    // 指针不能指向非法的地址, 必须小于等于-size，为什么？？？
  >  >    // 指针必须得对齐，2*SIZE_SZ 这个对齐得仔细想想
  >  >    if (__builtin_expect((uintptr_t) p > (uintptr_t) -size, 0) ||
  >  >        __builtin_expect(misaligned_chunk(p), 0)) {
  >  >        errstr = "free(): invalid pointer";
  >  >    errout:
  >  >        if (!have_lock && locked) __libc_lock_unlock(av->mutex);
  >  >        malloc_printerr(check_action, errstr, chunk2mem(p), av);
  >  >        return;
  >  >    }
  >  >    /* We know that each chunk is at least MINSIZE bytes in size or a
  >  >       multiple of MALLOC_ALIGNMENT.  */
  >  >    // 大小没有最小的chunk大，或者说，大小不是MALLOC_ALIGNMENT的整数倍
  >  >    if (__glibc_unlikely(size < MINSIZE || !aligned_OK(size))) {
  >  >        errstr = "free(): invalid size";
  >  >        goto errout;
  >  >    }
  >  >    // 检查该chunk是否处于使用状态，非调试状态下没有作用
  >  >    check_inuse_chunk(av, p);
  >  >~~~
  >
  >* fast bin
  >
  >  >如果上述检查都合格的话，判断当前的 bin 是不是在 fast bin 范围内，在的话就插入到 **fastbin 头部**，即成为对应 fastbin 链表的**第一个 free chunk**
  >
  >* 合并非mmap的空闲chunk
  >
  >  >**只有不是 fast bin 的情况下才会触发 unlink**
  >  >
  >  >首先我们先说一下为什么会合并 chunk，这是为了避免 heap 中有太多零零碎碎的内存块，合并之后可以用来应对更大的内存块请求。合并的主要顺序为
  >  >
  >  >- 先考虑物理低地址空闲块
  >  >- 后考虑物理高地址空闲块
  >  >
  >  >**合并后的 chunk 指向合并的 chunk 的低地址。**
  >  >
  >  >紧接着是一个风险检测，包括：
  >  >
  >  >>* 当前free的chunk不能是top chunk
  >  >>* 当前free的chunk的下一个chunk不能超过arena的边界
  >  >>* 当前要free的chunk的使用标记没有被标记
  >  >>* 判断下一个chunk的大小是否不大于2*SIZE_SZ，或者nextsize是否大于系统可提供的内存
  >  >
  >  >释放填充
  >  >
  >  >合并低地址，但如果他不是top chunk前最后一块chunk，那就向高地址合并然后放入unsorted bin中
  >  >
  >  >如果下一块是top chunk，那就被合并到top chunk中
  >  >
  >  >最后向系统返还内存

## tcache

>tcache提升堆管理的性能，但提升性能的同时舍弃了很多安全检查，也因此有了很多新的利用方式

* 相关结构体

  * tcache_entry

    ~~~c
    /* 当内存块（chunk）存储在每线程缓存（tcache）中时，
       我们将这个结构体覆盖在内存块的用户数据区域上 */
    typedef struct tcache_entry
    {
      struct tcache_entry *next; // 指向链表中下一个tcache条目
    } tcache_entry;
    ~~~

    `tcache_entry` 用于链接空闲的 chunk 结构体，其中的 `next` 指针指向下一个大小相同的 chunk。

    需要注意的是这里的 next 指向 chunk 的 user data，而 fastbin 的 fd 指向 chunk 开头的地址。

    而且，tcache_entry 会复用空闲 chunk 的 user data 部分。

  * tcache_prethread_struck

    ~~~c
    /* 每个线程拥有一个此结构体，用于管理线程本地缓存（因此得名"tcache_perthread_struct"）。
       保持结构体体积较小有一定重要性。注意COUNTS和ENTRIES是冗余的
       （本可以通过遍历链表计数），此设计出于性能考虑。*/
    typedef struct tcache_perthread_struct
    {
      char counts[TCACHE_MAX_BINS];       // 每个bin的缓存数量计数器
      tcache_entry *entries[TCACHE_MAX_BINS]; // 每个bin的空闲块链表头指针
    } tcache_perthread_struct;
    
    #define TCACHE_MAX_BINS 64 // 最大bin数量（对应64个不同大小的内存块）
    
    static __thread tcache_perthread_struct *tcache = NULL; // 线程本地存储指针
    ~~~

    每个 thread 都会维护一个 `tcache_perthread_struct`，它是整个 tcache 的管理结构，一共有 `TCACHE_MAX_BINS` 个计数器和 `TCACHE_MAX_BINS`项 tcache_entry，其中

    - `tcache_entry` 用单向链表的方式链接了相同大小的处于空闲状态（free 后）的 chunk，这一点上和 fastbin 很像。
    - `counts` 记录了 `tcache_entry` 链上空闲 chunk 的数目，每条链上最多可以有 7 个 chunk。

* ## 基本工作方式 [¶](https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/implementation/tcache/#_2)

  - 第一次 malloc 时，会先 malloc 一块内存用来存放 `tcache_perthread_struct` 。
  - free 内存，且 size 小于 small bin size 时
  - tcache 之前会放到 fastbin 或者 unsorted bin 中
  - tcache 后：
    - 先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）
    - tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中
    - tcache 中的 chunk 不会合并（不取消 inuse bit）
  - malloc 内存，且 size 在 tcache 范围内
  - 先从 tcache 取 chunk，直到 tcache 为空
  - tcache 为空后，从 bin 中找
  - tcache 为空时，如果 `fastbin/smallbin/unsorted bin` 中有 size 符合的 chunk，会先把 `fastbin/smallbin/unsorted bin` 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来

## malloc_state基本函数

1.初始化函数malloc_init_state

2.合并函数malloc_consolidate（如果fastbin没初始化则初始化）