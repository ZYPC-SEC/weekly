# <font style="color:rgb(38, 38, 38);">完成事项</font>
### 函数运行周期加深理解
### 指针学习
### 第十二章部分内容
# <font style="color:rgb(38, 38, 38);">下周待做事项</font>
 
### 完成c语言学习

# <font style="color:rgb(38, 38, 38);">本周学习的知识分享</font>
#### 函数运行周期加深理解
<strong>
1.压参
  在64位程序中，有六个寄存器 分别是 rdi, rsi, rdx, rcx, r8, r9
  按照顺序（倒叙的反义词）这六个参数fun（a,b,c,d,e,f）分别和上面六个寄存器对应（即从左到右依次放置）
  寄存器	                               调用者负责	
  rax, rcx, rdx, rsi, rdi, r8-r11	caller-saved	(callee可以乱改)
  如果多出来的参数，则压栈，注意，不是放在下文的局部变量内（即callee的栈帧），而是放在caller的栈帧，在call fun之前就压栈，这个顺序是按照参数从右到左
  而在某些情况下，为了方便调用，会把一些寄存器里的值复制到栈中（caller的栈帧），跟在之前多出来的变量的下面
2.call fun对函数进行调用
   在汇编中 能看到这些东西
    mov rdi x
    mov rsi x  
    call fun 此时RIP指向这个代码
    ...........   <- 这是下一个代码，也就是接下来要讲的保存地址，即是这个代码的地址（RIP指向的地址+call 这个指令的长度）
   
3.压ret
   之前说了RIP指向call 的地址（text段），而CPU又知道call的字节大小，因此能够计算（RIP指向的地址+call 这个指令的长度）出下一个代码的地址（返回地址）同时CPU的目标是将这个值放在栈中储存起来。
   那么如何储存？首先RSP-8，栈中腾出空间，之后CPU把这个值放在栈中存储起来
4.跳转函数
   此时 call fun 此时RIP指向这个代码
   那么CPU就能跳转到相应的位置，准备开始执行这个函数
5.压rbp
  一个代码push rbp蕴藏着很多东西，这也是初学者容易会忽略的（我忽略了，肯定有佬不会忽略 ）   rbp是一个寄存器，用来存储当前栈帧开始的位置，当然，push rbp并不意味就简简单单是把rbp放进去，可能push这个名字确实会误导人，但是其实本质是一个数据交换的过程
  首先，想要放进去东西，自然需要在栈中开辟一个新空间，而开辟的空间是混沌的，里面还保留着之前程序运行遗留的值。所进行的放入值，其实是将要保存的值把这些垃圾无效的值覆盖掉
  （跑偏了，思路回到rbp中来）。接着，空间腾好了，将rbp里面的值（也就是上一个函数，也就是调用现在即将运行的函数的函数，比如调用你的是main函数，这个函数开始的在栈帧中位置）存进栈中。
6.创建栈帧
   由于刚才腾了空间，现在rsp指向的就是腾放进去rbp的值的栈的最低地址，此时，mov rbp rsp,即把这个当前这个rsp指向的位置保存在了rbp寄存器当中，虽然将上一个函数的栈帧的位置覆盖掉了，但刚刚压rbp的时候已经把当时rbp保存的值保存在了栈里，所以原来的数据不会丢失，这也是为什么push rbp叫做保存调用函数（caller函数）的bp。
7.创建变量
   首先，系统会一次性计算完所有的局部变量大小，让sub rsp x;腾出空间，当然有时会涉及到栈对齐的问题，这其实是系统底层逻辑，为了优化进行的操作，比如实际有50个字节但实际上比如系统规定16字节进行对齐，那么，会分配64个字节的大小。而且，这些变量在分配的这个栈空间是有严格的顺序的，按照源码的顺序，从高地址向低地址进行填充。而找到这些变量的位置也是进行具体的rbp-offset来确定的。一旦局部变量分配完成，此后rsp不会再进行移动。当然有人问，主播主播，拿一些表达式该怎么判断呢，那么答案便是1.通过寄存器进行加减计算，如果是循环，那么记住，一切的本质是进行比较（cmp）之后姜萍。所以本质就是c中的if判断。
   当然如果有全局变量，那自然不是在栈中，如果未初始化，在bss段，如果初始化，在data段。
8.开始清理
  前言：一个函数的返回值该怎么处理呢，会把这个值放在rax寄存器中（如果是整型和指针），如果是浮点就是放在XMM0寄存器中，之后通过寄存器来传递
  首先，mov rsp rbp这个很好理解，就是让rsp的值变成了栈帧刚开始创建时那个位置的值，即rsp 上移，那此时有人问了，主播主播，上移了那数据也没清理啊，我只想说当然没清理，下次用到这些空间的时候，新的值会把这些覆盖掉。
  接下来pop rbp，这个跟之前push大差不差了，是把保存在栈中的地址放在rbp中，然后rsp +8。rbp本质就是一个参考点，知道当前函数的基址在哪里，进行定位的作用
  接下来ret 把之前放在栈中的地址放在RIP中，之后j姜萍到那,之后rsp + 8,当然如果还有参数那就不是ret 了而是ret n了，顺带把参数就清理了，好了，此时callee真正结束，恢复到caller
</strong>


#### 指针
<strong>

一.int b = 3
   int * c = b
   c中是一串数字，被编译器当作地址值。
   原因 ：*的含义
1. 告诉编译器这个变量是指针，用来存储地址
   int * c:翻译，c是指针，指向int值，同时也意味着读取这个地址的时候，一次读取int大小的内存（4字节）。
2.解引
   *c 告诉编译器从c中存储的地址，到这个地址取内容
   当然，我们可以创建一个指针，这个指针指向另一个指针，这个指针指向一个值
例： 
   int a =5;
   int * b = &a;
   int **c = &b
   翻译一下：a中存储一个变量 5，我们创建了一个指针b,b指向a的地址，告诉编译器，指向int值，又创建了一个指针变量c，这个c指向一个指针即。 *  *c,那么编译器知道这是地址，就一次读取8字节，之后指向int，告诉编译器读取4字节，这个里面存放的是整型变量
   当然，如果int * c = &b,这样就不行，虽然是一个地址，但是这种语法无疑会告诉编译器：c是一个指针，指向一个int值，那么不仅没有读取完全部的指针内容（指针是8字节），而且会让编译器认为，我读取的是一个整型值，而非地址，所以当你要这么解引**c，就是错的
二.指针具有算术单位
    p+1不是地址加1，而是p加上p指向的类型的一个大小，这个对void *无效

三：数组退化：只有在编译器编译时能知道数组的大小情况下，才不会发生退化，只有在在，表达式求值时，才会发生退化。
   int a[10];
   int * p = a(等价于&a[0])
   当然不能给a再去赋一个值了，因为a不是变量，是数组名
   再sizeof(a)时，这里不退化，表示的是整个数组的大小
   而sizeof(p)表示的是指针的大小，是8字节
   而传参时fun(int *a[])和fun(a)是相同的。

多维数组问题:
   例 int zippo[4][2] = { {1,2},{5,6},{9,10},{11,12 } };
   例一维数组 zippo[4] 那么zippo存储的是zippo数组首元素的地址所以在一维数组中zippo就是&zippo[0]
   那么同理，在二维数组中 zippo就是&zippo[0],而zippo[0]就相当于&zippo[0][0]
   所以*zippo取出来的是&zippo[0][0]的地址，所以**zippo就相当于取出的是zippo[0][0]的值
   而可以这么做的本质就是数组会退化为首元素地址
   那么，用指针来如何表述一个二维数组
   那么这么表示 int （*p)[2] 人话翻译一个指针p指向一个拥有两个int类型的数组
   但是如果这么写 int*(p)[2]或int*(p)[2]，表明有一个数组p[2]里面的元素全部为指针，皆指向int类型
   本质就是数组退化了一级
   而在多维数组声明只能省略第一个方括号里的值，而这个也可以用指针指代
      
四.指针兼容性问题：
   可以给指针加const，但不能丢弃const 如 const int * b;int *a=b
   任何一个指针可以跟void表示，void不解释类型，只当作原始的数据流
   虽然我们可以给第一级指针加上const，但二级指针不行，这样子我们可以通过修改第一级指针来改变原本指向的const int值，所以编译器禁止
五.函数指针
   指向函数的指针，保存的是函数入口的地址
六.野指针
   指向一个无效地址的指针
七.复合字面量
   int * pt1 = (int[]){1,2,3,4,5}
   int (* pt2 )[3] = (int[2][3]){{1,2,3}{1,2,3}}
   同样的，指针指向的是首元素地址
</strong>


# <font style="color:rgb(38, 38, 38);">本周学习总结</font>
完成指针学习，但对于编程实践没有进行练手，加深函数生命周期理解

# <font style="color:rgb(38, 38, 38);">杂项</font>
练手了几道简单pwn题，还是StackOverflow ret2text ret2shellcode 
