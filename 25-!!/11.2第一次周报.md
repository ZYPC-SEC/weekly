# <font style="color:rgb(38, 38, 38);">完成事项</font>
**本周主要完成C语言继续的学习，第八章字符输入/输出和输入验证，和第九章函数部分内容**
 # <font style="color:rgb(38, 38, 38);">下周待做事项</font>
**继续学习C语言，以pwnner的视角继续学习函数部分内容，之后在进行指针的学习，多多练习**
**编程，争取早日对指针的使用手到擒来，如果还有什么变化继续听donk爹的安排**
# <font style="color:rgb(38, 38, 38);">本周学习的知识分享</font>
### 第八章
本章开篇讲述了输入的两种不同形式，但其实主要讲述了行缓冲输入的相关知识点
从pwn的视角去看，当无法很好的管理你的缓冲区的时候是一件比较恐怖的事情，尤其是当存在这种getchar
一次只能处理一个字符的函数，管理不当就会造成一些数据滞留在了缓冲区，拿一个程序举例。
``` c
void display(char ch, int lines, int width)
{
	int row, col;
	for (row = 1; row <= lines; row++)
	{
		for (col = 1; col <= width; col++)
		{
			putchar(ch);
		}
		putchar('\n');
	}
}
int main(void)
{
	int ch;
	int rows, cols;
	printf("Enter a character and two integers:\n");
	while ((ch = getchar()) != '\n')
	{
		scanf("%d %d", &rows, &cols);
		display(ch, rows, cols);
		printf("Enter another character and two integers, or a newline to quit:\n");
	}
	printf("Bye!\n");
	return 0;
}
```
在这个程序中，由于没有做好缓冲区的管理，导致一旦有错误的输入，就无法得到我们自己想要的结果。
如果输入p 2 3 l就会产生非预期输出，正常的p的二行三列外加空格的二行三列，再输入接下来的字符如k，又会导致scanf函数读取失败，生成
二行三列的l。 
如果正常输入，也会导致最后的换行符让我们退出程序。
这些无不告诉我们好的管理的缓冲区，无不重要
总之，在本章内容中，作者主要讲述了如何处理非预期的输入导致程序混乱的问题，尤其是在数值和字符混合的情况下，核心的解决方法便是清除缓冲区
此外还涉及数据流和重定向等问题，主要表现在对数据流的相关转换和数据的截取
### 第九章
本章主要从pwnner的视角体会了程序的运行过程，但以这个视角，还是有些晕头晕脑
先说一下一个程序中都分为哪些部分
1.stack
2.heap
3.data
4.代码段
5.字符段
等.......
再说一下栈中主要都存放什么
1.返回地址
2.局部变量
3.函数参数
等......
而本章对于栈帧的相关理解皆基于在32位程序的理解
理解程序相关内容皆基于c primer plus书中示例程序
首先，在程序的运行入口通常并非是main函数，而是由一个运行库提供的入口函数，之后调用例如libc_start_main等函数，对于最后结尾的return 0;
也是将0返回这个函数，告知程序结束运行正常。
在调用任何一个函数之前（32位），首先会对这个函数创建一个栈帧，在这个栈帧中，会先压入这个函数相关参数（浅浅了解了一下64位相关传参过程，是通过寄存器按照顺序传参，当超过六个参数时
，才会进入栈中），之后压入返回地址，最后压入ebp，再为相关局部变量分配空间。当结束一个函数的调用的时候，会先将ebp弹出，之后pop ret 地址，回到原先调用函数的下一个指令，然后移动esp,清除相关参数，栈帧恢复正常。
而在跳转到一些地址是，一般是跳转到程序中代码段，字符段等地址，之前老是理解成栈中，晕了半天
现在具体复现一个递归程序
``` c
void up_and_down(int n)
{
	printf("Level %d;n location %p\n", n, &n);
	if(n<4)
		up_and_down(n + 1);
    printf("Level %d; n location %p\n", n, &n);
}
int main(void)
{
	up_and_down(1);
	return 0;
}
```
在这个程序中递归函数相关栈帧变化
压入n=1，作为参数，压入返回地址，指向return 0，压入ebp，之后调用printf函数，同样压入相关参数，返回地址，ebp，局部变量，处理后弹出，清理栈帧，跳转函数。
之后继续调用up_and_down，此时程序传参n=2，压入返回地址，此时指向的是up_and_down后面的printf函数，n=1，之后重复相关过程直到n=4时，此时返回地址指向的是up_and_down后面的printf函数
n=3,最后不断弹出返回清理栈帧，弹出返回清理栈帧，最后造成打印顺序为12344321。
而在压入相关参数是，一般遵循从右向左入栈，而处理顺序视函数而定。
# <font style="color:rgb(38, 38, 38);">本周学习总结</font>
**本周主要对第八章，和第九章部分内容进行深入学习，对缓冲输入有了更深刻的了解，也对程序中栈帧变化加深了理解（其实也不是很深）**
# <font style="color:rgb(38, 38, 38);">杂项</font>
中间换了换脑子，在nssctf中完成了一些简单的ret2shellcode 和ret2text