# <font style="color:rgb(38, 38, 38);">完成事项</font>
1. 学习梳理，已经同步至博客
2. 数据结构的继续学习
3. 书籍的阅读
4. 刷了一些题，找了找感觉

# <font style="color:rgb(38, 38, 38);">下周待做事项</font>
 1. 学车车
 2. unictf
 3. furryctf
 4. 书籍阅读
 5. 数据结构的学习，AVL树，红黑树，哈希表

# <font style="color:rgb(38, 38, 38);">本周学习的知识分享</font>
# **梳理复习内容详见博客**
---
# 数据结构：树
## 核心概念
### 根节点
#### 介绍
整棵树的起点，没有父节点。一棵树只有一个根。
### 节点
#### 介绍
树的基本单位，包含数据和指向子节点的指针。
### 父节点与子节点
#### 介绍
直接连接的上下级关系。上面的叫父，下面的叫子。
### 叶子节点
#### 介绍
没有子节点的末梢节点。
### 高度与深度
#### 介绍
+ 高度：从当前节点往最远的叶子节点数。（下面还有几代）
+ 深度：从根节点往下数，根的深度通常定义为 0。（第几代）
+ 树的高度决定了查找一个数据最坏要跳转几次指针
### 子树
### 度
**一个节点拥有的直接子节点个数，就叫这个节点的“度”**
## 表现
``` c
#include <stdint.h>
#include <stdlib.h>

typedef struct BinNode {
    uint64_t data;            // 存储数据（可以是数值，也可以是另一个内存地址）
    struct BinNode *left;     // 左子树指针 (8 字节)
    struct BinNode *right;    // 右子树指针 (8 字节)
    int32_t height;           // 平衡高度
} BinNode;

BinNode* create_node(uint64_t value) {
    BinNode* node = (BinNode*)malloc(sizeof(BinNode)); // 在堆上申请空间
    if (node) {
        node->data = value;
        node->left = NULL;
        node->right = NULL;
        node->height = 1; // 新节点初始高度设为 1
    }
    return node;
}
```
## 插入
``` c
void link_left(BinNode *parent, BinNode *new_child) {
    if (parent == NULL) return;
    parent->left = new_child; // 将父节点的左指针成员，指向新节点的首地址
}
```
## 分类
### 形态
#### 完美二叉树
+ 特征：极其对称。每一层都是满的，一个空位都没有。
+ 高度为 h , 节点数 一定为 2 的 h+1 次方 -1
#### 完全二叉树
+ 特征：**最后一层可以不满**，不过必须**从左往右**排。
#### 完满二叉树
+ 特征：每个节点要么**没有叶子**，要么**有两个叶子**。绝对不存在只有一个叶子的情况
#### 平衡二叉树
+ 特征：任意节点的左右子树高度差不超过 1。
+ 意义：防止退化成链表
#### 退化树
+ 特征：链表
### 逻辑
#### 二叉搜索树
- 若它的左子树不为空，左子树上所有节点的值都小于它的根节点。
- 若它的右子树不为空，右子树上所有的节点的值都大于它的根节点。
##### 二分查找
- 1、等于所要查找的数据，直接找到
- 2、若小于要查找的数据，在小于部分分组继续查询
- 3、若大于，在大于部分分组继续查询
#### 自平衡搜索树
##### AVL 树
+ **优点：** 树非常矮，**查询速度极快**，因为路程短。
##### 红黑树
+ **特点：** 它保证最长路径不会超过最短路径的两倍。
-  **优点：** **旋转的次数少**。插入和删除时非常高效。
## 遍历
### 层序遍历
+ 逐层扫描，横向扫完再扫纵向
+ **顺序：** 第一层（根）→ 第二层 → 第三层
- **工具：** 必须借助 **队列 (Queue)**。
- **代码逻辑（伪代码/C思路）：**
    1. 把根节点放进队列。
    2. 当队列不为空时：
        - 从队列头拿出一个节点 。
        - 打印/处理 的值。
        - 把左子树和右子树依次放进队列尾。
### 深度遍历
#### 前序遍历
- **逻辑：根 → 左 → 右**（根在最前面）。
- **应用：** 常用于树的复制。
- **递归代码：**
```c
   void preOrder(Node *root) {
    if (!root) return;
    printf("%d ", root->val); // 1. 先根
    preOrder(root->left);     // 2. 再进左
    preOrder(root->right);    // 3. 最后右
}
```
#### 中序遍历
- **逻辑：左 → 根 → 右**（根在中间）。
- 如果这是一棵二叉搜索树 ，中序遍历出来的结果一定是从小到大排好序的
- **递归代码：**
    ```c
        void inOrder(Node *root) {
        if (!root) return;
        inOrder(root->left);      // 1. 先去最左
        printf("%d ", root->val); // 2. 处理根
        inOrder(root->right);     // 3. 再去右
    }
    ```
#### 后序遍历
- **逻辑：左 → 右 → 根**
- **应用：** 常用于**树的销毁 (free)**。
- **递归代码：**
    ```c
    void postOrder(Node *root) {
        if (!root) return;
        postOrder(root->left);
        postOrder(root->right);
        printf("%d ", root->val); // 处理根
    }
    ```
#### 对比
| **遍历方式** | **核心数据结构**     | **遍历顺序** | **典型用途**        |
| -------- | -------------- | -------- | --------------- |
| **层序遍历** | **队列 (Queue)** | 逐层从左到右   | 寻找最短路径、内存扫描     |
| **前序遍历** | **栈 / 递归**     | 根-左-右    | 序列化、结构复制        |
| **中序遍历** | **栈 / 递归**     | 左-根-右    | **BST 排序输出**    |
| **后序遍历** | **栈 / 递归**     | 左-右-根    | **内存释放 (free)** |
|          |                |          |                 |
# 汇编知识
**已同步至博客**

# <font style="color:rgb(38, 38, 38);">本周学习总结</font>
1. 树数据结构，简单了解遍历逻辑，核心概念，树的分类
2. pwn 的学习梳理，ret2text , ret2shellcode , ret2libc , ret2syscall , ret2orw , ret2csu , GOT 表劫持，栈迁移,多系统调用
3. 汇编书籍阅读



# <font style="color:rgb(38, 38, 38);">杂项</font>
**去南通逛了一周，感觉就是纯粹为了坐灰机**
