# <font style="color:rgb(38, 38, 38);">完成事项</font>
+ c语言学习任务
  简单了解 ret2libc

# <font style="color:rgb(38, 38, 38);">下周待做事项</font>
+ 继续深入学习ret2libc

# <font style="color:rgb(38, 38, 38);">本周学习的知识分享</font>
### 结构
#### struct
1.struct book {};创立了一个结构，这个结构名字叫做book
我们可以对这个结构进行一个声明，如struct book library 我们声明了一个变量，名字叫library，你可以把这个句子看成类似的 int library
我们可以struct book library ，也可以声明一个指针struct book * ptbook
我们也可以struct book {}library;
2.初始化
例：struct book {
    char title[41];
    char author[31];
    float value;
  }library;
我们可以这样子
``` c
struct book library = {
"The ........"
 "renee ..."
  1.95
};
```
对于部分初始化的，我们可以
``` c
struct book library = {
.value = 1.95
};
```
也可以
``` c
struct book library = {
  .value = 1.95,
  .title = "The ........",
  .author = "renee ..."
};
```
如果中间对某一个变量赋值了两次，那么值为最后一次赋的值
和数组的结合使用
``` c
struct node {
    int id;
    char name[16];
};
struct node arr[100];
```
那么在内存上的排列就是[id name][id name][id name] ... x100，arr[i] 就是算 index 乘 sizeof(node)
在一个数组中，我们也可以用同样遍历的方法对数组进行初始化
例 
``` c
for(int i = 0;i<100;i++)
{
   scanf("%d",&arr[i].id);
scanf("%15s",arr[i].name);
}
```



3.运算符
（1）.
例如：scanf("%f",&library.value);
当然，我们要注意的一点是在一个数组当中还是拿library举例
library是一个book结构的数组
library是一个数组元素
library[2].title是library[2]的一个title成员
library[2].title[4]是library[2]的一个title成员的一个字符
#### 嵌套结构
我们可以在一个结构体中再嵌套一个结构体
例如
``` c
struct names {       
    char first[LEN];
    char last[LEN];
};

struct guy {    
    struct names handle;  
    char favfood[LEN];
    char job[LEN];
    float income;
};
//我们可以这样子初始化
struct guy fellow = {   
    { "Ewen", "Villard" },
    "grilled salmon",
    "personality coach",
    68112.00
};
```
最后访问就变成了 fellow.handle.first
#### 指向结构的指针
我们之前讲到，可以这么声明
struct book * ptbook
也就是说，当前这个ptbook指针，只要是book类型的结构体，都可以去指向，就跟 int * ptbook是差不多的
比如有一个book 类型binary变量，可以ptbook = &binary
或 ptbook = &fellow[0]
代码示例
``` c
struct guy fellow[2] = {
    {{ "Ewen", "Villard"},
        "grilled salmon",
        "personality coach",
        68112.00
    },
    {{"Rodney", "Swillbelly"},
        "tripe",
        "tabloid editor",
        432400.00
    }
};
struct guy * him;  

printf("address #1: %p #2: %p\n", &fellow[0], &fellow[1]);
him = &fellow[0];   
printf("pointer #1: %p #2: %p\n", him, him + 1);
printf("him->income is $%.2f: (*him).income is $%.2f\n",him->income, (*him).income);
him++;//此时him指向fellow[1]             
printf("him->favfood is %s:  him->handle.last is %s\n",him->favfood, him->handle.last);
```
我们也可以用指针对成员进行访问
如果him = &fellow[0]
我们可以用him -> income来表示
当然fellow[0].income= (*him).income

在现在的c中，两个相同结构的结构体，我们可以把一个结构初始化另一个结构，我们也可以把一个结构赋值给另一个结构，即使一个结构中含有数组，也可以完成，但是我们不能把一个数组赋值给另一个数组。
举个例子
``` c
	struct exam {
		int score;
		int rank;
	};
	struct exam s1 = {
		88,
		11
	};
	struct exam s2 = s1;//这是初始化的一种方法
	//也可以赋值
	struct exam s3;
	s3 = s1;
```
有一个潜在的风险
``` c
struct pnames {char * first;char * last;};
/*如果*/struct pnames trees;
scanf("%s",trees.last);
```
由于指针里面的地址没有进行初始化，所以这是一个随机值，当我们往这个地址里面填值，可能会导致程序崩溃
所以我们可以使用malloc，分配一个空间，把这个空间的地址赋值给这个指针，之后就可以进行填充了，但是注意使用完我们需要free
我们也可以使用复合字面量
``` c
struct book readfirst;
    readfirst = (struct book) {"Crime and Punishment",
        "Fyodor Dostoyevsky",
        11.25};
```
可是有人问，这样子不是多此一举么，临时结构这种情况要开辟两个空间，一个给readfirst，一个给临时开辟的匿名的，然后把匿名的赋值给readfirst之后销毁，那还不如直接初始化，但是复合字面量一开始就不是去优化程序的，而是为了以下几个情景
比如 1.if else语块，如果在语块中初始化，那么结束后也就销毁了
2.函数传参时 ，临时创建一个匿名结构体，进行传参，可以传整个结构体，也可以传值
3.数组、指针、嵌套初始化

下面讲一讲伸缩性数组
当我们在栈上定义一个结构体时，并没有给伸缩数组分配空间，也就是说之给其他确定了的元素才会分配，因此，如果我们想要给这个结构体分配完整的的空间，我们必须通过动态分配（malloc,calloc)进行分配，也就是说分配的大小是不包括伸缩性数组的结构体的大小加上即将分配的数组的大小

#### union
联合中，只分配一个变量的空间，这个变量是占据空间最大的那个变量，每次使用时只使用这一个空间。
可以对联合进行初始化，每次只能存储一个值。也就是说，比如这个联合中有三个类型，一个int,一个double，一个char，当我们初始化一个时，上一个我们初始化过的类型就没法进行使用了，因为一部分空间已经被新赋的值给覆盖掉了
#### typedef
与#define类似，但是这个只能用于自定义名称，受限于类型，，不能用于值
例如type char* x
x name ,sign;
相当于 char* name,*sign
但如果是define，只能是
x * name,sign
#### 几个新函数学习
1.fopen 
定义
``` c
FILE *fopen(const char *filename, const char *mode);

```
filename:文件名或路径，例如 "data.txt" 或 "C:\\test\\file.bin"
mode:打开模式字符串，控制文件读写方式
"r"	以只读方式打开文本文件，文件必须存在
"w"	以写入方式打开文本文件，文件存在则清空，不存在则创建
"a"	以追加方式打开文本文件，不存在则创建
"rb", "wb", "ab"	同上，但以二进制方式打开
"r+"	可读可写，文件必须存在
"w+"可读可写，文件存在会清空，不存在则创建
"a+"	可读可写，写入时只能追加到末尾        
返回值  ：成功：返回 FILE *
                失败：返回 NULL
2.fgets
定义
``` c
char *fgets(char *str, int n, FILE *stream);
```
str 一个地址，用来存放 存入字符串的地址
n 读入的最大的字符数，包括\0
stream 文件指针
也就是最多读取n-1个字符，\0自动补，会存入\n（不会自动去除），若遇 EOF 或错误，返回 NULL
fgets() 在文件结束且未读到任何字符，或发生读错误时返回 NULL
3.fputs
定义
``` c
int fputs(const char *str, FILE *stream);
```
不会自己加\n，（区别于puts）
4.fread
定义
``` c
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);

```
ptr	目标内存地址
size	每个数据单元的字节数
nmemb	数据单元数量
stream	文件指针

#### 枚举
使用符号来表达常量
使用enum关键字可以创建一个类型（类似结构体），一般的，这个结构中的变量名按照顺序依次表示0，1，2，3.....，但我们仍然可以对其中变量赋值，但注意/之后的变量会按照刚赋值的继续累加下去

#### 优先级
函数后的（），数组后的[ ]，比*优先级更高
例
``` c
int * risks[10] //这个就是指针数组
int (*risks)[10] //这个就是数组的指针
```
而在c中，由于函数名在表达式中，自动退化成指针，我们也可以创建如char （*flump[3])(int),
当我们平常创建一个函数时，比如char p1(int x),其实会退化成char (*)(int)即退化成指针，那么我们也可以像char （*flump[3])(int)这样一样，这个数组中都存放一个指针，这个指针指向一个函数，函数接收int类型参数，返回char类型

### ret2libc
#### 定义
顾名思义，这个攻击手法就是通过栈溢出，返回到libc库中，运用libc库中存在的函数，比如system，来执行命令，这种攻击方式可以绕过段不可执行
当然，想要通过这种方式去攻击，需要满足一些条件
1.只能调用 libc 里存在的函数
2.参数正确
3.地址可以泄露
4.存在溢出
5.可控制返回地址
6.知晓libc库版本
#### 函数调用约定
第一：RDI
第二：RSI
第三：RDX
第四：RCX
第五：R8
第六：R9
剩下在栈上传
而 ret2libc 是通过“构造栈”或“构造寄存器值”去满足这些约定
#### ELF程序加载流程
在c中，我们知道，编译器将源代码变成中间代码，链接器将中间代码和其他文件代码进行链接，并最终生成可执行文件
而程序启动时，动态链接器负责
1.映射可执行文件
2.加载共享库（libc.so）
3.解析符号，将函数转变成精确的地址
最后进程地址空间中就存在libc.so,可执行文件,stack,heap
#### GOT PLT
所谓got， Global Offset Table，就是一个指针数组，一开始会写入PLT内部指令，会被动态链接，加载器（ld.so）在首次调用会进行更新，里面记录了各个数据的真实地址，包括函数，参数，等
而PLT是什么，就是机器指令，用来跳到GOT中存放的地址
而所谓如何进行更新，我就浅谈一下我的理解。
printf 第一次调用 PLT/GOT 流程

假设 printf@plt 的汇编如下：
``` css
1030: jmp *0x2fca(%rip) ; 跳 GOT[printf]
1036: push $0x0         ; push 重定位索引
103b: jmp 1020          ; 跳到 plt0
```
jmp GOT[printf]：第一次调用时，GOT[printf] 并不是真正的函数地址，而是 指向 1036 的 push 指令。
执行后，程序会继续到 push $0x0，将重定位索引压栈。
这个索引告诉动态链接器：当前要解析的函数是第 0 条条目
进入 PLT0
``` css
1020: push 0x2fca(%rip)      ; push link_map
1026: jmp  *0x2fcc(%rip)     ; jmp 动态链接器入口
```
push link_map,把动态链接器需要的全局状态压栈（link_map 链表头）。之后jmp 到动态链接器，通常是 _dl_runtime_resolve，负责解析函数真实地址。之后读取重定位索引参数，确定要解析哪条重定位表条目。
接下来遍历 link_map：
link_map 是一个双向链表，存放已加载共享库的信息（库名、基址、状态等）。
动态链接器遍历 link_map，查找包含目标符号的库。
每个共享库有符号表和符号名字符串表。
根据重定位表条目中的符号索引找到符号，匹配符号名。之后就能计算真实地址，
真实地址 = 符号表偏移量 + 共享库基址
最后更新 GOT将计算出的真实地址写入 GOT[printf]。之后再调用 printf，就直接跳 GOT，不再执行解析流程。
而以上，这就是第一次调用一个函数的全过程，这些步骤我们在IDA上只能看到一个call指令，但是在各种段中，其实还发生了数据交换
而以上也牵扯到.got.plt 和 .plt.got的区别.got.plt属于GOT的一部分它是GOT中专门服务于过程链接表的部分，主要用于实现函数的延迟绑定，也就是上文的第一次调用，从 .got.plt[3] 开始，才是各个需要动态链接的函数的地址槽（例如 printf, scanf 等）
.plt.got本质是一个代码段，属于PLT的一部分。对于第二次调用时进行使用，非延迟
``` python
payload=b"a"*0x28+p64(pop_rdi)+p64(elf.got["puts"])+p64(elf.plt["puts"])
```
在这个代码中，我们为什么不使用got表中的真实地址，那是因为这个在数据段，而plt在代码段，我们使用plt去跳转，或触发解析
# <font style="color:rgb(38, 38, 38);">本周学习总结</font>
c语言相关知识，结构联合声明，enum,typedef关键字，指向函数指针，ret2libc相关知识

