# <font style="color:rgb(38, 38, 38);">完成事项</font>
+ 汇编书籍
+ 数据结构

# <font style="color:rgb(38, 38, 38);">下周待做事项</font>
+ 阅读汇编书籍
+ 数据结构
+ 汇编代码的实操

# <font style="color:rgb(38, 38, 38);">本周学习的知识分享</font>
# **1.计算机启动** 

1. 按下电源或复位，CPU 内部寄存器变成固定的数值，以 8086 为例
     + CS = 0xFFFF
     + IP = 0x0000
2. 寻址：由于之前学习我们知道，物理地址 = CS * 16 + IP
     + 代入：0xFFFF * 0x10 + 0x0000 = 0xFFFF0 ，这个是第一个地址
     + 为何不在低位？ ： 低位给 RAM, 断电后数据丢失，因此需要去内存顶端找 ROM，去寻找代码
     + DRAM 占据低端 640 KB , ROM 占据顶端 64 KB
3. 跳转：第一条指令为跳转，类似于 jmp 0xf000:0xe05b 。
# **2. 显存映射与字符属性 (VRAM)**

在没有操作系统的底层环境下，控制屏幕显示实质上是操作特定内存地址：

- **显存地址：** 文本模式下显存起始于物理地址 **0xB8000**。
    
- **存储格式：** 一个字符占 2 字节：低地址存放 ASCII 码（如 'L' 为 0x4C），高地址存放颜色属性（如 0x07 表示黑底白字）。
# 3.链表
## 定义
**链表由一系列动态分配在堆上的结构体组成的。每个结构体为一个节点**
## 组成
+ 指针域
+ 数据域
## 结构
+ 头指针：进入链表
+ 头节点：链表第一个节点
+ 尾节点：指向 Null 的节点
+ 尾指针：指向最后一个节点
## 主要类型
+ 单向链表
+ 双向链表
+ 循环链表

## 单向链表
### 定义
只能单向向后遍历的一种链表，只能从头节点开始


#### 表示
``` c
struct Node {
    long data;        // 数据域：占用 8 字节
    struct Node* next;    // 指针域：占用 8 字节（存储下一个节点的内存地址）
};
```
```c
struct Node *node1 = (struct Node *)malloc(sizeof(struct Node));
struct Node *node2 = (struct Node *)malloc(sizeof(struct Node));
node1->next = node2
```

### 插入
```c
struct Node *node1 = (struct Node *)malloc(sizeof(struct Node));
struct Node *node2 = (struct Node *)malloc(sizeof(struct Node));
struct Node *node3 = (struct Node *)malloc(sizeof(struct Node));
node1->next = node2
node3->next = node1->next
node1->next = node3
```
### 删除
+ 假设链表 A->B->C，删除 B，已知 A
```C
A->next = A->next->next //错误示范：直接覆盖了 B ，造成我们无法查询B的地址，无法回收
```
```c
struct Node *temp = A->next
A->next = A->next->next
free(temp)
```
## 双向链表
### 表示
```c
struct Node {
    long data;           // 8 字节：数据域
    struct Node* next;   // 8 字节：指向后一个节点的地址
    struct Node* prev;   // 8 字节：指向前一个节点的地址
};
```
+ 特性
   + 双向遍历
   + 冗余性：A 的 next 指向 B,B 的 prev 指向 A
   + 高效删除：
### 插入
#### 逻辑顺序
在 AC 间进行插入 B
1. B->next = C
2. B->prev = A
3. A->next = B
4. C->prev = B
### 删除
+ 假设链表 A <-> B <-> C，我们要删除 B。
+ **核心逻辑**：绕过 B，让 A 和 C 建立双向互指关系。
```c
//假设 temp 指针指向 B
struct Node *temp = B;
temp->prev->next=temp->next; //A -> C
temp->next->prev=temp->prev; //C -> A


free(temp);
```
## 循环链表
### 定义
尾节点的 next 不指向 NULL , 指向头节点
### 特性
+ 遍历不设置停止条件会进入无限循环
+ 尾节点 next 指向头节点，头节点 prev 指向尾节点
# 4. 寻址
``` asm
1. 立即寻址
	 mov eax, 11
     sub eax, 1
2. 寄存器寻址
     mov ebx, 0x3  
     mov edx, ebx   
3. 直接寻址
     mov ecx, msg      ; 将msg的地址赋值给ecx
4. 寄存器间接寻址
     mov esi, msg        ; 将msg的地址赋值给esi
     mov eax, [esi]      ; 将esi所指向的地址的值赋值给eax
5. 寄存器相对寻址
     mov ebx, msg        ; 将 msg 的首地址传给 ebx
	add ebx, 8          ; 手动将地址向后移动 8 字节（跳过两个双字）
	mov edx, [ebx]      ; 取出 ebx 指向地址处的内容，存入 edx
6. 基址变址寻址方式
     mov esi, msg ; 用 esi 作为基址寄存器，存放起始地址 
     mov edi, 3 ; 用 edi 作为变址寄存器，存放索引值 3
     mov eax, [esi + edi*4]  ; 将esi + edi*4所指向的地址的值赋值给eax
7. 相对基址变址寻址方式
     mov ebx, msg        ; ebx 存储基础地址
	mov ecx, 2          ; ecx 存储索引
	add ebx, 16         ; 先给基址增加 16 字节的偏移
	mov edx, [ebx + ecx*4 - 8]  ; 最终地址 ebx + ecx*4 - 8。取出该处值存入 edx
```
# 5.队列
## 定义

**队列是只允许在表的一端进行插入，而在另一端进行删除操作的线性表。**

## 特性

- **先进先出**
- **操作受限**：只能从队尾进，队头出。

## 组成

- **队头 (Front)**：允许删除的一端。
- **队尾 (Rear)**：允许插入的一端。
## 主要类型

### 1. 顺序队列

**由一段连续的内存空间（数组）组成。**

#### 表示
```c
#define MAXSIZE 100
typedef struct {
    int data[MAXSIZE];  // 数组存储数据域
    int front;           // 队头下标
    int rear;            // 队尾下标
}SeqQueue;
```
#### 假满

在顺序队列中，随着入队和出队操作，front 和 rear 都会向高位移动。当 rear 到达 MAXSIZE 时，即使数组低位因为出队而空出来了，也无法再插入。
#### 改进：循环队列

**逻辑上将数组的首尾相接，形成一个环。**
+ 队空：front == rear
+ 队满：(rear + 1) % MAXSIZE == front 

- **入队地址计算**：(rear + 1) % MAXSIZE
- **出队地址计算**：(front + 1) % MAXSIZE
### 2. 链式队列

**由动态分配在堆上的结构体节点组成。**
#### 表示
```c
// 定义节点结构
struct Node {
    long data;           // 数据域
    struct Node* next;   // 指针域
};

// 定义队列控制结构
struct LinkedQueue {
    struct Node* front;  // 指向队头节点
    struct Node* rear;   // 指向队尾节点
};
```
#### 操作逻辑

1. **入队 (Push)**：
    - 在堆上 malloc 一个新节点。
    - 让当前 rear->next 指向新节点。
    - 更新 rear 指向这个新节点。
2. **出队 (Pop)**：
    - 暂存 front 指向的节点。
    - 让 front 指向下一个节点（front = front->next）。
    - free 掉暂存的旧节点内存。
3. **如果队列原本为空，即第一个节点是头也是尾，同时新节点的next指向NULL**
# <font style="color:rgb(38, 38, 38);">本周学习总结</font>
**学习了部分数据结构，阅读汇编书籍，之后还需要加快进度**

# <font style="color:rgb(38, 38, 38);">杂项</font>
+ 学开车车

